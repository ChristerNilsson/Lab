// Generated by CoffeeScript 1.12.7
var Button, angle, buttons, currentLanguage, direction, draw, dt, fetchFromLocalStorage, findWords, handleMousePressed, index, language, languages, level, maxWord, maxWordSize, mousePressed, mouseReleased, newGame, possibleWords, radius1, radius2, radius3, radius4, radius5, released, reverseString, saveToLocalStorage, selLanguage, selectWords, setup, showWordInfo, size, solution, touchEnded, touchStarted, word, wordList, words, wrap,
  modulo = function(a, b) { return (+a % (b = +b) + b) % b; },
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

wordList = null;

words = null;

index = 0;

word = '';

level = 0;

angle = 0;

direction = 1;

size = null;

radius1 = null;

radius2 = null;

radius3 = null;

radius4 = null;

radius5 = null;

possibleWords = [];

solution = "";

dt = 0;

maxWord = 4;

languages = 'dan eng fra ger isl ita nor rus spa swe'.split(' ');

language = 9;

currentLanguage = language;

released = true;

buttons = [];

Button = (function() {
  function Button(txt, r1, degrees, r2, f) {
    this.txt = txt;
    this.r1 = r1;
    this.degrees = degrees;
    this.r2 = r2;
    this.f = f;
    this.x = this.r1 * cos(radians(this.degrees));
    this.y = this.r1 * sin(radians(this.degrees));
  }

  Button.prototype.draw = function() {
    fc(0.45);
    circle(this.x, this.y, this.r2);
    fc(0);
    return text(this.txt, this.x, this.y);
  };

  Button.prototype.mousePressed = function(mx, my) {
    if (this.r2 > dist(mx, my, width / 2 + this.x, height / 2 + this.y)) {
      return this.f();
    }
  };

  return Button;

})();

fetchFromLocalStorage = function() {
  var arr, lang, s;
  lang = languages[language];
  s = localStorage["lettero-" + lang];
  if (s) {
    arr = s.split(' ');
    maxWord = parseInt(arr[0]);
    return level = parseInt(arr[1]);
  } else {
    maxWord = 4;
    return level = 0;
  }
};

saveToLocalStorage = function() {
  var lang;
  lang = languages[language];
  return localStorage["lettero-" + lang] = maxWord + " " + level;
};

setup = function() {
  var radius6;
  language = languages.indexOf(document.title.toLowerCase().split(' ')[1]);
  currentLanguage = language;
  fetchFromLocalStorage();
  createCanvas(windowWidth, windowHeight);
  size = min(width, height);
  radius2 = size / 12;
  radius1 = 0.5 * size - radius2;
  radius3 = 0.6 * radius1;
  radius4 = radius1 - radius2;
  radius5 = 0.05 * size;
  radius6 = 0.59 * size;
  wordList = ordlista.split(' ');
  words = selectWords();
  textAlign(CENTER, CENTER);
  buttons.push(new Button('15', radius6, 45, radius2, (function(_this) {
    return function() {
      return maxWordSize(1);
    };
  })(this)));
  buttons.push(new Button('4', radius6, 45 + 90, radius2, (function(_this) {
    return function() {
      return maxWordSize(-1);
    };
  })(this)));
  buttons.push(new Button('spa', radius6, 45 + 270, radius2, (function(_this) {
    return function() {
      return selLanguage(1);
    };
  })(this)));
  buttons.push(new Button('dan', radius6, 45 + 180, radius2, (function(_this) {
    return function() {
      return selLanguage(-1);
    };
  })(this)));
  return newGame(0);
};

maxWordSize = function(d) {
  maxWord = 4 + modulo(maxWord - 4 + d, 15 - 4 + 1);
  saveToLocalStorage();
  return words = selectWords();
};

selLanguage = function(d) {
  var n;
  n = languages.length;
  return language = modulo(language + d, n);
};

newGame = function(dLevel) {
  var extra;
  if (language !== currentLanguage) {
    window.location.href = languages[language] + ".html";
  }
  solution = possibleWords.join(' ');
  direction = dLevel;
  extra = int(level / 10);
  if (dLevel < 0 && extra !== 0) {
    dLevel *= extra;
  }
  level += dLevel;
  if (level < 0) {
    level = 0;
  }
  word = words[index];
  index++;
  index %= words.length;
  possibleWords = findWords(word);
  if (0.5 < random()) {
    word = reverseString(word);
  }
  word = word.toUpperCase();
  angle = 360 * random();
  saveToLocalStorage();
  return false;
};

wrap = function(first, last, value) {
  return first + modulo(value - first, last - first + 1);
};

draw = function() {
  var button, ch, dAngle, i, j, k, len, len1, n;
  bg(0.5);
  push();
  translate(width / 2, height / 2);
  buttons[0].txt = wrap(4, 15, maxWord + 1);
  buttons[1].txt = wrap(4, 15, maxWord - 1);
  n = languages.length;
  buttons[2].txt = languages[modulo(language + 1, n)];
  buttons[3].txt = languages[modulo(language - 1, n)];
  textSize(0.09 * size);
  for (j = 0, len = buttons.length; j < len; j++) {
    button = buttons[j];
    button.draw();
  }
  textSize(0.11 * size);
  text(languages[language] + "-" + maxWord, 0, -0.2 * size);
  textSize(0.06 * size);
  text(solution, 0, 0.18 * size);
  pop();
  textSize(size / 4);
  if (direction === 1) {
    fc(0, 1, 0);
  } else {
    fc(1, 0, 0);
  }
  text(level, width / 2, height / 2);
  fc(0);
  translate(width / 2, height / 2);
  n = word.length;
  dAngle = 360 / n;
  rd(angle);
  textSize(size / 10);
  for (i = k = 0, len1 = word.length; k < len1; i = ++k) {
    ch = word[i];
    push();
    translate(radius1, 0);
    rd(90);
    fc(1, 1, 0);
    circle(0, 0, radius2);
    fc(0);
    text(ch, 0, 0);
    pop();
    rd(dAngle);
  }
  angle += (millis() - dt) / 50;
  return dt = millis();
};

selectWords = function() {
  var w;
  index = 0;
  return _.shuffle((function() {
    var j, len, results;
    results = [];
    for (j = 0, len = wordList.length; j < len; j++) {
      w = wordList[j];
      if (w.length <= maxWord) {
        results.push(w);
      }
    }
    return results;
  })());
};

showWordInfo = function() {
  var arr, lan, url;
  arr = solution.split(' ');
  if (arr.length === 0) {
    return;
  }
  released = true;
  url = '';
  lan = languages[language];
  if (lan === 'swe') {
    url = "https://svenska.se/tre/?sok=" + arr[0];
  }
  if (lan === 'rus') {
    url = "https://ru.wiktionary.org/w/index.php?search=" + arr[0];
  }
  if (url !== '') {
    return window.open(url, '_blank');
  }
};

handleMousePressed = function() {
  var button, ch, dword, i, j, k, len, len1, n, results, rw, w, x, y;
  if (released) {
    released = false;
  } else {
    return;
  }
  if (dist(mouseX, mouseY, width / 2, height / 2) < radius2) {
    return showWordInfo();
  } else if (dist(mouseX, mouseY, width / 2, height / 2) > radius1 + radius2) {
    results = [];
    for (j = 0, len = buttons.length; j < len; j++) {
      button = buttons[j];
      results.push(button.mousePressed(mouseX, mouseY));
    }
    return results;
  } else {
    n = word.length;
    dword = (word + word).toLowerCase();
    for (i = k = 0, len1 = word.length; k < len1; i = ++k) {
      ch = word[i];
      x = width / 2 + radius1 * cos(radians(angle + i / n * 360));
      y = height / 2 + radius1 * sin(radians(angle + i / n * 360));
      if (radius2 > dist(mouseX, mouseY, x, y)) {
        w = dword.slice(i, i + n);
        rw = reverseString(dword).slice(n - i - 1, n - i + n - 1);
        if (indexOf.call(possibleWords, w) >= 0 || indexOf.call(possibleWords, rw) >= 0) {
          return newGame(1);
        } else {
          return newGame(-1);
        }
      }
    }
  }
};

reverseString = function(str) {
  return str.split("").reverse().join("");
};

mousePressed = function() {
  handleMousePressed();
  return false;
};

touchStarted = function() {
  handleMousePressed();
  return false;
};

mouseReleased = function() {
  released = true;
  return false;
};

touchEnded = function() {
  released = true;
  return false;
};

findWords = function(word) {
  var ch, dword, i, j, len, n, res, rw, w;
  n = word.length;
  dword = (word + word).toLowerCase();
  res = [];
  for (i = j = 0, len = word.length; j < len; i = ++j) {
    ch = word[i];
    w = dword.slice(i, i + n);
    rw = reverseString(dword).slice(n - i - 1, n - i + n - 1);
    if (wordList.binaryIndexOf(w) !== -1) {
      res.push(w);
    }
    if (wordList.binaryIndexOf(rw) !== -1) {
      res.push(rw);
    }
  }
  return _.uniq(res);
};

Array.prototype.binaryIndexOf = function(item) {
  'use strict';
  var currIndex, currItem, maxIndex, minIndex;
  minIndex = 0;
  maxIndex = this.length - 1;
  while (minIndex <= maxIndex) {
    currIndex = (minIndex + maxIndex) / 2 | 0;
    currItem = this[currIndex];
    if (currItem < item) {
      minIndex = currIndex + 1;
    } else if (currItem > item) {
      maxIndex = currIndex - 1;
    } else {
      return currIndex;
    }
  }
  return -1;
};

//# sourceMappingURL=sketch.js.map
