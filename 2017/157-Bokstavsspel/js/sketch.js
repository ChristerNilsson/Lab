'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// Generated by CoffeeScript 2.0.3
var Enemy,
    Game,
    Player,
    draw,
    game,
    keyTyped,
    setup,
    indexOf = [].indexOf;

game = null;

Game = function () {
  function Game() {
    _classCallCheck(this, Game);

    this.N = 11;
    this.score = 0;
    this.highScore = 0;
    this.size = min(windowWidth, windowHeight);
    this.SIZE = this.size / this.N;
    this.newGame();
  }

  _createClass(Game, [{
    key: 'newGame',
    value: function newGame() {
      this.player = new Player(width / 2, height / 2);
      this.enemies = {};
      this.interval = 200;
      this.speed = 1;
      this.highScore = max(this.highScore, this.score);
      return this.score = 0;
    }
  }, {
    key: 'draw',
    value: function draw() {
      var enemy, k, letter, r, ref;
      bg(0.5);
      this.player.draw();
      ref = this.enemies;
      for (k in ref) {
        enemy = ref[k];
        if (enemy) {
          enemy.draw();
        }
      }
      fc(0);
      text(this.score, this.SIZE, this.SIZE);
      text(this.highScore, width - this.SIZE, this.SIZE);
      if (frameCount % this.interval === 0) {
        this.interval -= 1;
        this.speed *= 1.05;
        r = int(random(4));
        while (_.size(this.enemies) < 30) {
          letter = _.sample("'" + 'abcdefghijklmnopqrstuvwxyzåäö' + '0123456789[]{}().,-+*/%!@#=<>":'.slice(0, this.score));
          if (indexOf.call(_.keys(this.enemies), letter) >= 0) {
            if (!this.enemies[letter].active) {
              break;
            }
          } else {
            break;
          }
        }
        if (r === 0) {
          this.enemies[letter] = new Enemy(letter, this.player.x, 0, 0, this.speed * height / this.size);
        }
        if (r === 1) {
          this.enemies[letter] = new Enemy(letter, this.player.x, height, 0, -this.speed * height / this.size);
        }
        if (r === 2) {
          this.enemies[letter] = new Enemy(letter, 0, this.player.y, this.speed * width / this.size, 0);
        }
        if (r === 3) {
          return this.enemies[letter] = new Enemy(letter, width, this.player.y, -this.speed * width / this.size, 0);
        }
      }
    }
  }, {
    key: 'keyTyped',
    value: function keyTyped(k) {
      if (indexOf.call(_.keys(this.enemies), k) >= 0 && this.enemies[k].active) {
        this.score++;
        return this.enemies[k].active = false;
      } else {
        return this.newGame();
      }
    }
  }]);

  return Game;
}();

Enemy = function () {
  function Enemy(letter1, x1, y1, dx, dy) {
    _classCallCheck(this, Enemy);

    this.letter = letter1;
    this.x = x1;
    this.y = y1;
    this.dx = dx;
    this.dy = dy;
    this.active = true;
  }

  _createClass(Enemy, [{
    key: 'draw',
    value: function draw() {
      if (!this.active) {
        return;
      }
      this.x += this.dx;
      this.y += this.dy;
      fc(0);
      text(this.letter, this.x, this.y);
      if (10 > game.player.dist(this.x, this.y)) {
        return game.newGame();
      }
    }
  }]);

  return Enemy;
}();

Player = function () {
  function Player(x1, y1) {
    _classCallCheck(this, Player);

    this.x = x1;
    this.y = y1;
  }

  _createClass(Player, [{
    key: 'draw',
    value: function draw() {
      fc(1);
      return rect(this.x, this.y, game.SIZE, game.SIZE);
    }
  }, {
    key: 'dist',
    value: function (_dist) {
      function dist(_x, _x2) {
        return _dist.apply(this, arguments);
      }

      dist.toString = function () {
        return _dist.toString();
      };

      return dist;
    }(function (x, y) {
      return dist(x, y, this.x, this.y);
    })
  }]);

  return Player;
}();

draw = function draw() {
  return game.draw();
};

keyTyped = function keyTyped() {
  return game.keyTyped(key.toLowerCase());
};

setup = function setup() {
  createCanvas(windowWidth, windowHeight);
  game = new Game();
  rectMode(CENTER);
  textAlign(CENTER, CENTER);
  return textSize(game.SIZE);
};
//# sourceMappingURL=sketch.js.map
