{
  "version": 3,
  "file": "solver.js",
  "sourceRoot": "..",
  "sources": [
    "coffee\\solver.coffee"
  ],
  "names": [],
  "mappings": "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",
  "sourcesContent": [
    "class SolverState\n\tconstructor: (@grid, steps) ->\n\t\tlowerSolutionBound = @grid.lowerSolutionBound()\n\t\t@steps = steps.slice()\n\t\t@solved = @grid.isSolved()\n\t\t@val = lowerSolutionBound + steps.length\n\nclass SolverStateMinHeap\n\tmaxSize: 100000\n\n\tconstructor: -> @data = []\n\n\tenqueue: (pt) ->\n\t\t@data.push pt\n\t\t@bubbleUp @data.length - 1\n\t\tif @data.length == @maxSize then @data.pop()\n\n\tdequeue: ->\n\t\tret = @data[0]\n\t\tend = @data.pop()\n\t\tif @data.length > 0\n\t\t\t@data[0] = end\n\t\t\t@bubbleDown 0\n\t\tret\n\n\tbubbleUp: (curPos) ->\n\t\tif curPos == 0 then return\n\t\tparentPos = (curPos - 1) // 2\n\t\tcur = @data[curPos]\n\t\tparent = @data[parentPos]\n\t\tif cur.val < parent.val\n\t\t\t@data[curPos] = parent\n\t\t\t@data[parentPos] = cur\n\t\t\t@bubbleUp parentPos\n\n\tbubbleDown: (curPos) ->\n\t\tleftPos  = curPos * 2 + 1\n\t\trightPos = curPos * 2 + 2\n\t\tcur   = @data[curPos]\n\t\tleft  = @data[leftPos]\n\t\tright = @data[rightPos]\n\t\tswapPos = null\n\t\tif left? and left.val < cur.val then swapPos = leftPos\n\t\tif right? and right.val < left.val and right.val < cur.val then swapPos = rightPos\n\t\tif swapPos?\n\t\t\t@data[curPos] = @data[swapPos]\n\t\t\t@data[swapPos] = cur\n\t\t\t@bubbleDown swapPos\n\n\tempty: -> @data.length == 0\n\nsolve = (startGrid, frontier=null) ->\n\n\tif frontier == null\n\t\tfrontier = new SolverStateMinHeap\n\t\tstartState = new SolverState startGrid, []\n\t\tfrontier.enqueue startState\n\n\tits = 0\n\twhile not frontier.empty()\n\t\tits++\n\t\tif its > 100000 # 1000\n\t\t\twindow.setTimeout ->\n\t\t\t\tsolve startGrid, frontier\n\t\t\t, 10\n\t\t\treturn\n\n\t\tcurState = frontier.dequeue()\n\n\t\tif curState.solved\n\t\t\twindow.solution = curState.steps\n\t\t\tcurrent = 0\n\t\t\tgoState 2\n\t\t\treturn \n\n\t\tgrid = curState.grid\n\t\tsteps = curState.steps\n\n\t\tcandidates = _.shuffle grid.validMoves()\n\n\t\tlastStep = _.last steps\n\t\tif lastStep?\n\t\t\tcandidates = _(candidates).filter (x) ->  # why _ ?\n\t\t\t\tnot directionsAreOpposites x, lastStep\n\n\t\tfor sourceDirection in candidates\n\t\t\tnextGrid  = grid.applyMoveFrom sourceDirection\n\t\t\tnextSteps = steps.concat [sourceDirection]\n\t\t\tnextState = new SolverState nextGrid, nextSteps\n\t\t\tfrontier.enqueue nextState\n"
  ]
}