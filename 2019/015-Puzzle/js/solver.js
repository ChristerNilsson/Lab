"use strict";

// Generated by CoffeeScript 2.3.2
var SolverState, SolverStateMinHeap, solve;

SolverState = class SolverState {
  constructor(grid1, steps) {
    var lowerSolutionBound;
    this.grid = grid1;
    lowerSolutionBound = this.grid.lowerSolutionBound();
    this.steps = steps.slice();
    this.solved = this.grid.isSolved();
    this.val = lowerSolutionBound + steps.length;
  }

};

SolverStateMinHeap = function () {
  class SolverStateMinHeap {
    constructor() {
      this.data = [];
    }

    enqueue(pt) {
      this.data.push(pt);
      this.bubbleUp(this.data.length - 1);
      if (this.data.length === this.maxSize) {
        return this.data.pop();
      }
    }

    dequeue() {
      var end, ret;
      ret = this.data[0];
      end = this.data.pop();
      if (this.data.length > 0) {
        this.data[0] = end;
        this.bubbleDown(0);
      }
      return ret;
    }

    bubbleUp(curPos) {
      var cur, parent, parentPos;
      if (curPos === 0) {
        return;
      }
      parentPos = Math.floor((curPos - 1) / 2);
      cur = this.data[curPos];
      parent = this.data[parentPos];
      if (cur.val < parent.val) {
        this.data[curPos] = parent;
        this.data[parentPos] = cur;
        return this.bubbleUp(parentPos);
      }
    }

    bubbleDown(curPos) {
      var cur, left, leftPos, right, rightPos, swapPos;
      leftPos = curPos * 2 + 1;
      rightPos = curPos * 2 + 2;
      cur = this.data[curPos];
      left = this.data[leftPos];
      right = this.data[rightPos];
      swapPos = null;
      if (left != null && left.val < cur.val) {
        swapPos = leftPos;
      }
      if (right != null && right.val < left.val && right.val < cur.val) {
        swapPos = rightPos;
      }
      if (swapPos != null) {
        this.data[curPos] = this.data[swapPos];
        this.data[swapPos] = cur;
        return this.bubbleDown(swapPos);
      }
    }

    empty() {
      return this.data.length === 0;
    }

  };

  SolverStateMinHeap.prototype.maxSize = 100000;

  return SolverStateMinHeap;
}.call(undefined);

solve = function (startGrid, frontier = null) {
  var candidates, curState, current, grid, i, its, lastStep, len, nextGrid, nextState, nextSteps, sourceDirection, startState, steps;
  if (frontier === null) {
    frontier = new SolverStateMinHeap();
    startState = new SolverState(startGrid, []);
    frontier.enqueue(startState);
  }
  its = 0;
  while (!frontier.empty()) {
    its++;
    if (its > 100000) {
      // 1000
      window.setTimeout(function () {
        return solve(startGrid, frontier);
      }, 10);
      return;
    }
    curState = frontier.dequeue();
    if (curState.solved) {
      window.solution = curState.steps;
      current = 0;
      goState(2);
      return;
    }
    grid = curState.grid;
    steps = curState.steps;
    candidates = _.shuffle(grid.validMoves());
    lastStep = _.last(steps);
    if (lastStep != null) {
      candidates = _(candidates).filter(function (x) {
        // why _ ?
        return !directionsAreOpposites(x, lastStep);
      });
    }
    for (i = 0, len = candidates.length; i < len; i++) {
      sourceDirection = candidates[i];
      nextGrid = grid.applyMoveFrom(sourceDirection);
      nextSteps = steps.concat([sourceDirection]);
      nextState = new SolverState(nextGrid, nextSteps);
      frontier.enqueue(nextState);
    }
  }
};
//# sourceMappingURL=solver.js.map
