'use strict';

// Generated by CoffeeScript 2.3.2
var Button,
    buttons,
    current,
    draw,
    grid,
    mousePressed,
    originalGrid,
    prevNext,
    randomMoveList,
    setup,
    transfer,
    update,
    modulo = function (a, b) {
  return (+a % (b = +b) + b) % b;
};

buttons = [];

grid = null;

originalGrid = null;

current = 0;

Button = class Button {
  constructor(title, x1, y1, w, h, click) {
    this.title = title;
    this.x = x1;
    this.y = y1;
    this.w = w;
    this.h = h;
    this.click = click;
    this.active = true;
  }

  draw() {
    textAlign(CENTER, CENTER);
    textSize(30);
    if (this.title === 0) {
      fill(128);
    } else {
      fill(255);
    }
    rect(this.x, this.y, this.w, this.h);
    if (this.active) {
      fill(0);
    } else {
      fill(128);
    }
    if (this.title !== 0) {
      return text(this.title, this.x + this.w / 2, this.y + this.h / 2);
    }
  }

  inside() {
    return this.active && this.x < mouseX && mouseX < this.x + this.w && this.y < mouseY && mouseY < this.y + this.h;
  }

};

randomMoveList = function (grid, nMoves, moveList = []) {
  var last, ldc, ldr, nextGrid, sourceDirection, validMoves;
  if (moveList.length === nMoves) {
    return moveList;
  }
  validMoves = grid.validMoves();
  if (moveList.length > 0) {
    // Don't just revert the last move
    last = _.last(moveList);
    [ldr, ldc] = directionToDelta(last);
    validMoves = _.filter(validMoves, function (m) {
      return !directionsAreOpposites(last, m);
    });
  }
  sourceDirection = _.shuffle(validMoves)[0];
  nextGrid = grid.applyMoveFrom(sourceDirection);
  moveList.push(sourceDirection);
  return randomMoveList(nextGrid, nMoves, moveList);
};

transfer = function () {
  var i, j, len, ref, results;
  ref = range(16);
  results = [];
  for (j = 0, len = ref.length; j < len; j++) {
    i = ref[j];
    results.push(buttons[i].title = grid.grid[Math.floor(i / 4)][modulo(i, 4)]);
  }
  return results;
};

update = function (delta) {
  current = constrain(current + delta, 0, window.solution.length);
  grid = originalGrid.applyMoves(window.solution.slice(0, current));
  return transfer();
};

prevNext = function (value) {
  buttons[18].active = value;
  return buttons[19].active = value;
};

setup = function () {
  var i, j, len, ref, x, y;
  createCanvas(200 + 1, 350 + 1);
  ref = range(16);
  for (j = 0, len = ref.length; j < len; j++) {
    i = ref[j];
    x = i % 4;
    y = Math.floor(i / 4);
    buttons.push(new Button(i, 50 * x, 50 * y, 50, 50, function () {}));
  }
  buttons.push(new Button('Shuffle', 0, 250, 100, 50, function () {
    window.solution = [];
    grid = grid.applyMoves(randomMoveList(grid, 25));
    transfer();
    return prevNext(false);
  }));

  //print grid.lowerSolutionBound()
  buttons.push(new Button('Solve', 100, 250, 100, 50, function () {
    prevNext(false);
    window.solution = [];
    originalGrid = grid.copy();
    return solve(grid);
  }));
  buttons.push(new Button('Prev', 0, 300, 100, 50, function () {
    return update(-1);
  }));
  buttons.push(new Button('Next', 100, 300, 100, 50, function () {
    return update(+1);
  }));
  prevNext(false);
  grid = new Grid(INIT_GRID, [3, 3]);
  return transfer();
};

draw = function () {
  var button, j, len;
  background(128);
  for (j = 0, len = buttons.length; j < len; j++) {
    button = buttons[j];
    button.draw();
  }
  if (solution.length > 0) {
    textAlign(CENTER, CENTER);
    fill(255);
    return text(`${current} of ${solution.length}`, 100, 225);
  }
};

mousePressed = function () {
  var button, j, len, results;
  results = [];
  for (j = 0, len = buttons.length; j < len; j++) {
    button = buttons[j];
    if (button.inside()) {
      results.push(button.click());
    } else {
      results.push(void 0);
    }
  }
  return results;
};
//# sourceMappingURL=sketch.js.map
