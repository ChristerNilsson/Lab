'use strict';

// Generated by CoffeeScript 2.3.2
var Grid, manhattanDist, originalPosition;

originalPosition = function (num) {
  return [Math.floor((num - 1) / 4), (num - 1) % 4];
};

manhattanDist = function (num, curRow, curCol) {
  var origCol, origRow;
  [origRow, origCol] = originalPosition(num);
  return Math.abs(origRow - curRow) + Math.abs(origCol - curCol);
};

Grid = class Grid {
  constructor(grid = INIT_GRID, emptyPos = [3, 3]) {
    var i, len, row;
    this.emptyPos = emptyPos.slice();
    this.grid = [];
    for (i = 0, len = grid.length; i < len; i++) {
      row = grid[i];
      this.grid.push(row.slice());
    }
  }

  copy() {
    return new Grid(this.grid, this.emptyPos);
  }

  validMoves() {
    var colNum, rowNum, valid;
    [rowNum, colNum] = this.emptyPos;
    valid = [];
    if (colNum !== 0) {
      valid.push(XLEFT);
    }
    if (colNum !== 3) {
      valid.push(XRIGHT);
    }
    if (rowNum !== 0) {
      valid.push(XABOVE);
    }
    if (rowNum !== 3) {
      valid.push(XBELOW);
    }
    return valid;
  }

  positionToMove(rowNum, colNum) {
    var emptyCol, emptyRow;
    [emptyRow, emptyCol] = this.emptyPos;
    if (rowNum === emptyRow) {
      if (colNum === emptyCol - 1) {
        return XLEFT;
      }
      if (colNum === emptyCol + 1) {
        return XRIGHT;
      }
    }
    if (colNum === emptyCol) {
      if (rowNum === emptyRow - 1) {
        return XABOVE;
      }
      if (rowNum === emptyRow + 1) {
        return XBELOW;
      }
    }
    return null;
  }

  applyMoveFrom(sourceDirection) {
    var deltaCol, deltaRow, emptyPos, grid, i, len, nextGrid, number, ref, row, sourceCol, sourceRow, targetCol, targetRow;
    [targetRow, targetCol] = this.emptyPos;
    [deltaRow, deltaCol] = directionToDelta(sourceDirection);
    emptyPos = [sourceRow, sourceCol] = [targetRow + deltaRow, targetCol + deltaCol];
    grid = [];
    ref = this.grid;
    for (i = 0, len = ref.length; i < len; i++) {
      row = ref[i];
      grid.push(row.slice());
    }
    grid[targetRow][targetCol] = grid[sourceRow][sourceCol];
    grid[sourceRow][sourceCol] = 0;
    nextGrid = new Grid(grid, emptyPos);
    number = grid[targetRow][targetCol];
    nextGrid._lowerSolutionBound = this.lowerSolutionBound() - manhattanDist(number, sourceRow, sourceCol) + manhattanDist(number, targetRow, targetCol);
    return nextGrid;
  }

  applyMoves(sourceDirections) {
    var dir, i, len, nextGrid;
    nextGrid = this;
    for (i = 0, len = sourceDirections.length; i < len; i++) {
      dir = sourceDirections[i];
      nextGrid = nextGrid.applyMoveFrom(dir);
    }
    //nextGrid.log()
    return nextGrid;
  }

  lowerSolutionBound() {
    var colNum, moveCount, number, rowNum;
    // This calculates a lower bound on the minimum
    // number of steps required to solve the puzzle

    // This is the sum of the rectilinear distances
    // from where each number is to where it should
    // be
    if (this._lowerSolutionBound == null) {
      moveCount = 0;
      for (rowNum in this.grid) {
        for (colNum in this.grid[rowNum]) {
          number = this.grid[rowNum][colNum];
          if (number === 0) {
            continue;
          }
          moveCount += manhattanDist(number, rowNum, colNum);
        }
      }
      this._lowerSolutionBound = moveCount;
    }
    return this._lowerSolutionBound;
  }

  isSolved() {
    return this.lowerSolutionBound() === 0;
  }

  log() {
    var i, len, ref, results, row;
    print('');
    ref = this.grid;
    results = [];
    for (i = 0, len = ref.length; i < len; i++) {
      row = ref[i];
      results.push(print(row));
    }
    return results;
  }

};
//# sourceMappingURL=grid.js.map
