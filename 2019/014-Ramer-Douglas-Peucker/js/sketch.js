'use strict';

// Generated by CoffeeScript 2.3.2
var block,
    current,
    draw,
    drawTree,
    drawTreeBackGround,
    fastKey,
    info,
    keyPressed,
    keyReleased,
    mousePressed,
    myround,
    p1,
    p2,
    setup,
    show,
    treshold,
    modulo = function (a, b) {
  return (+a % (b = +b) + b) % b;
};

current = 0;

fastKey = 0;

p1 = null;

p2 = null;

treshold = 0.385;

setup = function () {
  var newpoints, p, xs, ys;
  //createCanvas 1500,1000 
  createCanvas(windowWidth - 20, windowHeight - 20);
  xs = function () {
    var j, len, results;
    results = [];
    for (j = 0, len = points.length; j < len; j++) {
      p = points[j];
      results.push(p.x);
    }
    return results;
  }();
  ys = function () {
    var j, len, results;
    results = [];
    for (j = 0, len = points.length; j < len; j++) {
      p = points[j];
      results.push(p.y);
    }
    return results;
  }();
  p1 = {
    x: min(xs),
    y: min(ys)
  };
  p2 = {
    x: max(xs),
    y: max(ys)
  };
  newpoints = simplify(points, treshold);
  return print(chrono);
};

show = function (p) {
  var factor, xfactor, yfactor;
  xfactor = 1500 / (p2.x - p1.x);
  yfactor = 1000 / (p2.y - p1.y);
  factor = 0.9 * min(xfactor, yfactor);
  return point(factor * (-1.1 * p1.x + p.x), factor * (-1.1 * p1.y + p.y));
};

info = function (title, x, y, r, g, b, sw) {
  noStroke();
  fill(255);
  text(title, x + 20, y);
  stroke(r, g, b);
  strokeWeight(sw);
  return point(x, y - 10);
};

myround = function (x, n) {
  return round(x * 10 ** n) / 10 ** n;
};

block = function ([level, i], r, g, b) {
  var x, y;
  //if i==undefined or level == undefined then return 
  fill(r, g, b);
  x = 1150 + level * 20;
  y = 25 + 1.9 * i;
  return rect(x, y, 20, 2);
};

drawTreeBackGround = function () {
  var i, j, len, ref, results, x;
  ref = range(-1, 17);
  results = [];
  for (j = 0, len = ref.length; j < len; j++) {
    i = ref[j];
    x = 1150 + i * 20;
    fc(0.75 + 0.05 * modulo(i, 4));
    results.push(rect(x, 0, 20, 1000));
  }
  return results;
};

drawTree = function () {
  var hash, i, j, len, level, pi, qi, ri, x, y;
  drawTreeBackGround();
  fill(0);
  hash = {};
  hash[0] = [-1, -1];
  hash[4999] = [-1, 500];
  for (i = j = 0, len = chrono.length; j < len; i = ++j) {
    [pi, qi, ri, level] = chrono[i];
    hash[qi] = [level, i];
    x = 1150 + level * 20;
    y = 25 + 1.9 * i;
    rect(x, y, 20, 2);
  }
  block(hash[0], 0, 0, 0);
  block(hash[4999], 0, 0, 0);
  [pi, qi, ri, level] = chrono[current];
  block(hash[pi], 255, 0, 0);
  block(hash[qi], 255, 255, 0);
  return block(hash[ri], 255, 0, 0);
};

draw = function () {
  var factor, i, j, k, l, len, len1, len2, len3, level, m, p, pi, qi, ref, ref1, ri, x1, x2, xfactor, yfactor;
  scale(height / 1000);
  background(0);
  drawTree();
  noFill();
  x1 = 75;
  textSize(24);
  [pi, qi, ri, level] = chrono[current];
  info('current end points', x1, 875, 255, 0, 0, 12);
  show(points[pi]);
  show(points[ri]);
  info('most distant point', x1, 925, 255, 255, 0, 12);
  show(points[qi]);
  push();
  p = points[qi];
  fill(255, 255, 0);
  noStroke();
  xfactor = 1500 / (p2.x - p1.x);
  yfactor = 1000 / (p2.y - p1.y);
  factor = 0.9 * min(xfactor, yfactor);
  text(current, 5 + factor * (-1.1 * p1.x + p.x), -5 + factor * (-1.1 * p1.y + p.y));
  pop();
  info('found points', x1, 950, 0, 255, 0, 7);
  show(points[0]);
  ref = range(current + 1);
  for (j = 0, len = ref.length; j < len; j++) {
    i = ref[j];
    [pi, qi, ri, level] = chrono[i];
    show(points[qi]);
  }
  info(`simplified ${chrono.length} points`, x1, 975, 0, 255, 0, 3);
  for (k = 0, len1 = chrono.length; k < len1; k++) {
    [pi, qi, ri, level] = chrono[k];
    show(points[qi]);
  }
  info(`original ${points.length} points`, x1, 850, 255, 255, 255, 1);
  for (l = 0, len2 = points.length; l < len2; l++) {
    p = points[l];
    show(p);
  }
  info('current line', x1, 900, 255, 0, 0, 1);
  [pi, qi, ri, level] = chrono[current];
  ref1 = range(pi, ri);
  for (m = 0, len3 = ref1.length; m < len3; m++) {
    i = ref1[m];
    show(points[i]);
  }
  noStroke();
  x2 = 100;
  text('Ramer-Douglas-Peucker 1973', 25, 40);
  text(`step(${pi},${ri},${level}) => ${qi}`, x2, 600);
  text(`current: ${current}`, x2, 625);
  text(`recursion level: ${level}`, x2, 650);
  text(`points in line: ${ri - pi + 1}`, x2, 675);
  text(`distance: ${myround(chrono[current][4], 2)}`, x2, 700);
  text(`treshold: ${treshold}`, x2, 725);
  text('up = fast backward', x2, 750);
  text('left = prev    right = next', x2, 775);
  text('down = fast forward', x2, 800);
  if (fastKey === DOWN_ARROW) {
    current++;
  }
  if (fastKey === UP_ARROW) {
    current--;
  }
  return current = constrain(current, 0, chrono.length - 1);
};

keyPressed = function () {
  if (keyCode === RIGHT_ARROW) {
    current++;
  }
  if (keyCode === LEFT_ARROW) {
    current--;
  }
  current = constrain(current, 0, chrono.length - 1);
  return fastKey = keyCode;
};

keyReleased = function () {
  return fastKey = 0;
};

mousePressed = function () {
  current = round((mouseY - 25) / 1.9 / (height / 1000) - 2);
  return current = constrain(current, 0, chrono.length - 1);
};
//# sourceMappingURL=sketch.js.map
