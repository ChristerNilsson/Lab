'use strict';

// Generated by CoffeeScript 2.3.2
var Board,
    COLORS,
    LOSE,
    N,
    SIZES,
    WIN,
    board,
    draw,
    keyPressed,
    make,
    move,
    score,
    setup,
    state,
    ts,
    modulo = function (a, b) {
  return (+a % (b = +b) + b) % b;
};

N = 4;

SIZES = [0, 128, 128, 80, 64, 48, 42];

COLORS = '0 #F00 #0F0 #FF0 #0FF #F0F #FFF #08F #0F8 #800 #808 #80F #FFF #08F #0F8 #800 #808 #80F'.split(' ');

[WIN, LOSE] = [1, 2];

ts = board = null;

score = state = 0;

move = function (lst) {
  var i, item, j, l, len, len1, ref, ref1;
  lst = function () {
    var j, len, results;
    results = [];
    for (j = 0, len = lst.length; j < len; j++) {
      item = lst[j];
      if (item > 0) {
        results.push(item);
      }
    }
    return results;
  }();
  ref = range(lst.length);
  for (j = 0, len = ref.length; j < len; j++) {
    i = ref[j];
    if (i < lst.length - 1 && lst[i] === lst[i + 1]) {
      [lst[i], lst[i + 1]] = [lst[i] + 1, 0];
      score += 2 ** lst[i];
    }
  }
  lst = function () {
    var l, len1, results;
    results = [];
    for (l = 0, len1 = lst.length; l < len1; l++) {
      item = lst[l];
      if (item > 0) {
        results.push(item);
      }
    }
    return results;
  }();
  ref1 = range(N - lst.length);
  for (l = 0, len1 = ref1.length; l < len1; l++) {
    i = ref1[l];
    lst.unshift(0);
  }
  return lst;
};

Board = class Board {
  constructor() {
    var i, j, len, ref;
    this.grid = function () {
      var j, len, ref, results;
      ref = range(N * N);
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        i = ref[j];
        results.push(0);
      }
      return results;
    }();
    ref = range(2);
    for (j = 0, len = ref.length; j < len; j++) {
      i = ref[j];
      this.addTile();
    }
  }

  mv(indices) {
    var i, index, j, len, lst, results;
    lst = move(function () {
      var j, len, results;
      results = [];
      for (j = 0, len = indices.length; j < len; j++) {
        index = indices[j];
        results.push(this.grid[index]);
      }
      return results;
    }.call(this));
    results = [];
    for (i = j = 0, len = indices.length; j < len; i = ++j) {
      index = indices[i];
      results.push(this.grid[index] = lst[i]);
    }
    return results;
  }

  addTile() {
    var index, tile;
    index = _.sample(function () {
      var j, len, ref, results;
      ref = this.grid;
      results = [];
      for (index = j = 0, len = ref.length; j < len; index = ++j) {
        tile = ref[index];
        if (tile === 0) {
          results.push(index);
        }
      }
      return results;
    }.call(this));
    return this.grid[index] = random() < 0.9 ? 1 : 2;
  }

  updateState() {
    var j, l, len, len1, m, ref, ref1, t, tmp;
    tmp = new Board();
    tmp.grid = this.grid.slice();
    ref = range(N);
    for (j = 0, len = ref.length; j < len; j++) {
      m = ref[j];
      ref1 = ts[m];
      for (l = 0, len1 = ref1.length; l < len1; l++) {
        t = ref1[l];
        tmp.mv(t);
      }
    }
    if (_.isEqual(tmp.grid, this.grid)) {
      return state = LOSE;
    }
  }

  move(m) {
    var j, len, original, ref, t;
    if (m !== 0 && m !== 1 && m !== 2 && m !== 3 || state > 0) {
      return;
    }
    original = this.grid.slice();
    ref = ts[m];
    for (j = 0, len = ref.length; j < len; j++) {
      t = ref[j];
      this.mv(t);
    }
    if (!_.isEqual(this.grid, original)) {
      this.addTile();
    }
    return this.updateState();
  }

  draw() {
    var cell, i, j, len, ref, results, value, x, y;
    ref = this.grid;
    results = [];
    for (i = j = 0, len = ref.length; j < len; i = ++j) {
      cell = ref[i];
      x = 100 + modulo(i, N) * 200;
      y = 100 + Math.floor(i / N) * 200;
      fill(COLORS[cell]);
      rect(x, y, 180, 180, 4);
      value = 2 ** cell;
      textSize(SIZES[value.toString().length]);
      fill(0);
      if (cell > 0) {
        text(value, x, y + 3);
      }
      textSize(64);
      text(score, 200, 850);
      results.push(text(['', 'You Win', 'Game Over'][state], 600, 850));
    }
    return results;
  }

};

make = function (lst, d) {
  var i, item, j, k, len, ref, results;
  ref = range(N);
  results = [];
  for (j = 0, len = ref.length; j < len; j++) {
    i = ref[j];
    results.push(function () {
      var l, len1, results1;
      results1 = [];
      for (k = l = 0, len1 = lst.length; l < len1; k = ++l) {
        item = lst[k];
        results1.push(item + d * i);
      }
      return results1;
    }());
  }
  return results;
};

setup = function () {
  test();
  createCanvas(801, 801 + 100);
  textAlign(CENTER, CENTER);
  rectMode(CENTER);
  board = new Board();
  ts = [];
  ts.push(make([12, 8, 4, 0], 1));
  ts.push(make([0, 1, 2, 3], N));
  ts.push(make([0, 4, 8, 12], 1));
  ts.push(make([3, 2, 1, 0], N));
  return score = 0;
};

draw = function () {
  bg(0.5);
  return board.draw();
};

keyPressed = function () {
  return board.move([UP_ARROW, RIGHT_ARROW, DOWN_ARROW, LEFT_ARROW].indexOf(keyCode));
};
//# sourceMappingURL=sketch.js.map
