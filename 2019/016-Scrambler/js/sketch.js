'use strict';

// Generated by CoffeeScript 2.3.2
var Button,
    buttons,
    createHash,
    draw,
    hash,
    hist,
    korrekt,
    level,
    mousePressed,
    mouseReleased,
    newGame,
    normalize,
    released,
    setup,
    slumpad,
    touchEnded,
    touchStarted,
    indexOf = [].indexOf;

hash = null;

korrekt = '';

slumpad = '';

buttons = [];

level = 3;

released = true;

hist = [];

normalize = function (ord) {
  var arr;
  arr = ord.split('');
  arr.sort();
  return arr.join('');
};

createHash = function (lvl) {
  var j, key, len, ord, ref;
  hash = {};
  level = constrain(lvl, 3, 28);
  ref = ordlista.split(' ');
  for (j = 0, len = ref.length; j < len; j++) {
    ord = ref[j];
    if (ord.length === level) {
      key = normalize(ord);
      if (hash[key]) {
        hash[key].push(ord);
      } else {
        hash[key] = [ord];
      }
    }
  }
  return newGame();
};

Button = class Button {
  constructor(title, x, y, w, h, click) {
    this.title = title;
    this.x = x;
    this.y = y;
    this.w = w;
    this.h = h;
    this.click = click;
  }

  draw() {
    rect(this.x, this.y, this.w, this.h);
    return text(this.title, this.x, this.y);
  }

  inside() {
    var mx, my;
    mx = mouseX * 1000 / windowWidth;
    my = mouseY * 1000 / windowHeight;
    return this.x - this.w / 2 < mx && mx < this.x + this.w + 2 && this.y - this.h / 2 < my && my < this.y + this.h + 2;
  }

};

newGame = function () {
  var results;
  korrekt = _.sample(_.keys(hash));
  results = [];
  while (true) {
    slumpad = _.shuffle(korrekt.split('')).join('');
    if (indexOf.call(hash[normalize(korrekt)], slumpad) < 0) {
      break;
    } else {
      results.push(void 0);
    }
  }
  return results;
};

setup = function () {
  createCanvas(windowWidth - 18, windowHeight - 20);
  textAlign(CENTER, CENTER);
  rectMode(CENTER);
  buttons.push(new Button('+', 900, 100, 100, 50, function () {
    return createHash(level + 1);
  }));
  buttons.push(new Button('-', 700, 100, 100, 50, function () {
    return createHash(level - 1);
  }));
  buttons.push(new Button('Next', 150, 100, 200, 50, function () {
    hist.unshift([slumpad, hash[normalize(korrekt)]]);
    return newGame();
  }));
  return createHash(3);
};

draw = function () {
  var button, i, j, k, len, len1, line0, line1, pair;
  scale(windowWidth / 1000, windowHeight / 1000);
  bg(0.5);
  for (j = 0, len = buttons.length; j < len; j++) {
    button = buttons[j];
    button.draw();
  }
  textSize(50);
  push();
  textSize(60);
  if (hash[normalize(korrekt)].length === 1) {
    text(slumpad, 500, 200);
  } else {
    text(`${slumpad} (${hash[normalize(korrekt)].length})`, 500, 200);
  }
  fc(0.6);
  text(_.size(hash), 500, 100);
  pop();
  text(level, 800, 100);
  push();
  for (i = k = 0, len1 = hist.length; k < len1; i = ++k) {
    pair = hist[i];
    [line0, line1] = pair;
    textAlign(LEFT, CENTER);
    text(line0, 50, 300 + 100 * i);
    textAlign(RIGHT, CENTER);
    text(line1, 900, 350 + 100 * i);
  }
  return pop();
};

mousePressed = touchStarted = function () {
  var button, j, len;
  if (released) {
    released = false; // to make Android work 	
  } else {
    return;
  }
  for (j = 0, len = buttons.length; j < len; j++) {
    button = buttons[j];
    if (button.inside()) {
      button.click();
    }
  }
  return false; // to prevent double click on Android
};

mouseReleased = touchEnded = function () {
  released = true;
  return false; // to prevent double click on Android
};
//# sourceMappingURL=sketch.js.map
