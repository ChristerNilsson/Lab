'use strict';

// Generated by CoffeeScript 2.3.2
var Button,
    buttons,
    createHash,
    draw,
    hash,
    hist,
    korrekt,
    level,
    mousePressed,
    mouseReleased,
    newGame,
    normalize,
    released,
    setup,
    slumpad,
    touchEnded,
    touchStarted,
    indexOf = [].indexOf;

hash = null;

korrekt = '';

slumpad = '';

buttons = [];

level = 3;

released = true;

hist = [];

normalize = function (ord) {
  var arr;
  arr = ord.split('');
  arr.sort();
  return arr.join('');
};

createHash = function (lvl) {
  var j, key, len, ord, ref;
  hash = {};
  level = constrain(lvl, 2, 25);
  ref = ordlista.split(' ');
  for (j = 0, len = ref.length; j < len; j++) {
    ord = ref[j];
    if (ord.length === level) {
      key = normalize(ord);
      if (hash[key]) {
        hash[key].push(ord);
      } else {
        hash[key] = [ord];
      }
    }
  }
  return newGame();
};

Button = class Button {
  constructor(title, x, y, w, h, click) {
    this.title = title;
    this.x = x;
    this.y = y;
    this.w = w;
    this.h = h;
    this.click = click;
  }

  draw() {
    rect(this.x, this.y, this.w, this.h);
    return text(this.title, this.x, this.y);
  }

  inside() {
    return this.x - this.w / 2 < mouseX && mouseX < this.x + this.w + 2 && this.y - this.h / 2 < mouseY && mouseY < this.y + this.h + 2;
  }

};

newGame = function () {
  var results;
  korrekt = _.sample(_.keys(hash));
  results = [];
  while (true) {
    slumpad = _.shuffle(korrekt.split('')).join('');
    if (indexOf.call(hash[normalize(korrekt)], slumpad) < 0) {
      break;
    } else {
      results.push(void 0);
    }
  }
  return results;
};

setup = function () {
  createCanvas(windowWidth - 20, windowHeight - 20);
  textAlign(CENTER, CENTER);
  rectMode(CENTER);
  textSize(50);
  buttons.push(new Button('+', 100, 100, 100, 50, function () {
    return createHash(level + 1);
  }));
  buttons.push(new Button('-', 100, 200, 100, 50, function () {
    return createHash(level - 1);
  }));
  buttons.push(new Button('Next', width / 2, 100, width / 2, 50, function () {
    hist.unshift(`${slumpad} : ${hash[normalize(korrekt)]}`);
    return newGame();
  }));
  return createHash(3);
};

draw = function () {
  var button, i, j, k, len, len1, line, results;
  bg(0.5);
  for (j = 0, len = buttons.length; j < len; j++) {
    button = buttons[j];
    button.draw();
  }
  if (hash[normalize(korrekt)].length === 1) {
    text(slumpad, width / 2, 200);
  } else {
    text(`${slumpad} (${hash[normalize(korrekt)].length})`, width / 2, 200);
  }
  text(level, 100, 150);
  results = [];
  for (i = k = 0, len1 = hist.length; k < len1; i = ++k) {
    line = hist[i];
    results.push(text(line, width / 2, 300 + 100 * i));
  }
  return results;
};

mousePressed = touchStarted = function () {
  var button, j, len;
  if (released) {
    released = false; // to make Android work 	
  } else {
    return;
  }
  for (j = 0, len = buttons.length; j < len; j++) {
    button = buttons[j];
    if (button.inside()) {
      button.click();
    }
  }
  return false; // to prevent double click on Android
};

mouseReleased = touchEnded = function () {
  released = true;
  return false; // to prevent double click on Android
};
//# sourceMappingURL=sketch.js.map
