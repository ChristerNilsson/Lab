'use strict';

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

// Generated by CoffeeScript 2.0.3
var ALFABET, N, arrayExcept, decr, f, g, incr, makePerms, match2, match3, match4, ok, _permute, sol6x6, sol7x7, solve, start, uniq, valid;

N = null;

ALFABET = ' abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';

// setup = ->
// 	createCanvas 200,200
// draw = ->
// 	bg 0.5
arrayExcept = function arrayExcept(arr, idx) {
  var res;
  res = arr.slice(0);
  res.splice(idx, 1);
  return res;
};

_permute = function permute(arr) {
  var _ref;

  var idx, perm, permutations, value;
  arr = Array.prototype.slice.call(arr, 0);
  if (arr.length === 0) {
    return [[]];
  }
  permutations = function () {
    var k, len, results;
    results = [];
    for (idx = k = 0, len = arr.length; k < len; idx = ++k) {
      value = arr[idx];
      results.push(function () {
        var l, len1, ref, results1;
        ref = _permute(arrayExcept(arr, idx));
        results1 = [];
        for (l = 0, len1 = ref.length; l < len1; l++) {
          perm = ref[l];
          results1.push([value].concat(perm));
        }
        return results1;
      }());
    }
    return results;
  }();
  return (_ref = []).concat.apply(_ref, _toConsumableArray(permutations));
};

assert([[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]], _permute([1, 2, 3]));

f = function f(kenken) {
  var i, k, key, l, len, len1, letter, res;
  res = {};
  for (k = 0, len = kenken.length; k < len; k++) {
    letter = kenken[k];
    res[letter] = [];
  }
  for (i = l = 0, len1 = kenken.length; l < len1; i = ++l) {
    key = kenken[i];
    res[key].push(i);
  }
  return res;
};

//        0123456789012345  
// rf =  f("abbcddecffgghhii")
// assert rf,
// 	a:[0]
// 	b:[1,2]
// 	c:[3,7]
// 	d:[4,5]
// 	e:[6]
// 	f:[8,9]
// 	g:[10,11]
// 	h:[12,13]
// 	i:[14,15]
uniq = function uniq(lst) {
  var i, item, k, len, res;
  res = [lst[0]];
  for (i = k = 0, len = lst.length; k < len; i = ++k) {
    item = lst[i];
    if (i > 0) {
      if (!_.isEqual(item, _.last(res))) {
        res.push(item);
      }
    }
  }
  return res;
};

match2 = function match2(total, operation) {
  var a, b, k, l, len, len1, lst, ref, ref1, res;
  res = [];
  ref = range(1, N + 1);
  for (k = 0, len = ref.length; k < len; k++) {
    a = ref[k];
    ref1 = range(1, N + 1);
    for (l = 0, len1 = ref1.length; l < len1; l++) {
      b = ref1[l];
      if (total === operation(a, b)) {
        lst = [a, b].sort();
        res.push(lst);
      }
    }
  }
  return uniq(res.sort());
};

match3 = function match3(total, operation) {
  var a, b, c, k, l, len, len1, len2, lst, m, ref, ref1, ref2, res;
  res = [];
  ref = range(1, N + 1);
  for (k = 0, len = ref.length; k < len; k++) {
    a = ref[k];
    ref1 = range(1, N + 1);
    for (l = 0, len1 = ref1.length; l < len1; l++) {
      b = ref1[l];
      ref2 = range(1, N + 1);
      for (m = 0, len2 = ref2.length; m < len2; m++) {
        c = ref2[m];
        if (total === operation(a, b, c)) {
          lst = [a, b, c].sort();
          res.push(lst);
        }
      }
    }
  }
  return uniq(res.sort());
};

match4 = function match4(total, operation) {
  var a, b, c, d, k, l, len, len1, len2, len3, lst, m, n, ref, ref1, ref2, ref3, res;
  res = [];
  ref = range(1, N + 1);
  for (k = 0, len = ref.length; k < len; k++) {
    a = ref[k];
    ref1 = range(1, N + 1);
    for (l = 0, len1 = ref1.length; l < len1; l++) {
      b = ref1[l];
      ref2 = range(1, N + 1);
      for (m = 0, len2 = ref2.length; m < len2; m++) {
        c = ref2[m];
        ref3 = range(1, N + 1);
        for (n = 0, len3 = ref3.length; n < len3; n++) {
          d = ref3[n];
          if (total === operation(a, b, c, d)) {
            lst = [a, b, c, d].sort();
            res.push(lst);
          }
        }
      }
    }
  }
  return uniq(res.sort());
};

g = function g(rf, ops) {
  // gets possible operands
  var key, res, total;
  res = {};
  for (key in rf) {
    total = parseInt(ops[key]);
    switch (rf[key].length) {
      case 1:
        res[key] = [[total]];
        break;
      case 2:
        switch (_.last(ops[key])) {
          case '/':
            res[key] = match2(total, function (a, b) {
              return Math.floor(a / b);
            });
            break;
          case '+':
            res[key] = match2(total, function (a, b) {
              return a + b;
            });
            break;
          case '*':
            res[key] = match2(total, function (a, b) {
              return a * b;
            });
            break;
          case '-':
            res[key] = match2(total, function (a, b) {
              return a - b;
            });
        }
        break;
      case 3:
        switch (_.last(ops[key])) {
          case '+':
            res[key] = match3(total, function (a, b, c) {
              return a + b + c;
            });
            break;
          case '*':
            res[key] = match3(total, function (a, b, c) {
              return a * b * c;
            });
        }
        break;
      case 4:
        switch (_.last(ops[key])) {
          case '+':
            res[key] = match4(total, function (a, b, c, d) {
              return a + b + c + d;
            });
            break;
          case '*':
            res[key] = match4(total, function (a, b, c, d) {
              return a * b * c * d;
            });
        }
        break;
      default:
        print('Problem!');
    }
  }
  return res;
};

// rg = g rf,
// 	a: '4'
// 	b: '2/'
// 	c: '12*'
// 	d: '1-'
// 	e: '3'
// 	f: '7+'
// 	g: '2/'
// 	h: '1-'
// 	i: '3-'

// assert rg,
// 	a: [[4]]
// 	b: [[1,2],[2,4]]
// 	c: [[3,4]]
// 	d: [[1,2],[2,3],[3,4]]
// 	e: [[3]]
// 	f: [[3,4]]
// 	g: [[1,2],[2,4]]
// 	h: [[1,2],[2,3],[3,4]]
// 	i: [[1,4]]
makePerms = function makePerms(rg) {
  // adds permutations
  var a, k, key, len, lst, pair, res;
  res = {};
  for (key in rg) {
    lst = rg[key];
    a = [];
    for (k = 0, len = lst.length; k < len; k++) {
      pair = lst[k];
      a = a.concat(_permute(pair));
    }
    res[key] = uniq(a.sort());
  }
  return res;
};

// rp = makePerms rg
// assert rp,
// 	a: [[4]]
// 	b: [[1,2],[2,1],[2,4],[4,2]]
// 	c: [[3,4],[4,3]]
// 	d: [[1,2],[2,1],[2,3],[3,2],[3,4],[4,3]]
// 	e: [[3]]
// 	f: [[3,4],[4,3]]
// 	g: [[1,2],[2,1],[2,4],[4,2]]
// 	h: [[1,2],[2,1],[2,3],[3,2],[3,4],[4,3]]
// 	i: [[1,4],[4,1]]
ok = function ok(lst) {
  lst = _.without(lst, 0);
  return lst.length === _.uniq(lst).length;
};

assert([1, 2, 3, 4], _.uniq([1, 2, 3, 4]));

assert(true, ok([1, 2, 3, 4]));

assert(false, ok([1, 2, 2, 4]));

assert(true, ok([0, 0, 0, 0]));

assert(true, ok([4, 0, 0, 1]));

assert(false, ok([4, 0, 0, 4]));

valid = function valid(indexes, pointer, rf, rp) {
  // 1..4 must be unique in each row and col. 0 is ok
  var col, grid, i, j, k, l, len, len1, len2, len3, m, n, p, ref, ref1, ref2, ref3, row, x, y;
  print(indexes, pointer);
  if (pointer === ' ') {
    return true;
  }
  grid = function () {
    var k, len, ref, results;
    ref = range(N * N);
    results = [];
    for (k = 0, len = ref.length; k < len; k++) {
      i = ref[k];
      results.push(0);
    }
    return results;
  }();
  ref = ALFABET.slice(1, 1 + ALFABET.indexOf(pointer));
  for (k = 0, len = ref.length; k < len; k++) {
    p = ref[k];
    ref1 = rf[p];
    for (j = l = 0, len1 = ref1.length; l < len1; j = ++l) {
      x = ref1[j];
      print(p, x, j, indexes[p]);
      y = rp[p][indexes[p]][j];
      grid[x] = y;
    }
  }
  ref2 = range(N);
  for (m = 0, len2 = ref2.length; m < len2; m++) {
    row = ref2[m];
    if (!ok(function () {
      var len3, n, ref3, results;
      ref3 = range(row * N, row * N + N);
      results = [];
      for (n = 0, len3 = ref3.length; n < len3; n++) {
        i = ref3[n];
        results.push(grid[i]);
      }
      return results;
    }())) {
      return false;
    }
  }
  ref3 = range(N);
  for (n = 0, len3 = ref3.length; n < len3; n++) {
    col = ref3[n];
    if (!ok(function () {
      var len4, o, ref4, results;
      ref4 = range(col, N * N, N);
      results = [];
      for (o = 0, len4 = ref4.length; o < len4; o++) {
        i = ref4[o];
        results.push(grid[i]);
      }
      return results;
    }())) {
      return false;
    }
  }
  return true;
};

//assert true, valid {a:-1,b:-1,c:-1,d:-1,e:-1,f:-1,g:-1,h:-1,i:-1}, ' ', rf, rp	
//assert true, valid {a:0, b:0,c:0,d:0,e:0,f:0,g:0,h:2,i:1}, 'i', rf, rp	
incr = function incr(pointer) {
  return ALFABET[ALFABET.indexOf(pointer) + 1];
};

decr = function decr(pointer) {
  return ALFABET[ALFABET.indexOf(pointer) - 1];
};

assert('b', incr('a'));

assert('a', decr('b'));

solve = function solve(kenken, ops) {
  var flag, indexes, key, pointer, rf, rg, rp, stopper;
  print(N = Math.sqrt(kenken.length));
  print(rf = f(kenken));
  print(rg = g(rf, ops));
  print(rp = makePerms(rg));
  indexes = {};
  for (key in ops) {
    indexes[key] = -1;
  }
  pointer = 'a';
  indexes['a'] = 0;
  stopper = ALFABET[1 + _.size(ops)];
  while (pointer !== ' ' && pointer !== stopper) {
    flag = indexes[pointer] < rp[pointer].length;
    if (flag && valid(indexes, pointer, rf, rp)) {
      pointer = incr(pointer);
      if (pointer < stopper) {
        indexes[pointer]++;
      }
      //print 'A',pointer, indexes[pointer]
    } else if (indexes[pointer] < rp[pointer].length - 1) {
      indexes[pointer]++;
      if (pointer < indexes.length) {
        indexes[incr(pointer)] = -1;
      }
    } else {
      //print 'B',pointer,indexes[pointer]
      indexes[pointer] = -1;
      pointer = decr(pointer);
      indexes[pointer]++;
    }
  }
  //print 'C',pointer,indexes[pointer]
  return indexes;
};

start = Date.now();

// assert {a: 0, b: 0, c: 0, d: 0, e: 0}, solve "abbacdeed", {a:'5+',b:'3/',c:'2',d:'1-',e:'2-'}
// assert {a:0,b:0,c:0,d:0,e:0,f:0,g:0,h:2,i:1}, solve "abbcddecffgghhii", {a:'4',b:'2/',c:'12*',d:'1-',e:'3',f:'7+',g:'2/',h:'1-',i:'3-'}
// assert {a:0,b:5,c:3,d:2,e:2,f:0,g:5,h:0}, solve "aabbcdefcdeghhgg", {a:'2/',b:'1-',c:'2/',d:'4+',e:'1-',f:'1',g:'8*',h:'7+'}
sol6x6 = {
  a: 1,
  b: 13,
  c: 2,
  d: 7,
  e: 4,
  f: 3,
  g: 2,
  h: 4,
  i: 0,
  j: 4,
  k: 0,
  l: 1,
  m: 3,
  n: 4,
  o: 10,
  p: 3,
  q: 0
};

//assert sol6x6, solve "aabccdeebbddffgghijflmhnjklmonppqqoo", {a:'11+',b:'11+',c:'3/',d:'12*',e:'1-',f:'6*',g:'5+',h:'3-',i:'4',j:'7+',k:'3',l:'11+',m:'5+',n:'2/',o:'12+',p:'6+',q:'5-'}
sol7x7 = {
  a: 1,
  b: 16,
  c: 2,
  d: 6,
  e: 0,
  f: 7,
  g: 2,
  h: 4,
  i: 0,
  j: 8,
  k: 1,
  l: 0,
  m: 0,
  n: 2,
  o: 5,
  p: 5,
  q: 5,
  r: 3,
  s: 4,
  t: 1,
  u: 10,
  v: 2 // 200 ms
};

//assert sol7x7, solve "aabbcddefbbcghefijjghklimjnokppmnnoqrssstuqrvvvtu", {a:'6-',b:'360*',c:'5-',d:'2/',e:'15*',f:'3-',g:'1-',h:'6+',i:'13+',j:'12+',k:'3+',l:'6',m:'8+',n:'120*',o:'1-',p:'3-',q:'2-',r:'1-',s:'8+',t:'6-',u:'1-',v:'60*'}

// 9x9
print(solve("abcccddeeabfgghdeeiifjjhkkklmfnoopqqlmrnsppttumrvspwwxuuyyzAAwxBByCzzDDEFFFCGGHHE", {
  a: '3-',
  b: '8+',
  c: '16+',
  d: '9+',
  e: '33+',
  f: '10+',
  g: '3+',
  h: '7+',
  i: '7+',
  j: '1-',
  k: '16+',
  l: '8-',
  m: '18+',
  n: '16+',
  o: '9+',
  p: '21+',
  q: '4-',
  r: '8-',
  s: '2-',
  t: '3-',
  u: '16+',
  v: '5',
  w: '17+',
  x: '7+',
  y: '16+',
  z: '22+',
  A: '3+',
  B: '7-',
  C: '7+',
  D: '4+',
  E: '9+',
  F: '13+',
  G: '17+',
  H: '12+'
}));

print('Ready!', Date.now() - start);
//# sourceMappingURL=sketch.js.map
