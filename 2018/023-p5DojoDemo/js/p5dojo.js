'use strict';

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

// Generated by CoffeeScript 2.0.3
// todo: Code Mirror hanterar inte toggleComment via Ctrl+/

// if the renew button is available, a new version of the b code is available.
// Clicking renew prints the current b code on the console as a backup.
var INTERVAL,
    bg,
    block,
    buffer,
    buildLink,
    cc,
    cct,
    changeLayout,
    chapter,
    circle,
    cmd,
    co,
    compare,
    currentItem,
    decorate,
    delay,
    demoState,
    draw,
    exercise,
    fc,
    fetch,
    fillSelect,
    fillTable,
    firstDiff,
    fixColor,
    fix_frames,
    gap,
    grid,
    ip,
    items,
    keyPressed,
    kwl,
    kwlinks,
    meny,
    msg,
    myCodeMirror,
    myprint,
    range,
    rd,
    reset,
    resizeTimer,
    run,
    run0,
    run1,
    saveToKeyStorage,
    sc,
    setup,
    showText,
    store,
    sw,
    tableAppend,
    tableClear,
    _unmark,
    updateTables,
    modulo = function modulo(a, b) {
  return (+a % (b = +b) + b) % b;
};

INTERVAL = 1000;

currentItem = 0;

chapter = '';

exercise = '';

cmd = '';

delay = 59;

demoState = 1;

myCodeMirror = null;

msg = null;

kwl = {};

kwlinks = [];

gap = 0;

block = 0;

buffer = [[], [], []];

meny = null;

grid = function grid() {
  var i, l, len, ref;
  push();
  bg(0.25);
  sc(0.5);
  ref = range(11);
  for (l = 0, len = ref.length; l < len; l++) {
    i = ref[l];
    line(0, 20 * i, 200, 20 * i);
    line(20 * i, 0, 20 * i, 200);
  }
  return pop();
};

myprint = function myprint() {
  return print(Array.prototype.slice.call(arguments).join(" "));
};

co = function co() {
  return fixColor(arguments);
};

ip = function ip(y1, y2, x, x1, x2) {
  if (arguments.length === 3) {
    x1 = 0;
    x2 = 9;
  }
  return map(x, x1, x2, y1, y2);
};

fixColor = function fixColor(args) {
  var a, b, g, n, r;
  n = args.length;
  r = 0;
  g = 0;
  b = 0;
  a = 1;
  if (n === 1) {
    r = args[0];
    g = r;
    b = r;
  } else if (n === 3) {
    r = args[0];
    g = args[1];
    b = args[2];
  } else if (n === 4) {
    r = args[0];
    g = args[1];
    b = args[2];
    a = args[3];
  }
  return color(255 * r, 255 * g, 255 * b, 255 * a);
};

bg = function bg() {
  return background(fixColor(arguments));
};

fc = function fc() {
  var n;
  n = arguments.length;
  if (n === 0) {
    return noFill();
  } else {
    return fill(fixColor(arguments));
  }
};

sc = function sc() {
  var n;
  n = arguments.length;
  if (n === 0) {
    return noStroke();
  } else {
    return stroke(fixColor(arguments));
  }
};

cc = function cc(n) {
  // https://github.com/jonasjacek/colors with modifications
  var b, g, helper, lst, r, z;
  helper = function helper(n, big) {
    return [n % 2 * big, int(n / 2) % 2 * big, int(n / 4) * big];
  };
  if (n < 8) {
    return helper(n, 255);
  } else if (n === 8) {
    return [192, 192, 192];
  } else if (n < 16) {
    return helper(n - 8, 128);
  } else if (n === 16) {
    return [64, 64, 64];
  } else if (n < 232) {
    n -= 16;
    r = n % 6;
    n = Math.floor(n / 6);
    g = n % 6;
    n = Math.floor(n / 6);
    b = n;
    lst = [0, 95, 135, 175, 215, 255];
    return [lst[r], lst[g], lst[b]];
  } else {
    n -= 232;
    z = lerp(8, 18, n);
    return [z, z, z];
  }
};

cct = function cct(n) {
  // makes text visible
  var b, g, r;

  var _cc = cc(n);

  var _cc2 = _slicedToArray(_cc, 3);

  r = _cc2[0];
  g = _cc2[1];
  b = _cc2[2];

  if (r + g + b >= 3 * 128) {
    return [0, 0, 0];
  } else {
    return [255, 255, 255];
  }
};

sw = function sw(n) {
  return strokeWeight(n);
};

circle = function circle(x, y, r) {
  return ellipse(x, y, 2 * r, 2 * r);
};

rd = function rd(vinkel) {
  return rotate(radians(vinkel));
};

range = _.range;

fillSelect = function fillSelect(sel, dict) {
  var key, results;
  sel.empty();
  results = [];
  for (key in dict) {
    results.push(sel.append($("<option>").attr('value', key).text(key)));
  }
  return results;
};

buildLink = function buildLink(keyword) {
  var nr;
  if (keyword.indexOf('_.') === 0) {
    keyword = keyword.replace('_.', '');
  }
  nr = kwl[keyword];
  if (nr === void 0) {
    return;
  }
  if (nr === 0) {
    keyword = keyword.toLowerCase();
  }
  if (nr === null) {
    return null;
  } else {
    keyword = keyword.replace('[]', 'array');
    keyword = keyword.replace('""', 'string');
    keyword = keyword.replace('{}', 'object');
    keyword = keyword.replace('->', 'pil');
    keyword = keyword.replace('@', 'this');
    keyword = keyword.replace('...', 'exclusiverange');
    keyword = keyword.replace('..', 'inclusiverange');
    keyword = keyword.replace('HSB', 'colorMode');
    return kwlinks[nr].replace('{}', keyword);
  }
};

decorate = function decorate(dict) {
  // {klocka: "draw|incr_hour"}
  var l, len, method, methods, objekt, res, s;
  if (dict === void 0) {
    return {};
  }
  if (dict === null) {
    return {};
  }
  res = {};
  for (objekt in dict) {
    s = dict[objekt];
    methods = s.split("|");
    res["draw()"] = objekt + ".draw(); " + objekt + ".store()";
    for (l = 0, len = methods.length; l < len; l++) {
      method = methods[l];
      res[method] = objekt + "." + method + "; " + objekt + ".draw(); " + objekt + ".store()";
    }
  }
  return res;
};

changeLayout = function changeLayout() {
  var w;
  w = $(window).width();
  $(".CodeMirror").width(w - 425);
  $("#canvas").css({
    top: 0,
    left: 205,
    position: 'absolute'
  });
  $("#msg").width(w - 430);
  return $("#input").width(w - 218);
};

resizeTimer = 0;

$(window).resize(function () {
  clearTimeout(resizeTimer);
  return resizeTimer = setTimeout(changeLayout, 10);
});

updateTables = function updateTables() {
  meny.rensa();
  return meny.traverse();
};

items = [];

showText = function showText() {
  var _items$currentItem = _slicedToArray(items[currentItem], 3);

  chapter = _items$currentItem[0];
  exercise = _items$currentItem[1];
  cmd = _items$currentItem[2];

  document.getElementById("chapter").innerHTML = "   Level: " + chapter;
  document.getElementById("exercise").innerHTML = "Exercise: " + exercise;
  document.getElementById("command").innerHTML = " Command: " + cmd;
  document.getElementById("seconds").innerHTML = "   Frame: " + currentItem + " " + ["(Paused)", ""][demoState];
  return document.getElementById("info").innerHTML = "Use Left, Right and Space keys";
};

draw = function draw() {
  var calls, code;

  //print items.length,chapter,exercise,cmd
  showText();
  meny = {
    exercise: exercise
  };
  calls = decorate(data[chapter][exercise].c);
  if (delay === 60) {
    code = 'app.' + cmd + '; app.draw(); app.store()';
    if (demoState === 1) {
      currentItem++;
    }
    delay--;
  } else {
    code = 'app.draw()';
    delay--;
  }
  if (delay === 0) {
    delay = 60;
  }
  if (demoState === 1) {
    return run1(chapter, exercise, code);
  }
};

keyPressed = function keyPressed() {
  if (keyCode === 32) {
    demoState = 1 - demoState;
  }
  if (keyCode === 37) {
    currentItem--;
  }
  if (keyCode === 39) {
    currentItem++;
  }
  return currentItem = modulo(currentItem, items.length);
};

setup = function setup() {
  var c, cmds, item1, item2, results, timestamp;
  timestamp = millis();
  c = createCanvas(3 * 201 + 10, 3 * 201 + 10);
  gap = 5 * width * 4;
  block = 201 * width * 4;
  pixelDensity(1);
  c.parent('canvas');
  bg(0);
  items = [];
  results = [];
  for (chapter in data) {
    item1 = data[chapter];
    if (chapter !== 'Information' && chapter !== 'Exhibition') {
      results.push(function () {
        var results1;
        results1 = [];
        for (exercise in item1) {
          item2 = item1[exercise];
          if (item2.d) {
            cmds = item2.d.split('|');
            results1.push(function () {
              var l, len, results2;
              results2 = [];
              for (l = 0, len = cmds.length; l < len; l++) {
                cmd = cmds[l];
                results2.push(items.push([chapter, exercise, cmd]));
              }
              return results2;
            }());
          } else {
            results1.push(items.push([chapter, exercise, '']));
          }
        }
        return results1;
      }());
    } else {
      results.push(void 0);
    }
  }
  return results;
};

window.onbeforeunload = function () {
  var blob, i, key1, key2, l, len, ref, res, s;
  if (document.URL.indexOf("record") === -1) {
    return;
  }
  res = [];
  for (key1 in data) {
    chapter = data[key1];
    for (key2 in chapter) {
      exercise = chapter[key2];
      if (exercise.d) {
        res.push('### ' + key1 + ' ### ' + key2 + '\n');
        ref = exercise.d;
        for (i = l = 0, len = ref.length; l < len; i = ++l) {
          s = ref[i];
          res.push('=== ' + i + '\n');
          res.push(s + "\n");
        }
      }
    }
  }
  blob = new Blob(res, {
    type: "text/plain;charset=utf-8"
  });
  saveAs(blob, "recording.txt");
  return true;
};

saveToKeyStorage = function saveToKeyStorage(b) {
  var l, len, line, place, ref, s;
  s = "";
  ref = b.split('\n');
  for (l = 0, len = ref.length; l < len; l++) {
    line = ref[l];
    if (line.indexOf("#") !== 0) {
      s += line;
    }
  }
  place = data[meny.chapter][meny.exercise];
  if (!place.d) {
    place.d = [];
  }
  return place.d.push(s);
};

run0 = function run0(code) {
  var src;
  if (meny.exercise === "") {
    return false;
  }
  src = myCodeMirror.getValue();
  return run(0, src + "\n" + code);
};

run1 = function run1(chapter, exercise, code) {
  if (exercise === "") {
    return;
  }
  return run(1, data[chapter][exercise].a + "\n" + code);
};

reset = function reset() {
  resetMatrix();
  colorMode(RGB, 255);
  angleMode(RADIANS);
  rectMode(CORNER);
  strokeCap(ROUND);
  textAlign(LEFT, BASELINE);
  smooth(); // pga SuperCircle
  bg(0);
  fc(0);
  sc(1);
  return sw(1);
};

run = function run(_n, coffee) {
  var code, e;
  reset();
  push();
  translate(5, 5);
  scale(3);
  grid();
  try {
    code = transpile(coffee);
    try {
      eval(code);
      buffer[1 - _n] = store();
      pop();
      return true;
    } catch (error) {
      e = error;
      pop();
      return false;
    }
  } catch (error) {
    e = error;
    pop();
    return false;
  }
};

store = function store() {
  loadPixels();
  return pixels.slice(gap, gap + block);
};

fetch = function fetch(buffer, y0) {
  var i, l, len, ref;
  loadPixels();
  ref = range(block);
  for (l = 0, len = ref.length; l < len; l++) {
    i = ref[l];
    pixels[gap + (gap + block) * y0 + i] = buffer[i];
  }
  return updatePixels();
};

fix_frames = function fix_frames() {
  var i, j, k, l, len, len1, len2, len3, m, o, p, ref, ref1, ref2, ref3;
  loadPixels();
  ref = range(4);
  for (l = 0, len = ref.length; l < len; l++) {
    k = ref[l];
    ref1 = range(gap);
    for (m = 0, len1 = ref1.length; m < len1; m++) {
      i = ref1[m];
      pixels[(gap + block) * k + i] = 128 - 64;
    }
  }
  ref2 = range(height);
  // 3*201+20
  for (o = 0, len2 = ref2.length; o < len2; o++) {
    j = ref2[o];
    ref3 = range(20);
    for (p = 0, len3 = ref3.length; p < len3; p++) {
      i = ref3[p];
      pixels[j * width * 4 + i] = 128 - 64;
      pixels[j * width * 4 + 206 * 4 + i] = 128 - 64;
    }
  }
  return updatePixels();
};

compare = function compare() {
  // Lägg en timer på denna. Bör vänta någon sekund
  var a, b, c, i, i4, l, len, ref;
  a = buffer[0];
  b = buffer[1];
  c = a.slice(0);
  if (msg.val() === '') {
    ref = range(block / 4);
    for (l = 0, len = ref.length; l < len; l++) {
      i = ref[l];
      i4 = 4 * i;
      c[i4 + 0] = abs(c[i4 + 0] - b[i4 + 0]);
      c[i4 + 1] = abs(c[i4 + 1] - b[i4 + 1]);
      c[i4 + 2] = abs(c[i4 + 2] - b[i4 + 2]);
      c[i4 + 3] = 255;
    }
  }
  fetch(a, 0);
  if (msg.val() === '') {
    fetch(b, 1);
    fetch(c, 2);
  }
  return fix_frames();
};

tableClear = function tableClear() {
  return $("#tabell tr").remove();
};

tableAppend = function tableAppend(t, call, expected, actual) {
  // exakt tre rader
  var cell1, cell2, cell4, cell6, dummy, row;
  row = t.insertRow(-1);
  cell1 = row.insertCell(-1);
  cell2 = row.insertCell(-1);
  cell1.innerHTML = call;
  cell2.innerHTML = JSON.stringify(expected);
  cell2.style.backgroundColor = '#00FF00';
  if (_.isEqual(expected, actual)) {
    return;
  }
  row = t.insertRow(-1);
  dummy = row.insertCell(-1);
  cell4 = row.insertCell(-1);
  cell4.innerHTML = JSON.stringify(actual);
  cell4.style.backgroundColor = '#FF0000';
  row = t.insertRow(-1);
  dummy = row.insertCell(-1);
  cell6 = row.insertCell(-1);
  return cell6.innerHTML = firstDiff(cell2.innerHTML, cell4.innerHTML);
};

firstDiff = function firstDiff(a, b) {
  // return index and differing characters
  var i, l, len, ref, res;
  res = '';
  if (a === b) {
    return '';
  }
  ref = range(_.min([a.length, b.length]));
  for (l = 0, len = ref.length; l < len; l++) {
    i = ref[l];
    res += a[i] === b[i] ? '·' : '^';
  }
  return res;
};

fillTable = function fillTable(a, b) {
  var key, keys, l, len, results, value;
  try {
    a = JSON.parse(localStorage[a]);
    b = JSON.parse(localStorage[b]);
    tableClear();
    keys = [];
    for (key in a) {
      value = a[key];
      keys.push(key);
    }
    for (key in b) {
      value = b[key];
      keys.push(key);
    }
    sort(keys);
    keys = _.uniq(keys);
    results = [];
    for (l = 0, len = keys.length; l < len; l++) {
      key = keys[l];
      if (key !== '_name' && key !== '_type') {
        results.push(tableAppend(tabell, "@" + key, _unmark(a[key]), _unmark(b[key])));
      } else {
        results.push(void 0);
      }
    }
    return results;
  } catch (error) {}
};

_unmark = function unmark(obj) {
  var item, key, res, value;
  if (_.isArray(obj)) {
    return function () {
      var l, len, results;
      results = [];
      // array
      for (l = 0, len = obj.length; l < len; l++) {
        item = obj[l];
        results.push(_unmark(item));
      }
      return results;
    }();
  }
  if (_.isObject(obj)) {
    res = {};
    for (key in obj) {
      value = obj[key];
      res[key] = _unmark(value); // if key != '_type'
    }
    return res;
  }
  return obj;
};
//# sourceMappingURL=p5dojo.js.map
