'use strict';

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

// Generated by CoffeeScript 2.0.3
// todo: Code Mirror hanterar inte toggleComment via Ctrl+/

// if the renew button is available, a new version of the b code is available.
// Clicking renew prints the current b code on the console as a backup.
var bg, block, buffer, buildKeywordLink, buildLink, cc, cct, changeLayout, circle, co, compare, decorate, editor_change, fc, fetch, fillSelect, fillTable, firstDiff, fixColor, fix_frames, gap, grid, ip, kwl, kwlinks, meny, mousePressed, msg, myCodeMirror, myprint, range, rd, reset, resizeTimer, run, run0, run1, saveSourceCode, saveToKeyStorage, sc, setMsg, setup, store, sw, tableAppend, tableClear, _unmark, updateTables;

myCodeMirror = null;

msg = null;

kwl = {};

kwlinks = [];

gap = 0;

block = 0;

buffer = [[], [], []];

meny = null;

setMsg = function setMsg(e, nr) {
  var p, s;
  if (e === '') {
    msg.val("");
    msg.hide();
  } else {
    s = e.toString();
    p = s.indexOf(':');
    if (p !== -1) {
      s = s.substr(p + 1);
    }
    s = s.replace(/\t/g, '  ');
    msg.val(s + ' (' + e.name + ')' + (nr === 1 ? " (in A)" : ""));
    msg.show();
  }
  return msg.css('background-color', e === '' ? '#FFFFFF' : '#FF0000');
};

grid = function grid() {
  var i, l, len, ref;
  push();
  bg(0.25);
  sc(0.5);
  ref = range(11);
  for (l = 0, len = ref.length; l < len; l++) {
    i = ref[l];
    line(0, 20 * i, 200, 20 * i);
    line(20 * i, 0, 20 * i, 200);
  }
  return pop();
};

myprint = function myprint() {
  return print(Array.prototype.slice.call(arguments).join(" "));
};

co = function co() {
  return fixColor(arguments);
};

ip = function ip(y1, y2, x, x1, x2) {
  if (arguments.length === 3) {
    x1 = 0;
    x2 = 9;
  }
  return map(x, x1, x2, y1, y2);
};

fixColor = function fixColor(args) {
  var a, b, g, n, r;
  n = args.length;
  r = 0;
  g = 0;
  b = 0;
  a = 1;
  if (n === 1) {
    r = args[0];
    g = r;
    b = r;
  } else if (n === 3) {
    r = args[0];
    g = args[1];
    b = args[2];
  } else if (n === 4) {
    r = args[0];
    g = args[1];
    b = args[2];
    a = args[3];
  }
  return color(255 * r, 255 * g, 255 * b, 255 * a);
};

bg = function bg() {
  return background(fixColor(arguments));
};

fc = function fc() {
  var n;
  n = arguments.length;
  if (n === 0) {
    return noFill();
  } else {
    return fill(fixColor(arguments));
  }
};

sc = function sc() {
  var n;
  n = arguments.length;
  if (n === 0) {
    return noStroke();
  } else {
    return stroke(fixColor(arguments));
  }
};

//b g c = (cc) -> bg cc%2, int(cc/2)%2, int(cc/4)
//f c c = (cc) -> fc cc%2, int(cc/2)%2, int(cc/4)
//s c c = (cc) -> sc cc%2, int(cc/2)%2, int(cc/4)
//t c c = (cc) -> f c c [7,7,0,0,7,0,0,0][cc]
cc = function cc(n) {
  // https://github.com/jonasjacek/colors with modifications
  var b, g, helper, lst, r, z;
  helper = function helper(n, big) {
    return [n % 2 * big, int(n / 2) % 2 * big, int(n / 4) * big];
  };
  if (n < 8) {
    return helper(n, 255);
  } else if (n === 8) {
    return [192, 192, 192];
  } else if (n < 16) {
    return helper(n - 8, 128);
  } else if (n === 16) {
    return [64, 64, 64];
  } else if (n < 232) {
    n -= 16;
    r = n % 6;
    n = Math.floor(n / 6);
    g = n % 6;
    n = Math.floor(n / 6);
    b = n;
    lst = [0, 95, 135, 175, 215, 255];
    return [lst[r], lst[g], lst[b]];
  } else {
    n -= 232;
    z = lerp(8, 18, n);
    return [z, z, z];
  }
};

cct = function cct(n) {
  // makes text visible
  var b, g, r;

  var _cc = cc(n);

  var _cc2 = _slicedToArray(_cc, 3);

  r = _cc2[0];
  g = _cc2[1];
  b = _cc2[2];

  if (r + g + b >= 3 * 128) {
    return [0, 0, 0];
  } else {
    return [255, 255, 255];
  }
};

sw = function sw(n) {
  return strokeWeight(n);
};

circle = function circle(x, y, r) {
  return ellipse(x, y, 2 * r, 2 * r);
};

rd = function rd(vinkel) {
  return rotate(radians(vinkel));
};

range = _.range;

fillSelect = function fillSelect(sel, dict) {
  var key, results;
  sel.empty();
  results = [];
  for (key in dict) {
    results.push(sel.append($("<option>").attr('value', key).text(key)));
  }
  return results;
};

buildLink = function buildLink(keyword) {
  var nr;
  if (keyword.indexOf('_.') === 0) {
    keyword = keyword.replace('_.', '');
  }
  nr = kwl[keyword];
  if (nr === void 0) {
    return;
  }
  if (nr === 0) {
    keyword = keyword.toLowerCase();
  }
  if (nr === null) {
    return null;
  } else {
    keyword = keyword.replace('[]', 'array');
    keyword = keyword.replace('""', 'string');
    keyword = keyword.replace('{}', 'object');
    keyword = keyword.replace('->', 'pil');
    keyword = keyword.replace('@', 'this');
    keyword = keyword.replace('...', 'exclusiverange');
    keyword = keyword.replace('..', 'inclusiverange');
    keyword = keyword.replace('HSB', 'colorMode');
    return kwlinks[nr].replace('{}', keyword);
  }
};

buildKeywordLink = function buildKeywordLink() {
  var save;
  kwl = {};
  kwlinks = [];
  kwlinks.push('https://github.com/ChristerNilsson/p5Dojo/blob/master/README.md#{}');
  kwlinks.push('https://p5js.org/reference/#/p5/{}');
  kwlinks.push('https://www.w3schools.com/jsref/jsref_{}.asp');
  kwlinks.push('https://github.com/ChristerNilsson/p5Dojo/blob/master/_.md#{}');
  save = function save(index, words) {
    var l, len, ref, results, word;
    ref = words.split(' ');
    results = [];
    for (l = 0, len = ref.length; l < len; l++) {
      word = ref[l];
      results.push(kwl[word] = index);
    }
    return results;
  };
  save(0, '[] "" {} .. ... @ -> class text textSize textAlign textFont operators comparisons logical if bg fc sc sw');
  save(0, 'range circle for while angleMode readText readInt readFloat');
  save(0, 'PI sqrt atan2 abs cos sin log10 Date arc rect ellipse point line triangle quad arguments');
  save(0, 'parseInt parseFloat dist nf constrain int round map lerp radians rotate reduce');
  save(1, 'rectMode translate scale push pop random millis colorMode HSB strokeCap');
  save(2, 'break return');
  return save(3, 'contains filter countBy isEqual last max min pairs sortBy findIndex');
};

mousePressed = function mousePressed() {
  var code, dict, objekt, p, ref, ref1, ref2, ref3;
  if (meny.chapter === '' || meny.exercise === '') {
    return;
  }
  p = null;
  if (0 <= (ref = mouseX - 5) && ref <= 200 && 0 <= (ref1 = mouseY - 5) && ref1 <= 200) {
    p = [mouseX - 5, mouseY - 5];
  }
  if (0 <= (ref2 = mouseX - 5) && ref2 <= 200 && 0 <= (ref3 = mouseY - 210) && ref3 <= 200) {
    p = [mouseX - 5, mouseY - 210];
  }
  if (p) {
    dict = data[meny.chapter][meny.exercise].c;
    if (dict != null) {
      objekt = _.keys(dict)[0];
      code = objekt + ('.mousePressed(' + p[0] + ',' + p[1] + '); ') + objekt + ".draw(); " + objekt + ".store()";
      if (run1(code) === true) {
        run0(code);
        return compare();
      }
    }
  }
};

decorate = function decorate(dict) {
  // {klocka: "draw|incr_hour"}
  var l, len, method, methods, objekt, res, s;
  if (dict === void 0) {
    return {};
  }
  if (dict === null) {
    return {};
  }
  res = {};
  for (objekt in dict) {
    s = dict[objekt];
    methods = s.split("|");
    res["draw()"] = objekt + ".draw(); " + objekt + ".store()";
    for (l = 0, len = methods.length; l < len; l++) {
      method = methods[l];
      res[method] = objekt + "." + method + "; " + objekt + ".draw(); " + objekt + ".store()";
    }
  }
  return res;
};

changeLayout = function changeLayout() {
  var w;
  w = $(window).width();
  $(".CodeMirror").width(w - 425);
  $("#canvas").css({
    top: 0,
    left: 205,
    position: 'absolute'
  });
  $("#msg").width(w - 430);
  return $("#input").width(w - 218);
};

resizeTimer = 0;

$(window).resize(function () {
  clearTimeout(resizeTimer);
  return resizeTimer = setTimeout(changeLayout, 10);
});

updateTables = function updateTables() {
  meny.rensa();
  return meny.traverse();
};

setup = function setup() {
  var c, timestamp;
  meny = new Menu(data, document.getElementById("meny"));
  updateTables();
  timestamp = millis();
  c = createCanvas(5 + 201 + 5, 3 * 201 + 20);
  buildKeywordLink();
  gap = 5 * width * 4;
  block = 201 * width * 4;
  pixelDensity(1);
  c.parent('canvas');
  return msg = $('#msg');
};

window.onbeforeunload = function () {
  var blob, chapter, exercise, i, key1, key2, l, len, ref, res, s;
  if (document.URL.indexOf("record") === -1) {
    return;
  }
  res = [];
  for (key1 in data) {
    chapter = data[key1];
    for (key2 in chapter) {
      exercise = chapter[key2];
      if (exercise.d) {
        res.push('### ' + key1 + ' ### ' + key2 + '\n');
        ref = exercise.d;
        for (i = l = 0, len = ref.length; l < len; i = ++l) {
          s = ref[i];
          res.push('=== ' + i + '\n');
          res.push(s + "\n");
        }
      }
    }
  }
  blob = new Blob(res, {
    type: "text/plain;charset=utf-8"
  });
  saveAs(blob, "recording.txt");
  return true;
};

window.onload = function () {
  var ta;
  ta = document.getElementById("code");
  myCodeMirror = CodeMirror.fromTextArea(document.getElementById("code"), {
    lineNumbers: true,
    mode: "coffeescript",
    keyMap: "sublime",
    theme: "dracula",
    autoCloseBrackets: true,
    lineWiseCopyCut: true,
    tabSize: 2,
    indentWithTabs: true,
    matchBrackets: true
  });
  $(".CodeMirror").css('font-size', "16pt");
  myCodeMirror.on("change", editor_change);
  meny.chapter = "";
  meny.exercise = "";
  myCodeMirror.setValue('# Klicka först på L1:\n# Klicka därefter på Background1');
  myCodeMirror.focus();
  window.resizeTo(1000, 750);
  changeLayout();
  return meny.setState(0);
};

saveToKeyStorage = function saveToKeyStorage(b) {
  var l, len, line, place, ref, s;
  s = "";
  ref = b.split('\n');
  for (l = 0, len = ref.length; l < len; l++) {
    line = ref[l];
    if (line.indexOf("#") !== 0) {
      s += line;
    }
  }
  place = data[meny.chapter][meny.exercise];
  if (!place.d) {
    place.d = [];
  }
  return place.d.push(s);
};

editor_change = function editor_change() {
  var code, dce, res;
  reset();
  if (meny.exercise === '') {
    return;
  }
  if (0 === _.size(meny.calls)) {
    code = ""; // transpile, draw
  } else {
    code = meny.calls["draw()"];
  }
  dce = data[meny.chapter][meny.exercise];
  if (dce && dce.a && _.size(dce.a.c) > 0) {
    if (false === run1(code)) {
      // bör normalt vara true
      return;
    }
  }
  res = run0(code);
  //if res # spara källkod EFTER exekvering
  saveSourceCode();
  return compare();
};

saveSourceCode = function saveSourceCode() {
  return localStorage[meny.exercise + "/d"] = myCodeMirror.getValue();
};

run0 = function run0(code) {
  var src;
  if (meny.exercise === "") {
    return false;
  }
  src = myCodeMirror.getValue();
  return run(0, src + "\n" + code);
};

run1 = function run1(code) {
  if (meny.exercise === "") {
    return;
  }
  return run(1, data[meny.chapter][meny.exercise].a + "\n" + code);
};

reset = function reset() {
  resetMatrix();
  colorMode(RGB, 255);
  angleMode(RADIANS);
  rectMode(CORNER);
  strokeCap(ROUND);
  textAlign(LEFT, BASELINE);
  smooth(); // pga SuperCircle
  bg(0);
  fc(0);
  sc(1);
  return sw(1);
};

run = function run(_n, coffee) {
  var code, e;
  reset();
  push();
  translate(5, 5);
  grid();
  setMsg("", _n);
  if (meny.exercise === "") {
    pop();
    return true;
  }
  try {
    code = transpile(coffee);
    try {
      eval(code);
      buffer[1 - _n] = store();
      pop();
      return true;
    } catch (error) {
      e = error;
      setMsg(e, _n);
      pop();
      return false;
    }
  } catch (error) {
    e = error;
    setMsg(e, _n);
    pop();
    return false;
  }
};

store = function store() {
  loadPixels();
  return pixels.slice(gap, gap + block);
};

fetch = function fetch(buffer, y0) {
  var i, l, len, ref;
  loadPixels();
  ref = range(block);
  for (l = 0, len = ref.length; l < len; l++) {
    i = ref[l];
    pixels[gap + (gap + block) * y0 + i] = buffer[i];
  }
  return updatePixels();
};

fix_frames = function fix_frames() {
  var i, j, k, l, len, len1, len2, len3, m, o, q, ref, ref1, ref2, ref3;
  loadPixels();
  ref = range(4);
  for (l = 0, len = ref.length; l < len; l++) {
    k = ref[l];
    ref1 = range(gap);
    for (m = 0, len1 = ref1.length; m < len1; m++) {
      i = ref1[m];
      pixels[(gap + block) * k + i] = 128 - 64;
    }
  }
  ref2 = range(height);
  // 3*201+20
  for (o = 0, len2 = ref2.length; o < len2; o++) {
    j = ref2[o];
    ref3 = range(20);
    for (q = 0, len3 = ref3.length; q < len3; q++) {
      i = ref3[q];
      pixels[j * width * 4 + i] = 128 - 64;
      pixels[j * width * 4 + 206 * 4 + i] = 128 - 64;
    }
  }
  return updatePixels();
};

compare = function compare() {
  // Lägg en timer på denna. Bör vänta någon sekund
  var a, b, c, i, i4, l, len, ref;
  a = buffer[0];
  b = buffer[1];
  c = a.slice(0);
  if (msg.val() === '') {
    ref = range(block / 4);
    for (l = 0, len = ref.length; l < len; l++) {
      i = ref[l];
      i4 = 4 * i;
      c[i4 + 0] = abs(c[i4 + 0] - b[i4 + 0]);
      c[i4 + 1] = abs(c[i4 + 1] - b[i4 + 1]);
      c[i4 + 2] = abs(c[i4 + 2] - b[i4 + 2]);
      c[i4 + 3] = 255;
    }
  }
  fetch(a, 0);
  if (msg.val() === '') {
    fetch(b, 1);
    fetch(c, 2);
  }
  return fix_frames();
};

tableClear = function tableClear() {
  return $("#tabell tr").remove();
};

tableAppend = function tableAppend(t, call, expected, actual) {
  // exakt tre rader
  var cell1, cell2, cell4, cell6, dummy, row;
  row = t.insertRow(-1);
  cell1 = row.insertCell(-1);
  cell2 = row.insertCell(-1);
  cell1.innerHTML = call;
  cell2.innerHTML = JSON.stringify(expected);
  cell2.style.backgroundColor = '#00FF00';
  if (_.isEqual(expected, actual)) {
    return;
  }
  row = t.insertRow(-1);
  dummy = row.insertCell(-1);
  cell4 = row.insertCell(-1);
  cell4.innerHTML = JSON.stringify(actual);
  cell4.style.backgroundColor = '#FF0000';
  row = t.insertRow(-1);
  dummy = row.insertCell(-1);
  cell6 = row.insertCell(-1);
  return cell6.innerHTML = firstDiff(cell2.innerHTML, cell4.innerHTML);
};

firstDiff = function firstDiff(a, b) {
  // return index and differing characters
  var i, l, len, ref, res;
  res = '';
  if (a === b) {
    return '';
  }
  ref = range(_.min([a.length, b.length]));
  for (l = 0, len = ref.length; l < len; l++) {
    i = ref[l];
    res += a[i] === b[i] ? '·' : '^';
  }
  return res;
};

fillTable = function fillTable(a, b) {
  var key, keys, l, len, results, value;
  try {
    a = JSON.parse(localStorage[a]);
    b = JSON.parse(localStorage[b]);
    tableClear();
    keys = [];
    for (key in a) {
      value = a[key];
      keys.push(key);
    }
    for (key in b) {
      value = b[key];
      keys.push(key);
    }
    sort(keys);
    keys = _.uniq(keys);
    results = [];
    for (l = 0, len = keys.length; l < len; l++) {
      key = keys[l];
      if (key !== '_name' && key !== '_type') {
        results.push(tableAppend(tabell, "@" + key, _unmark(a[key]), _unmark(b[key])));
      } else {
        results.push(void 0);
      }
    }
    return results;
  } catch (error) {}
};

_unmark = function unmark(obj) {
  var item, key, res, value;
  if (_.isArray(obj)) {
    return function () {
      var l, len, results;
      results = [];
      // array
      for (l = 0, len = obj.length; l < len; l++) {
        item = obj[l];
        results.push(_unmark(item));
      }
      return results;
    }();
  }
  if (_.isObject(obj)) {
    res = {};
    for (key in obj) {
      value = obj[key];
      res[key] = _unmark(value); // if key != '_type'
    }
    return res;
  }
  return obj;
};
//# sourceMappingURL=p5dojo.js.map
