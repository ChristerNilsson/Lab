"use strict";

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// Generated by CoffeeScript 2.0.3
var Arc, Circle, Group, Polygon, Rect, Shape, Vector, cn, draw, karusell, mouseMoved, setup, stage, testCircle, testRect, testVector;

stage = null;

cn = {};

//########
karusell = null;

Vector = function () {
  function Vector() {
    var x1 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var y1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

    _classCallCheck(this, Vector);

    this.x = x1;
    this.y = y1;
    this.rotation = atan2(this.y, this.x);
    this.length = sqrt(this.x * this.x + this.y * this.y);
  }

  _createClass(Vector, [{
    key: "add",
    value: function add(vector) {
      return new Vector(this.x + vector.x, this.y + vector.y);
    }
  }, {
    key: "sub",
    value: function sub(vector) {
      return new Vector(this.x - vector.x, this.y - vector.y);
    }
  }, {
    key: "rotate",
    value: function rotate(degrees) {
      var v, x, y;
      v = this.rotation + degrees;
      x = this.length * cos(v);
      y = this.length * sin(v);
      return new Vector(x, y);
    }
  }]);

  return Vector;
}();

testVector = function testVector() {
  var a, b, c;
  a = new Vector(10, 20);
  assert(10, a.x);
  assert(20, a.y);
  a = a.rotate(90);
  assert(-20.000000000000004, a.x);
  assert(9.999999999999995, a.y);
  b = new Vector(10, 10);
  assert(45, b.rotation);
  assert(14.142135623730951, b.length);
  c = b.add(b);
  assert(20, c.x);
  assert(20, c.y);
  c = c.sub(b);
  assert(10, c.x);
  return assert(10, c.y);
};

Shape = function () {
  function Shape() {
    var x1 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var y1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var parent1 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var rotation1 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

    _classCallCheck(this, Shape);

    this.x = x1;
    this.y = y1;
    this.parent = parent1;
    this.rotation = rotation1;
    this.children = [];
    this.fillColor = "#fff";
    this.strokeColor = "#000";
    this.strokeWeight = 1;
    if (this.parent != null) {
      this.parent.add(this);
    }
  }

  _createClass(Shape, [{
    key: "draw",
    value: function draw() {
      var child, k, len, ref, results;
      translate(this.x, this.y);
      rotate(this.rotation);
      ref = this.children;
      results = [];
      for (k = 0, len = ref.length; k < len; k++) {
        child = ref[k];
        push();
        child.draw();
        results.push(pop());
      }
      return results;
    }
  }, {
    key: "add",
    value: function add(shape) {
      return this.children.push(shape);
    }
  }, {
    key: "fill",
    value: function fill(color) {
      this.fillColor = color;
      return this;
    }
  }, {
    key: "stroke",
    value: function stroke(color) {
      this.strokeColor = color;
      return this;
    }
  }, {
    key: "contains",
    value: function contains(m) {
      // m is mouse position
      var p2, p3, p4, rotation, x, y;

      var _stagepos = this.stagepos();

      var _stagepos2 = _slicedToArray(_stagepos, 3);

      x = _stagepos2[0];
      y = _stagepos2[1];
      rotation = _stagepos2[2];

      p2 = new Vector(x, y);
      p3 = m.sub(p2);
      p4 = p3.rotate(-rotation);
      return this.inside(p4); //, @points
    }
  }, {
    key: "stagepos",
    value: function stagepos() {
      // returns resulting [x, y, rotation]
      var current, k, len, lst, rot, rotation, rotres, v1, v2, vec, x, y;
      lst = [];
      current = this;
      while (current) {
        lst.unshift([current.x, current.y, current.rotation]);
        current = current.parent;
      }
      vec = new Vector();
      rot = 0;
      rotres = 0;
      for (k = 0, len = lst.length; k < len; k++) {
        var _lst$k = _slicedToArray(lst[k], 3);

        x = _lst$k[0];
        y = _lst$k[1];
        rotation = _lst$k[2];

        rotres += rotation;
        v1 = new Vector(x, y);
        v2 = v1.rotate(rot);
        rot = rotation;
        vec = vec.add(v2);
      }
      return [vec.x, vec.y, rotres];
    }
  }, {
    key: "mouseMoved",
    value: function mouseMoved(m) {
      // m = mouse position
      var child, k, len, ref, results;
      ref = this.children;
      results = [];
      for (k = 0, len = ref.length; k < len; k++) {
        child = ref[k];
        child.strokeWeight = child.contains(m) ? 3 : 1;
        results.push(child.mouseMoved(m));
      }
      return results;
    }
  }]);

  return Shape;
}();

Polygon = function (_Shape) {
  _inherits(Polygon, _Shape);

  function Polygon(x, y) {
    var parent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : stage;

    _classCallCheck(this, Polygon);

    var _this = _possibleConstructorReturn(this, (Polygon.__proto__ || Object.getPrototypeOf(Polygon)).call(this, x, y, parent));

    _this.points = [];
    return _this;
  }

  _createClass(Polygon, [{
    key: "lineTo",
    value: function lineTo(x, y) {
      return this.points.push(new Vector(x, y));
    }
  }, {
    key: "draw",
    value: function draw() {
      var k, len, p, ref;
      _get(Polygon.prototype.__proto__ || Object.getPrototypeOf(Polygon.prototype), "draw", this).call(this);
      fill(this.fillColor);
      strokeWeight(this.strokeWeight);
      beginShape();
      ref = this.points;
      for (k = 0, len = ref.length; k < len; k++) {
        p = ref[k];
        vertex(p.x, p.y);
      }
      return endShape(CLOSE);
    }
  }, {
    key: "inside",
    value: function inside(p) {
      // only checks if p is locally within polygon
      var i, intersect, j, k, len, lst, res, xi, xj, yi, yj;
      res = false;
      lst = range(this.points.length);
      lst.unshift(lst.pop());
      for (i = k = 0, len = lst.length; k < len; i = ++k) {
        j = lst[i];
        xi = this.points[i].x;
        yi = this.points[i].y;
        xj = this.points[j].x;
        yj = this.points[j].y;
        intersect = yi >= p.y !== yj >= p.y && p.x <= (xj - xi) * (p.y - yi) / (yj - yi) + xi;
        if (intersect) {
          res = !res;
        }
      }
      return res;
    }
  }]);

  return Polygon;
}(Shape);

Circle = function (_Shape2) {
  _inherits(Circle, _Shape2);

  function Circle(x, y, radius1) {
    var parent = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : stage;

    _classCallCheck(this, Circle);

    var _this2 = _possibleConstructorReturn(this, (Circle.__proto__ || Object.getPrototypeOf(Circle)).call(this, x, y, parent));

    _this2.radius = radius1;
    return _this2;
  }

  _createClass(Circle, [{
    key: "draw",
    value: function draw() {
      _get(Circle.prototype.__proto__ || Object.getPrototypeOf(Circle.prototype), "draw", this).call(this);
      fill(this.fillColor);
      strokeWeight(this.strokeWeight);
      return circle(0, 0, this.radius);
    }
  }, {
    key: "inside",
    value: function inside(d) {
      return this.radius >= sqrt(d.x * d.x + d.y * d.y);
    }
  }]);

  return Circle;
}(Shape);

// class Circle extends Polygon
// 	constructor : (x,y,@radius,parent=stage) -> 
// 		super x,y,parent
// 		for v in range 0,361,10
// 			x = @radius * cos v
// 			y = @radius * sin v
// 			@lineTo x,y
testCircle = function testCircle() {
  var c;
  c = new Circle(100, 200, 50);
  assert(100, c.x);
  assert(200, c.y);
  assert(50, c.radius);
  assert([100.00000000000001, 200, 0], c.stagepos());
  assert(true, c.contains(new Vector(110, 210)));
  assert(true, c.contains(new Vector(129, 239)));
  return assert(false, c.contains(new Vector(131, 241)));
};

Arc = function (_Polygon) {
  _inherits(Arc, _Polygon);

  function Arc(x, y, radius, start, stopp) {
    var parent = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : stage;

    _classCallCheck(this, Arc);

    var k, len, ref, v;

    var _this3 = _possibleConstructorReturn(this, (Arc.__proto__ || Object.getPrototypeOf(Arc)).call(this, x, y, parent));

    ref = range(start, stopp + 1, 10);
    for (k = 0, len = ref.length; k < len; k++) {
      v = ref[k];
      x = radius * cos(v);
      y = radius * sin(v);
      _this3.lineTo(x, y);
    }
    return _this3;
  }

  return Arc;
}(Polygon);

Rect = function (_Polygon2) {
  _inherits(Rect, _Polygon2);

  function Rect(x, y, w, h) {
    var parent = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : stage;

    _classCallCheck(this, Rect);

    var _this4 = _possibleConstructorReturn(this, (Rect.__proto__ || Object.getPrototypeOf(Rect)).call(this, x, y, parent));

    w = w / 2;
    h = h / 2;
    _this4.lineTo(-w, -h, +w, -h);
    _this4.lineTo(+w, -h, +w, +h);
    _this4.lineTo(+w, +h, -w, +h);
    _this4.lineTo(-w, +h, -w, -h);
    return _this4;
  }

  return Rect;
}(Polygon);

testRect = function testRect() {
  var r;
  r = cn.rect(100, 200, 10, 20);
  assert(-5, r.points[0].x);
  assert(-10, r.points[0].y);
  assert(5, r.points[1].x);
  assert(-10, r.points[1].y);
  assert(5, r.points[2].x);
  assert(10, r.points[2].y);
  assert(-5, r.points[3].x);
  assert(10, r.points[3].y);
  assert(true, r.inside(new Vector(1, 1)));
  assert(true, r.inside(new Vector(5, 10)));
  assert(false, r.inside(new Vector(6, 10)));
  assert(false, r.inside(new Vector(5, 11)));
  assert([100.00000000000001, 200, 0], r.stagepos());
  assert(true, r.contains(new Vector(100 + 4, 200 + 4)));
  assert(true, r.contains(new Vector(100 - 4, 200 - 4)));
  assert(true, r.contains(new Vector(100 - 4, 200 + 4)));
  assert(true, r.contains(new Vector(100 + 4, 200 - 4)));
  r = cn.rect(100, 200, 10, 10);
  r.rotation = 45;
  print(r);
  assert(true, r.contains(new Vector(100 + 3, 200 + 3)));
  assert(false, r.contains(new Vector(100 + 4, 200 + 4)));
  assert(true, r.contains(new Vector(100 + 7, 200 + 0)));
  return assert(false, r.contains(new Vector(100 + 8, 200 + 0)));
};

// assert true, r.contains new Vector 100-4,200-4
// assert true, r.contains new Vector 100-4,200+4
// assert true, r.contains new Vector 100+4,200-4

//	assert true,r.contains new Vector 1,1
// d2 = new Vector 140,230
// assert true,r.contains d1.sub d2
// d2 = new Vector 141,231
// assert false,r.contains d1.sub d2
Group = function (_Shape3) {
  _inherits(Group, _Shape3);

  function Group(x, y) {
    var parent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : stage;

    _classCallCheck(this, Group);

    return _possibleConstructorReturn(this, (Group.__proto__ || Object.getPrototypeOf(Group)).call(this, x, y, parent));
  }

  _createClass(Group, [{
    key: "contains",
    value: function contains() {}
  }]);

  return Group;
}(Shape);

cn.shape = function () {
  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  return new (Function.prototype.bind.apply(Shape, [null].concat(args)))();
};

cn.group = function () {
  for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    args[_key2] = arguments[_key2];
  }

  return new (Function.prototype.bind.apply(Group, [null].concat(args)))();
};

cn.circle = function () {
  for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
    args[_key3] = arguments[_key3];
  }

  return new (Function.prototype.bind.apply(Circle, [null].concat(args)))();
};

cn.arc = function () {
  for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
    args[_key4] = arguments[_key4];
  }

  return new (Function.prototype.bind.apply(Arc, [null].concat(args)))();
};

cn.rect = function () {
  for (var _len5 = arguments.length, args = Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
    args[_key5] = arguments[_key5];
  }

  return new (Function.prototype.bind.apply(Rect, [null].concat(args)))();
};

//#########################
setup = function setup() {
  var a, b;
  createCanvas(600, 600);
  angleMode(DEGREES);

  // testVector()
  // testCircle()
  // testRect()
  stage = new Shape();
  karusell = cn.group(200, 200);
  karusell.name = 'karusell';
  a = cn.circle(0, 0, 100, karusell).fill("#ff0");
  b = cn.rect(0, -100, 100, 100, karusell).fill("#f00");
  a.name = 'circle';
  b.name = 'rect';
  cn.rect(-100, 0, 100, 100, karusell).fill("#0f0");
  cn.circle(0, 100, 50, karusell).fill("#fff");
  cn.arc(100, 0, 50, 0, 180, karusell).fill("#f00");
  cn.arc(100, 0, -50, 0, 180, karusell).fill("#0f0");
  karusell.rotation = 45;
  //xdraw()
  //xdraw()
  return print(stage);
};

draw = function draw() {
  var child, k, len, ref, results;
  bg(1);
  stage.draw();
  karusell.rotation += 0.1;
  ref = karusell.children;
  results = [];
  for (k = 0, len = ref.length; k < len; k++) {
    child = ref[k];
    results.push(child.rotation += 0.05);
  }
  return results;
};

mouseMoved = function mouseMoved() {
  return stage.mouseMoved(new Vector(mouseX, mouseY));
};
//# sourceMappingURL=sketch.js.map
