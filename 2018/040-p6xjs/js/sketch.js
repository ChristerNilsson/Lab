"use strict";

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// Generated by CoffeeScript 2.0.3
var Arc, Circle, Group, Polygon, Rect, Shape, Vector, cn, draw, mouseMoved, mousePressed, setup, shapes, stage;

stage = null;

cn = {};

//########
shapes = {};

Vector = function () {
  function Vector() {
    var x1 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var y1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

    _classCallCheck(this, Vector);

    this.x = x1;
    this.y = y1;
    this.rotation = atan2(this.y, this.x);
    this.length = sqrt(this.x * this.x + this.y * this.y);
  }

  _createClass(Vector, [{
    key: "add",
    value: function add(vector) {
      return new Vector(this.x + vector.x, this.y + vector.y);
    }
  }, {
    key: "sub",
    value: function sub(vector) {
      return new Vector(this.x - vector.x, this.y - vector.y);
    }
  }, {
    key: "rotate",
    value: function rotate(degrees) {
      var v, x, y;
      v = this.rotation + degrees;
      x = this.length * cos(v);
      y = this.length * sin(v);
      return new Vector(x, y);
    }
  }]);

  return Vector;
}();

Shape = function () {
  function Shape() {
    var x1 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var y1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var parent1 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var rotation1 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

    _classCallCheck(this, Shape);

    this.x = x1;
    this.y = y1;
    this.parent = parent1;
    this.rotation = rotation1;
    this.children = [];
    this.fillColor = "#fff";
    this.strokeColor = "#000";
    this.strokeWeight = 1;
    this.txt = '';
    if (this.parent != null) {
      this.parent.add(this);
    }
  }

  _createClass(Shape, [{
    key: "draw",
    value: function draw() {
      var child, k, len, ref, results;
      translate(this.x, this.y);
      rotate(this.rotation);
      ref = this.children;
      results = [];
      for (k = 0, len = ref.length; k < len; k++) {
        child = ref[k];
        push();
        child.draw();
        results.push(pop());
      }
      return results;
    }
  }, {
    key: "add",
    value: function add(shape) {
      return this.children.push(shape);
    }
  }, {
    key: "fill",
    value: function fill(color) {
      this.fillColor = color;
      return this;
    }
  }, {
    key: "stroke",
    value: function stroke(color) {
      this.strokeColor = color;
      return this;
    }
  }, {
    key: "text",
    value: function text(txt) {
      this.txt = txt;
      return this;
    }
  }, {
    key: "contains",
    value: function contains(m) {
      // m is mouse position
      var p, rotation, x, y;

      var _stagepos = this.stagepos();

      var _stagepos2 = _slicedToArray(_stagepos, 3);

      x = _stagepos2[0];
      y = _stagepos2[1];
      rotation = _stagepos2[2];

      p = new Vector(x, y);
      p = m.sub(p);
      p = p.rotate(-rotation);
      return this.inside(p);
    }
  }, {
    key: "stagepos",
    value: function stagepos() {
      // returns resulting [x, y, rotation]
      var current, k, len, lst, rot, rotation, rotres, v1, v2, vec, x, y;
      lst = [];
      current = this;
      while (current) {
        lst.unshift([current.x, current.y, current.rotation]);
        current = current.parent;
      }
      vec = new Vector();
      rot = 0;
      rotres = 0;
      for (k = 0, len = lst.length; k < len; k++) {
        var _lst$k = _slicedToArray(lst[k], 3);

        x = _lst$k[0];
        y = _lst$k[1];
        rotation = _lst$k[2];

        rotres += rotation;
        v1 = new Vector(x, y);
        v2 = v1.rotate(rot);
        rot = rotation;
        vec = vec.add(v2);
      }
      return [vec.x, vec.y, rotres];
    }
  }, {
    key: "clicked",
    value: function clicked(f) {
      return this.click = f;
    }
  }, {
    key: "mouseMoved",
    value: function mouseMoved(m) {
      // m = mouse position
      var child, k, len, ref, results;
      ref = this.children;
      results = [];
      for (k = 0, len = ref.length; k < len; k++) {
        child = ref[k];
        child.strokeWeight = child.contains(m) ? 3 : 1;
        results.push(child.mouseMoved(m));
      }
      return results;
    }
  }, {
    key: "mousePressed",
    value: function mousePressed(m) {
      // m = mouse position
      var child, k, len, ref, results;
      ref = this.children;
      results = [];
      for (k = 0, len = ref.length; k < len; k++) {
        child = ref[k];
        if (child.click != null) {
          if (child.contains(m)) {
            child.click();
          }
        }
        results.push(child.mousePressed(m));
      }
      return results;
    }
  }, {
    key: "move",
    value: function move(dx, dy) {
      var _ref;

      return _ref = [this.x + dx, this.y + dy], this.x = _ref[0], this.y = _ref[1], _ref;
    }
  }]);

  return Shape;
}();

Polygon = function (_Shape) {
  _inherits(Polygon, _Shape);

  function Polygon(x, y) {
    var parent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : stage;

    _classCallCheck(this, Polygon);

    var _this = _possibleConstructorReturn(this, (Polygon.__proto__ || Object.getPrototypeOf(Polygon)).call(this, x, y, parent));

    _this.points = [];
    return _this;
  }

  _createClass(Polygon, [{
    key: "lineTo",
    value: function lineTo(x, y) {
      return this.points.push(new Vector(x, y));
    }
  }, {
    key: "draw",
    value: function draw() {
      var k, len, p, ref;
      _get(Polygon.prototype.__proto__ || Object.getPrototypeOf(Polygon.prototype), "draw", this).call(this);
      fill(this.fillColor);
      strokeWeight(this.strokeWeight);
      beginShape();
      ref = this.points;
      for (k = 0, len = ref.length; k < len; k++) {
        p = ref[k];
        vertex(p.x, p.y);
      }
      return endShape(CLOSE);
    }
  }, {
    key: "inside",
    value: function inside(p) {
      // only checks if p is locally within polygon
      var i, intersect, j, k, len, lst, res, xi, xj, yi, yj;
      res = false;
      lst = range(this.points.length);
      lst.unshift(lst.pop());
      for (i = k = 0, len = lst.length; k < len; i = ++k) {
        j = lst[i];
        xi = this.points[i].x;
        yi = this.points[i].y;
        xj = this.points[j].x;
        yj = this.points[j].y;
        intersect = yi >= p.y !== yj >= p.y && p.x <= (xj - xi) * (p.y - yi) / (yj - yi) + xi;
        if (intersect) {
          res = !res;
        }
      }
      return res;
    }
  }]);

  return Polygon;
}(Shape);

Circle = function (_Shape2) {
  _inherits(Circle, _Shape2);

  function Circle(x, y, radius1) {
    var parent = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : stage;

    _classCallCheck(this, Circle);

    var _this2 = _possibleConstructorReturn(this, (Circle.__proto__ || Object.getPrototypeOf(Circle)).call(this, x, y, parent));

    _this2.radius = radius1;
    return _this2;
  }

  _createClass(Circle, [{
    key: "draw",
    value: function draw() {
      _get(Circle.prototype.__proto__ || Object.getPrototypeOf(Circle.prototype), "draw", this).call(this);
      fill(this.fillColor);
      strokeWeight(this.strokeWeight);
      circle(0, 0, this.radius);
      fill('#000');
      textSize(30);
      textAlign(CENTER, CENTER);
      return text(this.txt, 0, 0);
    }
  }, {
    key: "inside",
    value: function inside(d) {
      return this.radius >= sqrt(d.x * d.x + d.y * d.y);
    }
  }]);

  return Circle;
}(Shape);

Arc = function (_Polygon) {
  _inherits(Arc, _Polygon);

  function Arc(x, y, radius, start, stopp) {
    var parent = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : stage;

    _classCallCheck(this, Arc);

    var k, len, lst, v;

    var _this3 = _possibleConstructorReturn(this, (Arc.__proto__ || Object.getPrototypeOf(Arc)).call(this, x, y, parent));

    _this3.lineTo(0, 0);
    lst = range(start, stopp, 10);
    lst.push(stopp);
    for (k = 0, len = lst.length; k < len; k++) {
      v = lst[k];
      x = radius * cos(v);
      y = radius * sin(v);
      _this3.lineTo(x, y);
    }
    return _this3;
  }

  return Arc;
}(Polygon);

Rect = function (_Polygon2) {
  _inherits(Rect, _Polygon2);

  function Rect(x, y, w, h) {
    var parent = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : stage;

    _classCallCheck(this, Rect);

    var _this4 = _possibleConstructorReturn(this, (Rect.__proto__ || Object.getPrototypeOf(Rect)).call(this, x, y, parent));

    w = w / 2;
    h = h / 2;
    _this4.lineTo(-w, -h, +w, -h);
    _this4.lineTo(+w, -h, +w, +h);
    _this4.lineTo(+w, +h, -w, +h);
    _this4.lineTo(-w, +h, -w, -h);
    return _this4;
  }

  return Rect;
}(Polygon);

Group = function (_Shape3) {
  _inherits(Group, _Shape3);

  function Group(x, y) {
    var parent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : stage;

    _classCallCheck(this, Group);

    return _possibleConstructorReturn(this, (Group.__proto__ || Object.getPrototypeOf(Group)).call(this, x, y, parent));
  }

  _createClass(Group, [{
    key: "contains",
    value: function contains() {}
  }]);

  return Group;
}(Shape);

cn.shape = function () {
  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  return new (Function.prototype.bind.apply(Shape, [null].concat(args)))();
};

cn.group = function () {
  for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    args[_key2] = arguments[_key2];
  }

  return new (Function.prototype.bind.apply(Group, [null].concat(args)))();
};

cn.circle = function () {
  for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
    args[_key3] = arguments[_key3];
  }

  return new (Function.prototype.bind.apply(Circle, [null].concat(args)))();
};

cn.arc = function () {
  for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
    args[_key4] = arguments[_key4];
  }

  return new (Function.prototype.bind.apply(Arc, [null].concat(args)))();
};

cn.rect = function () {
  for (var _len5 = arguments.length, args = Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
    args[_key5] = arguments[_key5];
  }

  return new (Function.prototype.bind.apply(Rect, [null].concat(args)))();
};

//#########################
setup = function setup() {
  var alfabet, digit, i, k, l, len, len1, letter, numbers, results, x, y;
  createCanvas(600, 600);
  angleMode(DEGREES);

  // test()
  stage = new Shape();
  cn.circle(300, 300, 200).fill("#ff0");
  shapes.letters = cn.group(300, 300);
  shapes.digits = cn.group(300, 300);
  alfabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
  for (i = k = 0, len = alfabet.length; k < len; i = ++k) {
    letter = alfabet[i];
    x = 200 * cos(i * 360 / alfabet.length);
    y = 200 * sin(i * 360 / alfabet.length);
    cn.circle(x, y, 20, shapes.letters).fill("#f00").text(letter).clicked(function () {
      return print(this.txt);
    });
  }
  numbers = '0123456789';
  results = [];
  for (i = l = 0, len1 = numbers.length; l < len1; i = ++l) {
    digit = numbers[i];
    x = 260 * cos(i * 360 / numbers.length);
    y = 260 * sin(i * 360 / numbers.length);
    results.push(cn.circle(x, y, 40, shapes.digits).fill("#0f0").text(digit).clicked(function () {
      return print(this.txt);
    }));
  }
  return results;
};

draw = function draw() {
  var child, k, l, len, len1, ref, ref1, results;
  bg(0.5);
  stage.draw();
  shapes.letters.rotation += 0.1;
  ref = shapes.letters.children;
  for (k = 0, len = ref.length; k < len; k++) {
    child = ref[k];
    child.rotation -= 0.1;
  }
  shapes.digits.rotation -= 0.1;
  ref1 = shapes.digits.children;
  results = [];
  for (l = 0, len1 = ref1.length; l < len1; l++) {
    child = ref1[l];
    results.push(child.rotation += 0.1);
  }
  return results;
};

mouseMoved = function mouseMoved() {
  return stage.mouseMoved(new Vector(mouseX, mouseY));
};

mousePressed = function mousePressed() {
  return stage.mousePressed(new Vector(mouseX, mouseY));
};
//# sourceMappingURL=sketch.js.map
