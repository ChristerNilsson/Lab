'use strict';

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// Generated by CoffeeScript 2.0.3
var Button,
    COLORS,
    FREE,
    N,
    SIZE,
    TILE,
    b,
    bridge,
    buttons,
    draw,
    getcols,
    getlst,
    getrows,
    legal,
    makeColors,
    makeGame,
    makeMove,
    message,
    mousePressed,
    mybrightness,
    newGame,
    selected,
    setup,
    within,
    wrap,
    modulo = function modulo(a, b) {
  return (+a % (b = +b) + b) % b;
};

SIZE = 12;

TILE = 60;

FREE = -1;

N = 5;

b = null;

COLORS = null;

selected = [];

message = '';

buttons = [];

wrap = false;

Button = function () {
  function Button(x2, y2, txt, click) {
    _classCallCheck(this, Button);

    this.x = x2;
    this.y = y2;
    this.txt = txt;
    this.click = click;
    this.r = 50;
  }

  _createClass(Button, [{
    key: 'inside',
    value: function inside(x, y) {
      return this.r > dist(this.x, this.y, x, y);
    }
  }, {
    key: 'draw',
    value: function draw() {
      fc(0.5);
      sc();
      circle(this.x, this.y, this.r);
      fc(0);
      textSize(30);
      return text(this.txt, this.x, this.y);
    }
  }]);

  return Button;
}();

newGame = function newGame(n) {
  N = constrain(n, 2, 100);
  return makeGame();
};

setup = function setup() {
  createCanvas(30 + TILE * SIZE + 30, 100 + TILE * SIZE + TILE);
  rectMode(CENTER);
  makeColors();
  makeGame();
  buttons.push(new Button(80, 65, '-', function () {
    return newGame(N - 1);
  }));
  buttons.push(new Button(180, 65, N, function () {}));
  buttons.push(new Button(280, 65, '+', function () {
    return newGame(N + 1);
  }));
  return buttons.push(new Button(width - 80, 65, '', function () {
    return wrap = !wrap;
  }));
};

mybrightness = function mybrightness(s) {
  var ch, l, len, res;
  res = 0;
  for (l = 0, len = s.length; l < len; l++) {
    ch = s[l];
    res += "0123456789abcdef#".indexOf(ch);
  }
  return res;
};

makeColors = function makeColors() {
  var i, j, k, l, len, len1, len2, m, o, ref, ref1, ref2;
  COLORS = [];
  ref = "05af";
  for (l = 0, len = ref.length; l < len; l++) {
    i = ref[l];
    ref1 = "05af";
    for (m = 0, len1 = ref1.length; m < len1; m++) {
      j = ref1[m];
      ref2 = "05af";
      for (o = 0, len2 = ref2.length; o < len2; o++) {
        k = ref2[o];
        COLORS.push("#" + i + j + k);
      }
    }
  }
  COLORS = _.without(COLORS, "#000", "#005", "#00a");
  return COLORS.sort(function (a, b) {
    return mybrightness(b) - mybrightness(a);
  });
};

makeGame = function makeGame() {
  var candidates, i, j, l, len, len1, m, ref, ref1, results;
  candidates = [];
  ref = range(50);
  for (l = 0, len = ref.length; l < len; l++) {
    i = ref[l];
    candidates.push(i % N);
    candidates.push(N - 1 - i % N);
  }
  candidates = _.shuffle(candidates);
  b = new Array(SIZE);
  ref1 = range(SIZE);
  results = [];
  for (m = 0, len1 = ref1.length; m < len1; m++) {
    i = ref1[m];
    b[i] = new Array(SIZE);
    results.push(function () {
      var len2, o, ref2, results1;
      ref2 = range(SIZE);
      results1 = [];
      for (o = 0, len2 = ref2.length; o < len2; o++) {
        j = ref2[o];
        if (i === 0 || i === SIZE - 1 || j === 0 || j === SIZE - 1) {
          results1.push(b[i][j] = FREE);
        } else {
          results1.push(b[i][j] = candidates.pop());
        }
      }
      return results1;
    }());
  }
  return results;
};

draw = function draw() {
  var button, cell, i, j, l, len, len1, len2, len3, m, o, p, ref, ref1, results;
  bg(0.25);
  buttons[1].txt = N - 1;
  buttons[3].txt = wrap ? 'wrap' : 'nowrap';
  for (l = 0, len = buttons.length; l < len; l++) {
    button = buttons[l];
    button.draw();
  }
  textSize(0.8 * TILE);
  translate(TILE, TILE + 100);
  textAlign(CENTER, CENTER);
  fc(1);
  sc(0);
  ref = range(SIZE);
  for (m = 0, len1 = ref.length; m < len1; m++) {
    i = ref[m];
    ref1 = range(SIZE);
    for (o = 0, len2 = ref1.length; o < len2; o++) {
      j = ref1[o];
      fc(0);
      sc(1);
      rect(TILE * i, TILE * j, TILE, TILE);
      cell = b[i][j];
      if (cell >= 0) {
        fill(COLORS[modulo(cell, COLORS.length)]);
        sc();
        text(b[i][j], TILE * i, TILE * j);
      }
    }
  }
  results = [];
  for (p = 0, len3 = selected.length; p < len3; p++) {
    var _selected$p = _slicedToArray(selected[p], 2);

    i = _selected$p[0];
    j = _selected$p[1];

    fc(1, 1, 0, 0.5);
    sc();
    results.push(circle(TILE * i, TILE * j, TILE / 2 - 3));
  }
  return results;
};

within = function within(i, j) {
  return 0 <= i && i < SIZE && 0 <= j && j < SIZE;
};

mousePressed = function mousePressed() {
  var button, i, i1, j, j1, l, len;
  for (l = 0, len = buttons.length; l < len; l++) {
    button = buttons[l];
    if (button.inside(mouseX, mouseY)) {
      button.click();
    }
  }
  var _ref = [Math.floor((mouseX - TILE / 2) / TILE), Math.floor((mouseY - 100 - TILE / 2) / TILE)];
  i = _ref[0];
  j = _ref[1];

  if (!within(i, j)) {
    return;
  }
  if (selected.length === 0) {
    if (b[i][j] !== FREE) {
      return selected.push([i, j]);
    }
  } else {
    var _selected$ = _slicedToArray(selected[0], 2);

    i1 = _selected$[0];
    j1 = _selected$[1];

    if (i === i1 && j === j1) {
      return selected.pop();
    }
    if (b[i][j] + b[i1][j1] === N - 1) {
      if (legal(i1, j1, i, j) || legal(i, j, i1, j1) || bridge(i, j, i1, j1)) {
        b[i][j] = b[i1][j1] = FREE;
        return selected.pop();
      }
    }
  }
};

makeMove = function makeMove(x, y) {
  if (wrap) {
    return [modulo(x, SIZE), modulo(x, SIZE)];
  } else {
    return [x, y];
  }
};

// A*. This algorithm blocks itself sometimes.
// That's why bridge is also used.
legal = function legal(i0, j0, i1, j1) {
  var cands, dx, dy, front, index, index0, key, l, len, len1, m, next, reached, ref, start, turns, turns0, x, x0, y, y0;
  start = [0, i0, j0, -1];
  cands = [];
  cands.push(start);
  reached = {};
  reached[[i0, j0]] = start;
  while (cands.length > 0) {
    front = cands;
    front.sort(function (a, b) {
      return a[0] - b[0];
    });
    cands = [];
    for (l = 0, len = front.length; l < len; l++) {
      var _front$l = _slicedToArray(front[l], 4);

      turns0 = _front$l[0];
      x0 = _front$l[1];
      y0 = _front$l[2];
      index0 = _front$l[3];

      ref = [[-1, 0], [1, 0], [0, -1], [0, 1]];
      for (index = m = 0, len1 = ref.length; m < len1; index = ++m) {
        var _ref$index = _slicedToArray(ref[index], 2);

        dx = _ref$index[0];
        dy = _ref$index[1];

        var _makeMove = makeMove(x0 + dx, y0 + dy);

        var _makeMove2 = _slicedToArray(_makeMove, 2);

        x = _makeMove2[0];
        y = _makeMove2[1];

        key = [x, y];
        turns = turns0;
        if (index !== index0 && index0 !== -1) {
          turns++;
        }
        next = [turns, x, y, index];
        if (x === i1 && y === j1) {
          return 2 >= turns;
        }
        if (within(x, y)) {
          if (b[x][y] === FREE) {
            if (!(key in reached) || reached[key][0] > next[0]) {
              reached[key] = next;
              cands.push(next);
            }
          }
        }
      }
    }
  }
  return false;
};

getlst = function getlst(x0, y0, dx, dy) {
  var resx, resy, x, y;
  resx = [];
  resy = [];

  var _makeMove3 = makeMove(x0 + dx, y0 + dy);

  var _makeMove4 = _slicedToArray(_makeMove3, 2);

  x = _makeMove4[0];
  y = _makeMove4[1];

  while (within(x, y)) {
    if (b[x][y] !== FREE) {
      return [resx, resy];
    }
    resx.push(x);
    resy.push(y);

    var _makeMove5 = makeMove(x + dx, y + dy);

    var _makeMove6 = _slicedToArray(_makeMove5, 2);

    x = _makeMove6[0];
    y = _makeMove6[1];
  }
  return [resx, resy];
};

getrows = function getrows(x0, x1) {
  var found, l, len, len1, m, ref, ref1, res, x, y;
  res = [];
  ref = range(SIZE);
  for (l = 0, len = ref.length; l < len; l++) {
    y = ref[l];
    found = false;
    ref1 = range(x0, x1);
    for (m = 0, len1 = ref1.length; m < len1; m++) {
      x = ref1[m];
      if (b[x][y] !== FREE) {
        found = true;
      }
    }
    if (!found) {
      res.push(y);
    }
  }
  return res;
};

getcols = function getcols(y0, y1) {
  var found, l, len, len1, m, ref, ref1, res, x, y;
  res = [];
  ref = range(SIZE);
  for (l = 0, len = ref.length; l < len; l++) {
    x = ref[l];
    found = false;
    ref1 = range(y0, y1);
    for (m = 0, len1 = ref1.length; m < len1; m++) {
      y = ref1[m];
      if (b[x][y] !== FREE) {
        found = true;
      }
    }
    if (!found) {
      res.push(x);
    }
  }
  return res;
};

bridge = function bridge(x0, y0, x1, y1) {
  var lst1, lst2, lst3, lst4, lst5;
  lst1 = getlst(x0, y0, 0, -1)[1].concat(getlst(x0, y0, 0, 1)[1]);
  lst2 = getlst(x1, y1, 0, -1)[1].concat(getlst(x1, y1, 0, 1)[1]);
  lst3 = getrows(_.min([x0, x1]) + 1, _.max([x0, x1]));
  lst4 = _.intersection(lst1, lst2, lst3);
  lst1 = getlst(x0, y0, -1, 0)[0].concat(getlst(x0, y0, 1, 0)[0]);
  lst2 = getlst(x1, y1, -1, 0)[0].concat(getlst(x1, y1, 1, 0)[0]);
  lst3 = getcols(_.min([y0, y1]) + 1, _.max([y0, y1]));
  lst5 = _.intersection(lst1, lst2, lst3);
  return lst4.length > 0 || lst5.length > 0;
};
//# sourceMappingURL=sketch.js.map
