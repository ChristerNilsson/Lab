'use strict';

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

// Generated by CoffeeScript 2.0.3
var COLORS, FREE, N, SIZE, TILE, b, bridge, draw, getcols, getlst, getrows, legal, makeGame, message, mousePressed, selected, setup, within;

SIZE = 12;

TILE = 60;

FREE = -1;

N = 10; // 2 3 4 5 6 7 8 9 10

b = null;

COLORS = '#f00 #0f0 #00f #ff0 #000 #fff #f0f #0ff #444 #bbb #123'.split(' ');

selected = [];

message = '';

setup = function setup() {
  createCanvas(800, 800);
  rectMode(CENTER);
  textSize(0.8 * TILE);
  return makeGame();
};

makeGame = function makeGame() {
  var candidates, i, j, k, l, len, len1, ref, ref1, results;
  candidates = [];
  ref = range(100);
  for (k = 0, len = ref.length; k < len; k++) {
    i = ref[k];
    candidates.push(i % N);
  }
  candidates = _.shuffle(candidates);
  b = new Array(SIZE);
  ref1 = range(SIZE);
  results = [];
  for (l = 0, len1 = ref1.length; l < len1; l++) {
    i = ref1[l];
    b[i] = new Array(SIZE);
    results.push(function () {
      var len2, m, ref2, results1;
      ref2 = range(SIZE);
      results1 = [];
      for (m = 0, len2 = ref2.length; m < len2; m++) {
        j = ref2[m];
        if (i === 0 || i === SIZE - 1 || j === 0 || j === SIZE - 1) {
          results1.push(b[i][j] = FREE);
        } else {
          results1.push(b[i][j] = candidates.pop());
        }
      }
      return results1;
    }());
  }
  return results;
};

draw = function draw() {
  var cell, i, j, k, l, len, len1, len2, m, ref, ref1, results;
  bg(1);
  translate(TILE, TILE);
  textAlign(CENTER, CENTER);
  fc(1);
  sc(0);
  ref = range(SIZE);
  for (k = 0, len = ref.length; k < len; k++) {
    i = ref[k];
    ref1 = range(SIZE);
    for (l = 0, len1 = ref1.length; l < len1; l++) {
      j = ref1[l];
      fc(0.5);
      sc(0);
      rect(TILE * i, TILE * j, TILE, TILE);
      cell = b[i][j];
      if (cell >= 0) {
        fill(COLORS[cell]);
        sc();
        text(b[i][j], TILE * i, TILE * j);
      }
    }
  }
  text(selected, 10, SIZE * TILE);
  results = [];
  for (m = 0, len2 = selected.length; m < len2; m++) {
    var _selected$m = _slicedToArray(selected[m], 2);

    i = _selected$m[0];
    j = _selected$m[1];

    fc(1, 1, 0, 0.5);
    sc();
    results.push(circle(TILE * i, TILE * j, TILE / 2 - 3));
  }
  return results;
};

within = function within(i, j) {
  return 0 <= i && i < SIZE && 0 <= j && j < SIZE;
};

mousePressed = function mousePressed() {
  var i, i1, j, j1;
  var _ref = [Math.floor((mouseX - TILE / 2) / TILE), Math.floor((mouseY - TILE / 2) / TILE)];
  i = _ref[0];
  j = _ref[1];

  if (!within(i, j)) {
    return;
  }
  if (selected.length === 0) {
    if (b[i][j] !== FREE) {
      return selected.push([i, j]);
    }
  } else {
    var _selected$ = _slicedToArray(selected[0], 2);

    i1 = _selected$[0];
    j1 = _selected$[1];

    if (i === i1 && j === j1) {
      return selected.pop();
    }
    if (b[i][j] + b[i1][j1] === N - 1) {
      if (legal(i, j, i1, j1) || bridge(i, j, i1, j1)) {
        b[i][j] = b[i1][j1] = FREE;
        return selected.pop();
      }
    }
  }
};

// A*. This algorithm blocks itself sometimes.
// That's why bridge is also used.
legal = function legal(i0, j0, i1, j1) {
  var cands, dx, dy, front, index, index0, k, key, l, len, len1, next, reached, ref, start, turns, turns0, x, x0, y, y0;
  start = [0, i0, j0, -1];
  cands = [];
  cands.push(start);
  reached = {};
  reached[[i0, j0]] = start;
  while (cands.length > 0) {
    front = cands;
    front.sort(function (a, b) {
      return a[0] - b[0];
    });
    cands = [];
    for (k = 0, len = front.length; k < len; k++) {
      var _front$k = _slicedToArray(front[k], 4);

      turns0 = _front$k[0];
      x0 = _front$k[1];
      y0 = _front$k[2];
      index0 = _front$k[3];

      ref = [[-1, 0], [1, 0], [0, -1], [0, 1]];
      for (index = l = 0, len1 = ref.length; l < len1; index = ++l) {
        var _ref$index = _slicedToArray(ref[index], 2);

        dx = _ref$index[0];
        dy = _ref$index[1];
        x = x0 + dx;
        y = y0 + dy;

        key = [x, y];
        turns = turns0;
        if (index !== index0 && index0 !== -1) {
          turns++;
        }
        next = [turns, x, y, index];
        if (x === i1 && y === j1) {
          return 2 >= turns;
        }
        if (within(x, y)) {
          if (b[x][y] === FREE) {
            if (!(key in reached) || reached[key][0] > next[0]) {
              reached[key] = next;
              cands.push(next);
            }
          }
        }
      }
    }
  }
  return false;
};

getlst = function getlst(x0, y0, dx, dy) {
  var resx, resy, x, y;
  resx = [];
  resy = [];
  x = x0 + dx;
  y = y0 + dy;

  while (within(x, y)) {
    if (b[x][y] !== FREE) {
      return [resx, resy];
    }
    resx.push(x);
    resy.push(y);
    var _ref2 = [x + dx, y + dy];
    x = _ref2[0];
    y = _ref2[1];
  }
  return [resx, resy];
};

getrows = function getrows(x0, x1) {
  var found, k, l, len, len1, ref, ref1, res, x, y;
  res = [];
  ref = range(SIZE);
  for (k = 0, len = ref.length; k < len; k++) {
    y = ref[k];
    found = false;
    ref1 = range(x0, x1);
    for (l = 0, len1 = ref1.length; l < len1; l++) {
      x = ref1[l];
      if (b[x][y] !== FREE) {
        found = true;
      }
    }
    if (!found) {
      res.push(y);
    }
  }
  return res;
};

getcols = function getcols(y0, y1) {
  var found, k, l, len, len1, ref, ref1, res, x, y;
  res = [];
  ref = range(SIZE);
  for (k = 0, len = ref.length; k < len; k++) {
    x = ref[k];
    found = false;
    ref1 = range(y0, y1);
    for (l = 0, len1 = ref1.length; l < len1; l++) {
      y = ref1[l];
      if (b[x][y] !== FREE) {
        found = true;
      }
    }
    if (!found) {
      res.push(x);
    }
  }
  return res;
};

bridge = function bridge(x0, y0, x1, y1) {
  var lst1, lst2, lst3, lst4, lst5;
  lst1 = getlst(x0, y0, 0, -1)[1].concat(getlst(x0, y0, 0, 1)[1]);
  lst2 = getlst(x1, y1, 0, -1)[1].concat(getlst(x1, y1, 0, 1)[1]);
  lst3 = getrows(_.min([x0, x1]) + 1, _.max([x0, x1]));
  lst4 = _.intersection(lst1, lst2, lst3);
  lst1 = getlst(x0, y0, -1, 0)[0].concat(getlst(x0, y0, 1, 0)[0]);
  lst2 = getlst(x1, y1, -1, 0)[0].concat(getlst(x1, y1, 1, 0)[0]);
  lst3 = getcols(_.min([y0, y1]) + 1, _.max([y0, y1]));
  lst5 = _.intersection(lst1, lst2, lst3);
  return lst4.length > 0 || lst5.length > 0;
};
//# sourceMappingURL=sketch.js.map
