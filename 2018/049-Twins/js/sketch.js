'use strict';

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// Generated by CoffeeScript 2.0.3
var Button,
    COLORS,
    FREE,
    Hearts,
    KEY,
    SIZE,
    TILE,
    b,
    buttons,
    deathTimestamp,
    delta,
    draw,
    drawPath,
    found,
    hearts,
    legal,
    level,
    loadStorage,
    makeColors,
    makeGame,
    makeMove,
    makePath,
    maxLevel,
    message,
    milliseconds0,
    milliseconds1,
    mousePressed,
    mybrightness,
    newGame,
    numbers,
    path,
    pathTimestamp,
    saveStorage,
    selected,
    setup,
    showMoves,
    showMoves1,
    size,
    state,
    within,
    modulo = function modulo(a, b) {
  return (+a % (b = +b) + b) % b;
};

SIZE = 12;

TILE = 60;

FREE = -1;

COLORS = null;

KEY = '049-Twins';

size = null;

level = null;

maxLevel = null;

numbers = null;

b = null;

selected = [];

message = '';

buttons = [];

path = [];

pathTimestamp = null;

deathTimestamp = null;

hearts = null;

milliseconds0 = null;

milliseconds1 = null;

state = 'halted'; // 'running' 'halted'

delta = 0;

found = null;

Hearts = function () {
  function Hearts(x1, y1) {
    var count = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 9;
    var maximum = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 9;

    _classCallCheck(this, Hearts);

    this.x = x1;
    this.y = y1;
    this.count = count;
    this.maximum = maximum;
  }

  _createClass(Hearts, [{
    key: 'draw',
    value: function draw() {
      var i, l, len, ref, results, x;
      ref = range(this.maximum);
      results = [];
      for (l = 0, len = ref.length; l < len; l++) {
        i = ref[l];
        x = this.x + 60 * i;
        if (i < this.count) {
          fc(1, 0, 0);
          sc(1, 0, 0);
        } else {
          fc(0.5);
          sc(0.5);
        }
        sw(10);
        line(x - 15, this.y + 2, x, this.y + 20);
        line(x, this.y, x, this.y + 20);
        line(x + 15, this.y + 2, x, this.y + 20);
        sw(1);
        circle(x - 10, this.y, 10);
        results.push(circle(x + 10, this.y, 10));
      }
      return results;
    }
  }]);

  return Hearts;
}();

Button = function () {
  function Button(x1, y1, txt, click) {
    _classCallCheck(this, Button);

    this.x = x1;
    this.y = y1;
    this.txt = txt;
    this.click = click;
    this.r = 24;
  }

  _createClass(Button, [{
    key: 'inside',
    value: function inside(x, y) {
      return this.r > dist(this.x, this.y, x, y);
    }
  }, {
    key: 'draw',
    value: function draw() {
      fc(0.5);
      if (level === maxLevel) {
        sc(1);
      } else {
        sc();
      }
      sw(2);
      circle(this.x, this.y, this.r);
      fc(0);
      textSize(30);
      sc();
      return text(this.txt, this.x, this.y);
    }
  }]);

  return Button;
}();

newGame = function newGame(n) {
  if (n === 1 || n === maxLevel + 1) {
    return;
  }
  level = constrain(n, 2, maxLevel);
  return makeGame();
};

saveStorage = function saveStorage() {
  return localStorage[KEY] = maxLevel;
};

loadStorage = function loadStorage() {
  if (KEY in localStorage) {
    return maxLevel = parseInt(localStorage[KEY]);
  } else {
    return maxLevel = 2;
  }
};

setup = function setup() {
  createCanvas(30 + TILE * SIZE + 30, 50 + TILE * SIZE + TILE);
  rectMode(CENTER);
  makeColors();
  loadStorage();
  level = maxLevel;
  buttons.push(new Button(60, 40, '-', function () {
    return newGame(level - 1);
  }));
  buttons.push(new Button(120, 40, level, function () {
    return newGame(level);
  }));
  buttons.push(new Button(180, 40, '+', function () {
    return newGame(level + 1);
  }));
  hearts = new Hearts(240, 35);
  makeGame();
  return showMoves();
};

mybrightness = function mybrightness(s) {
  var ch, l, len, res;
  res = 0;
  for (l = 0, len = s.length; l < len; l++) {
    ch = s[l];
    res += "0123456789abcdef#".indexOf(ch);
  }
  return res;
};

makeColors = function makeColors() {
  var i, j, k, l, len, len1, len2, m, o, ref, ref1, ref2;
  COLORS = [];
  ref = "05af";
  for (l = 0, len = ref.length; l < len; l++) {
    i = ref[l];
    ref1 = "05af";
    for (m = 0, len1 = ref1.length; m < len1; m++) {
      j = ref1[m];
      ref2 = "05af";
      for (o = 0, len2 = ref2.length; o < len2; o++) {
        k = ref2[o];
        COLORS.push("#" + i + j + k);
      }
    }
  }
  COLORS = _.without(COLORS, "#000", "#005", "#00a");
  return COLORS.sort(function (a, b) {
    return mybrightness(b) - mybrightness(a);
  });
};

makeGame = function makeGame() {
  var candidates, i, j, l, len, len1, len2, m, o, ref, ref1, ref2;
  candidates = [];
  maxLevel += delta;
  level += delta;
  delta = 0;
  saveStorage();
  size = 5 + Math.floor(level / 4);
  if (size > 12) {
    size = 12;
  }
  hearts.count = size - 3;
  hearts.maximum = size - 3;
  numbers = (size - 2) * (size - 2);
  if (numbers % 2 === 1) {
    numbers -= 1;
  }
  ref = range(numbers / 2);
  for (l = 0, len = ref.length; l < len; l++) {
    i = ref[l];
    candidates.push(i % level);
    candidates.push(level - 1 - i % level);
  }
  candidates = _.shuffle(candidates);
  b = new Array(size);
  ref1 = range(size);
  for (m = 0, len1 = ref1.length; m < len1; m++) {
    i = ref1[m];
    b[i] = new Array(size);
    ref2 = range(size);
    for (o = 0, len2 = ref2.length; o < len2; o++) {
      j = ref2[o];
      if (i === 0 || i === size - 1 || j === 0 || j === size - 1) {
        b[i][j] = FREE;
      } else {
        if (size % 2 === 0) {
          b[i][j] = candidates.pop();
        } else {
          if (i === Math.floor(size / 2) && j === Math.floor(size / 2)) {
            b[i][j] = FREE;
          } else {
            b[i][j] = candidates.pop();
          }
        }
      }
    }
  }
  milliseconds0 = millis();
  return state = 'running';
};

draw = function draw() {
  var button, cell, h, i, i0, i1, j, j0, j1, l, len, len1, len2, len3, m, ms, o, p, ref, ref1, w, x, y, z;
  bg(0.25);
  sw(1);
  buttons[1].txt = level - 1;
  for (l = 0, len = buttons.length; l < len; l++) {
    button = buttons[l];
    button.draw();
  }
  hearts.draw();
  textSize(0.8 * TILE);
  translate(TILE, TILE + 50);
  textAlign(CENTER, CENTER);
  fc(1);
  sc(0);
  ref = range(size);
  for (m = 0, len1 = ref.length; m < len1; m++) {
    i = ref[m];
    ref1 = range(size);
    for (o = 0, len2 = ref1.length; o < len2; o++) {
      j = ref1[o];
      fc(0);
      sc(1);
      rect(TILE * i, TILE * j, TILE, TILE);
      cell = b[i][j];
      if (cell >= 0) {
        fill(COLORS[modulo(cell, COLORS.length)]);
        sc(0);
        text(b[i][j], TILE * i, TILE * j);
      }
    }
  }
  for (p = 0, len3 = selected.length; p < len3; p++) {
    var _selected$p = _slicedToArray(selected[p], 2);

    i = _selected$p[0];
    j = _selected$p[1];

    fc(1, 1, 0, 0.5);
    sc();
    circle(TILE * i, TILE * j, TILE / 2 - 3);
  }
  drawPath();
  if (state === 'halted') {
    fc(1, 1, 0, 0.5);
    x = Math.floor(size / 2) * TILE;
    y = Math.floor(size / 2) * TILE;
    w = size * TILE;
    h = size * TILE;
    rect(x, y, w, h);
    ms = round(milliseconds1 - milliseconds0) / 1000;
    if (ms > 0) {
      y = size * TILE;
      fc(1);
      sc();
      textSize(20);
      text(ms, x, y);
    }
  }
  if (millis() < deathTimestamp) {
    sc(1, 0, 0);
    sw(5);
    fc();
    x = Math.floor(size / 2) * TILE - TILE / 2;
    y = Math.floor(size / 2) * TILE - TILE / 2;
    w = size * TILE;
    h = size * TILE;
    rect(x, y, w, h);
  }
  var _found = found;

  var _found2 = _slicedToArray(_found, 6);

  i0 = _found2[0];
  j0 = _found2[1];
  i1 = _found2[2];
  j1 = _found2[3];
  z = _found2[4];
  z = _found2[5];

  fc();
  circle(TILE * i0, TILE * j0, TILE / 2 - 3);
  return circle(TILE * i1, TILE * j1, TILE / 2 - 3);
};

within = function within(i, j) {
  return 0 <= i && i < size && 0 <= j && j < size;
};

mousePressed = function mousePressed() {
  var button, i, i1, j, j1, l, len;
  if (state === 'halted') {
    newGame(level);
    return;
  }
  for (l = 0, len = buttons.length; l < len; l++) {
    button = buttons[l];
    if (button.inside(mouseX, mouseY)) {
      button.click();
    }
  }
  var _ref = [Math.floor((mouseX - TILE / 2) / TILE), Math.floor((mouseY - 50 - TILE / 2) / TILE)];
  i = _ref[0];
  j = _ref[1];

  if (!within(i, j)) {
    return;
  }
  if (selected.length === 0) {
    if (b[i][j] !== FREE) {
      selected.push([i, j]);
    }
  } else {
    var _selected$ = _slicedToArray(selected[0], 2);

    i1 = _selected$[0];
    j1 = _selected$[1];

    if (i === i1 && j === j1) {
      return selected.pop();
    }
    if (b[i][j] + b[i1][j1] === level - 1) {
      path = legal(false, i1, j1, i, j);
      if (path.length === 0) {
        path = legal(true, i1, j1, i, j);
        if (path.length === 0) {
          hearts.count -= 2; // Punish two, anything goes
        } else {
          hearts.count -= 1; // Punish one, wrap
        }
        deathTimestamp = 200 + millis();
      }
      b[i][j] = b[i1][j1] = FREE;
      numbers -= 2;
      selected.pop();
      if (numbers === 0) {
        milliseconds1 = millis();
        state = 'halted';
        if (level === maxLevel) {
          if (hearts.count >= 0) {
            delta = 1;
          } else {
            delta = -1;
          }
        }
      } else {
        if (level === maxLevel) {
          if (hearts.count < 0) {
            state = 'halted';
            delta = -1;
          }
        }
      }
    }
  }
  return showMoves();
};

makeMove = function makeMove(wrap, x, y) {
  if (wrap) {
    return [modulo(x, size), modulo(y, size)];
  } else {
    return [x, y];
  }
};

makePath = function makePath(wrap, reached, i, j) {
  var di, dj, i0, index, indexes0, j0, key, l, len, res, turns0;
  res = [];
  key = i + ',' + j;

  var _reached$key = _slicedToArray(reached[key], 4);

  turns0 = _reached$key[0];
  i0 = _reached$key[1];
  j0 = _reached$key[2];
  indexes0 = _reached$key[3];
  i = i0;
  j = j0;

  res.push([i, j]);
  pathTimestamp = millis();
  indexes0.reverse();
  for (l = 0, len = indexes0.length; l < len; l++) {
    index = indexes0[l];

    var _index = _slicedToArray([[1, 0], [-1, 0], [0, 1], [0, -1]][index], 2);

    di = _index[0];
    dj = _index[1];

    var _makeMove = makeMove(wrap, i + di, j + dj);

    var _makeMove2 = _slicedToArray(_makeMove, 2);

    i = _makeMove2[0];
    j = _makeMove2[1];

    res.push([i, j]);
  }
  return res;
};

drawPath = function drawPath() {
  var i1, i2, j1, j2, l, len;
  if (path.length === 0) {
    return;
  }
  sw(3);
  sc(1, 1, 0);

  var _path$ = _slicedToArray(path[0], 2);

  i1 = _path$[0];
  j1 = _path$[1];

  for (l = 0, len = path.length; l < len; l++) {
    var _path$l = _slicedToArray(path[l], 2);

    i2 = _path$l[0];
    j2 = _path$l[1];

    if (1 === dist(i1, j1, i2, j2)) {
      line(TILE * i1, TILE * j1, TILE * i2, TILE * j2);
    }
    i1 = i2;
    j1 = j2;
  }
  if (millis() > 500 + pathTimestamp) {
    return path = [];
  }
};

// A*
legal = function legal(wrap, i0, j0, i1, j1) {
  var cands, dx, dy, front, index, indexes0, key, l, len, len1, m, next, reached, ref, start, turns, turns0, x, x0, y, y0;
  start = [0, i0, j0, // turns,x,y,move
  []];
  cands = [];
  cands.push(start);
  reached = {};
  reached[[i0, j0]] = start;
  while (cands.length > 0) {
    front = cands;
    front.sort(function (a, b) {
      return a[0] - b[0];
    });
    cands = [];
    for (l = 0, len = front.length; l < len; l++) {
      var _front$l = _slicedToArray(front[l], 4);

      turns0 = _front$l[0];
      x0 = _front$l[1];
      y0 = _front$l[2];
      indexes0 = _front$l[3];

      ref = [[-1, 0], [1, 0], [0, -1], [0, 1]];
      for (index = m = 0, len1 = ref.length; m < len1; index = ++m) {
        var _ref$index = _slicedToArray(ref[index], 2);

        dx = _ref$index[0];
        dy = _ref$index[1];

        var _makeMove3 = makeMove(wrap, x0 + dx, y0 + dy);

        var _makeMove4 = _slicedToArray(_makeMove3, 2);

        x = _makeMove4[0];
        y = _makeMove4[1];

        key = x + ',' + y;
        turns = turns0;
        if (indexes0.length > 0 && index !== _.last(indexes0)) {
          turns++;
        }
        next = [turns, x, y, indexes0.concat([index])];
        if (x === i1 && y === j1 && turns <= 2) {
          reached[key] = next;
          return makePath(wrap, reached, i1, j1);
        }
        if (within(x, y)) {
          if (b[x][y] === FREE) {
            if (!(key in reached) || reached[key][0] >= next[0]) {
              if (next[0] < 3) {
                reached[key] = next;
                cands.push(next);
              }
            }
          }
        }
      }
    }
  }
  return [];
};

showMoves = function showMoves() {
  var res;
  res = showMoves1(false);
  if (res.length === 0) {
    res = showMoves1(true);
  }
  if (res.length > 0) {
    found = res[0];
  }
  return print(res);
};

showMoves1 = function showMoves1(wrap) {
  var i0, i1, j0, j1, l, len, len1, len2, len3, m, o, p, ref, ref1, ref2, ref3, res;
  res = [];
  ref = range(1, size - 1);
  for (l = 0, len = ref.length; l < len; l++) {
    i0 = ref[l];
    ref1 = range(1, size - 1);
    for (m = 0, len1 = ref1.length; m < len1; m++) {
      j0 = ref1[m];
      if (b[i0][j0] !== FREE) {
        ref2 = range(1, size - 1);
        for (o = 0, len2 = ref2.length; o < len2; o++) {
          i1 = ref2[o];
          ref3 = range(1, size - 1);
          for (p = 0, len3 = ref3.length; p < len3; p++) {
            j1 = ref3[p];
            if (b[i1][j1] !== FREE) {
              if (b[i0][j0] + b[i1][j1] === level - 1) {
                if (b[i0][j0] <= b[i1][j1] && (i0 !== i1 || j0 !== j1)) {
                  path = legal(wrap, i0, j0, i1, j1);
                  if (path.length > 0) {
                    res.push([i0, j0, i1, j1, b[i0][j0], b[i1][j1]]);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return res;
};
//# sourceMappingURL=sketch.js.map
