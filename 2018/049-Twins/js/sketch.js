'use strict';

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// Generated by CoffeeScript 2.0.3
var Button,
    COLORS,
    FREE,
    N,
    SIZE,
    TILE,
    b,
    buttons,
    draw,
    legal,
    makeColors,
    makeGame,
    makeMove,
    message,
    mousePressed,
    mybrightness,
    newGame,
    selected,
    setup,
    within,
    wrap,
    modulo = function modulo(a, b) {
  return (+a % (b = +b) + b) % b;
};

SIZE = 12;

TILE = 60;

FREE = -1;

N = 5;

b = null;

COLORS = null;

selected = [];

message = '';

buttons = [];

wrap = false;

Button = function () {
  function Button(x1, y1, txt, click) {
    _classCallCheck(this, Button);

    this.x = x1;
    this.y = y1;
    this.txt = txt;
    this.click = click;
    this.r = 50;
  }

  _createClass(Button, [{
    key: 'inside',
    value: function inside(x, y) {
      return this.r > dist(this.x, this.y, x, y);
    }
  }, {
    key: 'draw',
    value: function draw() {
      fc(0.5);
      sc();
      circle(this.x, this.y, this.r);
      fc(0);
      textSize(30);
      return text(this.txt, this.x, this.y);
    }
  }]);

  return Button;
}();

newGame = function newGame(n) {
  N = constrain(n, 2, 100);
  return makeGame();
};

setup = function setup() {
  createCanvas(30 + TILE * SIZE + 30, 100 + TILE * SIZE + TILE);
  rectMode(CENTER);
  makeColors();
  makeGame();
  buttons.push(new Button(80, 65, '-', function () {
    return newGame(N - 1);
  }));
  buttons.push(new Button(180, 65, N, function () {}));
  buttons.push(new Button(280, 65, '+', function () {
    return newGame(N + 1);
  }));
  return buttons.push(new Button(width - 80, 65, '', function () {
    return wrap = !wrap;
  }));
};

mybrightness = function mybrightness(s) {
  var ch, l, len, res;
  res = 0;
  for (l = 0, len = s.length; l < len; l++) {
    ch = s[l];
    res += "0123456789abcdef#".indexOf(ch);
  }
  return res;
};

makeColors = function makeColors() {
  var i, j, k, l, len, len1, len2, m, o, ref, ref1, ref2;
  COLORS = [];
  ref = "05af";
  for (l = 0, len = ref.length; l < len; l++) {
    i = ref[l];
    ref1 = "05af";
    for (m = 0, len1 = ref1.length; m < len1; m++) {
      j = ref1[m];
      ref2 = "05af";
      for (o = 0, len2 = ref2.length; o < len2; o++) {
        k = ref2[o];
        COLORS.push("#" + i + j + k);
      }
    }
  }
  COLORS = _.without(COLORS, "#000", "#005", "#00a");
  return COLORS.sort(function (a, b) {
    return mybrightness(b) - mybrightness(a);
  });
};

makeGame = function makeGame() {
  var candidates, i, j, l, len, len1, m, ref, ref1, results;
  candidates = [];
  ref = range(50);
  for (l = 0, len = ref.length; l < len; l++) {
    i = ref[l];
    candidates.push(i % N);
    candidates.push(N - 1 - i % N);
  }
  candidates = _.shuffle(candidates);
  b = new Array(SIZE);
  ref1 = range(SIZE);
  results = [];
  for (m = 0, len1 = ref1.length; m < len1; m++) {
    i = ref1[m];
    b[i] = new Array(SIZE);
    results.push(function () {
      var len2, o, ref2, results1;
      ref2 = range(SIZE);
      results1 = [];
      for (o = 0, len2 = ref2.length; o < len2; o++) {
        j = ref2[o];
        if (i === 0 || i === SIZE - 1 || j === 0 || j === SIZE - 1) {
          results1.push(b[i][j] = FREE);
        } else {
          results1.push(b[i][j] = candidates.pop());
        }
      }
      return results1;
    }());
  }
  return results;
};

draw = function draw() {
  var button, cell, i, j, l, len, len1, len2, len3, m, o, q, ref, ref1, results;
  bg(0.25);
  buttons[1].txt = N - 1;
  buttons[3].txt = wrap ? 'wrap' : 'nowrap';
  for (l = 0, len = buttons.length; l < len; l++) {
    button = buttons[l];
    button.draw();
  }
  textSize(0.8 * TILE);
  translate(TILE, TILE + 100);
  textAlign(CENTER, CENTER);
  fc(1);
  sc(0);
  ref = range(SIZE);
  for (m = 0, len1 = ref.length; m < len1; m++) {
    i = ref[m];
    ref1 = range(SIZE);
    for (o = 0, len2 = ref1.length; o < len2; o++) {
      j = ref1[o];
      fc(0);
      sc(1);
      rect(TILE * i, TILE * j, TILE, TILE);
      cell = b[i][j];
      if (cell >= 0) {
        fill(COLORS[modulo(cell, COLORS.length)]);
        sc();
        text(b[i][j], TILE * i, TILE * j);
      }
    }
  }
  results = [];
  for (q = 0, len3 = selected.length; q < len3; q++) {
    var _selected$q = _slicedToArray(selected[q], 2);

    i = _selected$q[0];
    j = _selected$q[1];

    fc(1, 1, 0, 0.5);
    sc();
    results.push(circle(TILE * i, TILE * j, TILE / 2 - 3));
  }
  return results;
};

within = function within(i, j) {
  return 0 <= i && i < SIZE && 0 <= j && j < SIZE;
};

mousePressed = function mousePressed() {
  var button, i, i1, j, j1, l, len;
  for (l = 0, len = buttons.length; l < len; l++) {
    button = buttons[l];
    if (button.inside(mouseX, mouseY)) {
      button.click();
    }
  }
  var _ref = [Math.floor((mouseX - TILE / 2) / TILE), Math.floor((mouseY - 100 - TILE / 2) / TILE)];
  i = _ref[0];
  j = _ref[1];

  if (!within(i, j)) {
    return;
  }
  if (selected.length === 0) {
    if (b[i][j] !== FREE) {
      return selected.push([i, j]);
    }
  } else {
    var _selected$ = _slicedToArray(selected[0], 2);

    i1 = _selected$[0];
    j1 = _selected$[1];

    if (i === i1 && j === j1) {
      return selected.pop();
    }
    if (b[i][j] + b[i1][j1] === N - 1) {
      if (legal(i1, j1, i, j) || legal(i, j, i1, j1)) {
        // or bridge(i,j,i1,j1)
        b[i][j] = b[i1][j1] = FREE;
        return selected.pop();
      }
    }
  }
};

makeMove = function makeMove(x, y) {
  if (wrap) {
    return [modulo(x, SIZE), modulo(y, SIZE)];
  } else {
    return [x, y];
  }
};

// A*
legal = function legal(i0, j0, i1, j1) {
  var cands, dx, dy, front, index, index0, key, l, len, len1, m, next, p, reached, ref, start, turns, turns0, x, x0, y, y0;
  start = [0, i0, j0, -1 // turns,x,y,move
  ];
  cands = [];
  cands.push(start);
  reached = {};
  reached[[i0, j0]] = start;
  while (cands.length > 0) {
    front = cands;
    front.sort(function (a, b) {
      return a[0] - b[0];
    });
    cands = [];
    for (l = 0, len = front.length; l < len; l++) {
      var _front$l = _slicedToArray(front[l], 4);

      turns0 = _front$l[0];
      x0 = _front$l[1];
      y0 = _front$l[2];
      index0 = _front$l[3];

      ref = [[-1, 0], [1, 0], [0, -1], [0, 1]];
      for (index = m = 0, len1 = ref.length; m < len1; index = ++m) {
        p = ref[index];
        var _p = p;

        var _p2 = _slicedToArray(_p, 2);

        dx = _p2[0];
        dy = _p2[1];

        var _makeMove = makeMove(x0 + dx, y0 + dy);

        var _makeMove2 = _slicedToArray(_makeMove, 2);

        x = _makeMove2[0];
        y = _makeMove2[1];

        key = x + ',' + y;
        turns = turns0;
        if (index !== index0 && index0 !== -1) {
          turns++;
        }
        next = [turns, x, y, index];
        if (x === i1 && y === j1) {
          return 2 >= turns;
        }
        if (within(x, y)) {
          if (b[x][y] === FREE) {
            if (!(key in reached) || reached[key][0] > next[0]) {
              if (next[0] < 3) {
                reached[key] = next;
                cands.push(next);
              }
            }
          }
        }
      }
    }
  }
  return false;
};

// getlst = (x0,y0,dx,dy) ->
// 	resx = []
// 	resy = []
// 	[x,y] = makeMove x0+dx,y0+dy 
// 	while within x,y
// 		if b[x][y] != FREE then return [resx,resy]
// 		resx.push x
// 		resy.push y
// 		[x,y] = makeMove x+dx,y+dy 
// 	[resx,resy]

// getrows = (x0,x1) ->
// 	res = []
// 	for y in range SIZE
// 		found = false 
// 		for x in range x0,x1 
// 			if b[x][y] != FREE then found = true 
// 		if not found then res.push y
// 	res

// getcols = (y0,y1) ->
// 	res = []
// 	for x in range SIZE
// 		found = false 
// 		for y in range y0,y1 
// 			if b[x][y] != FREE then found = true 
// 		if not found then res.push x
// 	res

// bridge = (x0,y0,x1,y1) ->
// 	lst1 = getlst(x0,y0,0,-1)[1].concat getlst(x0,y0,0,1)[1]
// 	lst2 = getlst(x1,y1,0,-1)[1].concat getlst(x1,y1,0,1)[1]
// 	lst3 = getrows _.min([x0,x1])+1,_.max([x0,x1])
// 	lst4 = _.intersection lst1, lst2, lst3 

// 	lst1 = getlst(x0,y0,-1,0)[0].concat getlst(x0,y0,1,0)[0]
// 	lst2 = getlst(x1,y1,-1,0)[0].concat getlst(x1,y1,1,0)[0]
// 	lst3 = getcols _.min([y0,y1])+1,_.max([y0,y1])
// 	lst5 = _.intersection lst1, lst2, lst3 

// 	lst4.length > 0 or lst5.length > 0
//# sourceMappingURL=sketch.js.map
