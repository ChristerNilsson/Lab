'use strict';

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// Generated by CoffeeScript 2.0.3
var Button,
    COLORS,
    FREE,
    Hearts,
    KEY,
    SIZE,
    TILE,
    b,
    buttons,
    draw,
    drawPath,
    hearts,
    legal,
    level,
    loadStorage,
    makeColors,
    makeGame,
    makeMove,
    makePath,
    maxLevel,
    message,
    mousePressed,
    mybrightness,
    newGame,
    numbers,
    path,
    pathTimestamp,
    saveStorage,
    selected,
    setup,
    within,
    modulo = function modulo(a, b) {
  return (+a % (b = +b) + b) % b;
};

SIZE = 12;

TILE = 60;

FREE = -1;

COLORS = null;

KEY = '049-Twins';

level = null;

maxLevel = null;

numbers = null;

b = null;

selected = [];

message = '';

buttons = [];

path = [];

pathTimestamp = null;

hearts = null;

Hearts = function () {
  function Hearts(x1, y1) {
    var count = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 9;
    var maximum = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 9;

    _classCallCheck(this, Hearts);

    this.x = x1;
    this.y = y1;
    this.count = count;
    this.maximum = maximum;
  }

  _createClass(Hearts, [{
    key: 'draw',
    value: function draw() {
      var i, l, len, ref, results, x;
      ref = range(this.maximum);
      results = [];
      for (l = 0, len = ref.length; l < len; l++) {
        i = ref[l];
        x = this.x + 25 * i;
        if (i < this.count) {
          fc(1, 0, 0);
        } else {
          fc(0.5);
        }
        triangle(x - 11, this.y, x + 11, this.y, x, this.y + 15);
        circle(x - 5, this.y, 5);
        results.push(circle(x + 5, this.y, 5));
      }
      return results;
    }
  }]);

  return Hearts;
}();

Button = function () {
  function Button(x1, y1, txt, click) {
    _classCallCheck(this, Button);

    this.x = x1;
    this.y = y1;
    this.txt = txt;
    this.click = click;
    this.r = 50;
  }

  _createClass(Button, [{
    key: 'inside',
    value: function inside(x, y) {
      return this.r > dist(this.x, this.y, x, y);
    }
  }, {
    key: 'draw',
    value: function draw() {
      fc(0.5);
      sc();
      circle(this.x, this.y, this.r);
      fc(0);
      textSize(30);
      return text(this.txt, this.x, this.y);
    }
  }]);

  return Button;
}();

newGame = function newGame(n) {
  level = constrain(n, 2, maxLevel);
  return makeGame();
};

saveStorage = function saveStorage() {
  return localStorage[KEY] = maxLevel;
};

loadStorage = function loadStorage() {
  if (KEY in localStorage) {
    maxLevel = parseInt(localStorage[KEY]);
    return print(maxLevel);
  } else {
    return maxLevel = 2;
  }
};

setup = function setup() {
  createCanvas(30 + TILE * SIZE + 30, 100 + TILE * SIZE + TILE);
  rectMode(CENTER);
  makeColors();
  loadStorage();
  level = maxLevel;
  buttons.push(new Button(80, 65, '-', function () {
    return newGame(level - 1);
  }));
  buttons.push(new Button(180, 65, level, function () {
    return newGame(level);
  }));
  buttons.push(new Button(280, 65, '+', function () {
    return newGame(level + 1);
  }));
  hearts = new Hearts(width - 240, 110);
  return makeGame();
};

//assert true,  setBoard 41,true,2,5,9,8,["","",""," 25"," 22 35 21       7"," 11 10 15","          5","  19 18   29","   33      30"]
//assert false, setBoard 41,true,2,5,3,8,["","",""," 25"," 22 35 21       7"," 11 10 15","          5","  19 18   29","   33      30"]
//assert false, setBoard 21,false,2,8,6,8,["","    17","","","        11","  7","     4   7","  5    7  15 10","  17   5 3 18 16 2 12","       8 13 15 9","  10  3    13 13"]
//assert true,  setBoard 21,false,2,2,7,2,["","        20  5"," 18 1  17   19 16","  4 9 10  14 15 3","     9"]
mybrightness = function mybrightness(s) {
  var ch, l, len, res;
  res = 0;
  for (l = 0, len = s.length; l < len; l++) {
    ch = s[l];
    res += "0123456789abcdef#".indexOf(ch);
  }
  return res;
};

makeColors = function makeColors() {
  var i, j, k, l, len, len1, len2, m, o, ref, ref1, ref2;
  COLORS = [];
  ref = "05af";
  for (l = 0, len = ref.length; l < len; l++) {
    i = ref[l];
    ref1 = "05af";
    for (m = 0, len1 = ref1.length; m < len1; m++) {
      j = ref1[m];
      ref2 = "05af";
      for (o = 0, len2 = ref2.length; o < len2; o++) {
        k = ref2[o];
        COLORS.push("#" + i + j + k);
      }
    }
  }
  COLORS = _.without(COLORS, "#000", "#005", "#00a");
  return COLORS.sort(function (a, b) {
    return mybrightness(b) - mybrightness(a);
  });
};

makeGame = function makeGame() {
  var candidates, i, j, l, len, len1, m, ref, ref1, results;
  candidates = [];
  hearts.count = 9;
  numbers = 100;
  ref = range(50);
  for (l = 0, len = ref.length; l < len; l++) {
    i = ref[l];
    candidates.push(i % level);
    candidates.push(level - 1 - i % level);
  }
  candidates = _.shuffle(candidates);
  b = new Array(SIZE);
  ref1 = range(SIZE);
  results = [];
  for (m = 0, len1 = ref1.length; m < len1; m++) {
    i = ref1[m];
    b[i] = new Array(SIZE);
    results.push(function () {
      var len2, o, ref2, results1;
      ref2 = range(SIZE);
      results1 = [];
      for (o = 0, len2 = ref2.length; o < len2; o++) {
        j = ref2[o];
        if (i === 0 || i === SIZE - 1 || j === 0 || j === SIZE - 1) {
          results1.push(b[i][j] = FREE);
        } else {
          results1.push(b[i][j] = candidates.pop());
        }
      }
      return results1;
    }());
  }
  return results;
};

draw = function draw() {
  var button, cell, i, j, l, len, len1, len2, len3, m, o, p, ref, ref1;
  bg(0.25);
  sw(1);
  buttons[1].txt = level - 1;
  for (l = 0, len = buttons.length; l < len; l++) {
    button = buttons[l];
    button.draw();
  }
  hearts.draw();
  textSize(0.8 * TILE);
  translate(TILE, TILE + 100);
  textAlign(CENTER, CENTER);
  fc(1);
  sc(0);
  ref = range(SIZE);
  for (m = 0, len1 = ref.length; m < len1; m++) {
    i = ref[m];
    ref1 = range(SIZE);
    for (o = 0, len2 = ref1.length; o < len2; o++) {
      j = ref1[o];
      fc(0);
      sc(1);
      rect(TILE * i, TILE * j, TILE, TILE);
      cell = b[i][j];
      if (cell >= 0) {
        fill(COLORS[modulo(cell, COLORS.length)]);
        sc();
        text(b[i][j], TILE * i, TILE * j);
      }
    }
  }
  for (p = 0, len3 = selected.length; p < len3; p++) {
    var _selected$p = _slicedToArray(selected[p], 2);

    i = _selected$p[0];
    j = _selected$p[1];

    fc(1, 1, 0, 0.5);
    sc();
    circle(TILE * i, TILE * j, TILE / 2 - 3);
  }
  return drawPath();
};

within = function within(i, j) {
  return 0 <= i && i < SIZE && 0 <= j && j < SIZE;
};

mousePressed = function mousePressed() {
  var button, i, i1, j, j1, l, len;
  for (l = 0, len = buttons.length; l < len; l++) {
    button = buttons[l];
    if (button.inside(mouseX, mouseY)) {
      button.click();
    }
  }
  var _ref = [Math.floor((mouseX - TILE / 2) / TILE), Math.floor((mouseY - 100 - TILE / 2) / TILE)];
  i = _ref[0];
  j = _ref[1];

  if (!within(i, j)) {
    return;
  }
  if (selected.length === 0) {
    if (b[i][j] !== FREE) {
      return selected.push([i, j]);
    }
  } else {
    var _selected$ = _slicedToArray(selected[0], 2);

    i1 = _selected$[0];
    j1 = _selected$[1];

    if (i === i1 && j === j1) {
      return selected.pop();
    }
    if (b[i][j] + b[i1][j1] === level - 1) {
      path = legal(false, i1, j1, i, j);
      if (path.length === 0) {
        path = legal(true, i1, j1, i, j);
        if (path.length === 0) {
          hearts.count -= 2; // Punish two
        } else {
          hearts.count -= 1; // Punish one
        }
      }
      b[i][j] = b[i1][j1] = FREE;
      numbers -= 2;
      selected.pop();
      if (numbers === 0) {
        if (level === maxLevel) {
          if (hearts.count >= 0) {
            maxLevel += 1;
            level += 1;
          } else {
            maxLevel -= 1;
            level -= 1;
          }
        }
        saveStorage();
        return newGame(level);
      } else {
        if (level === maxLevel) {
          if (hearts.count < 0) {
            maxLevel -= 1;
            level -= 1;
            saveStorage();
            return newGame(level);
          }
        }
      }
    }
  }
};

makeMove = function makeMove(wrap, x, y) {
  if (wrap) {
    return [modulo(x, SIZE), modulo(y, SIZE)];
  } else {
    return [x, y];
  }
};

makePath = function makePath(wrap, reached, i, j) {
  var di, dj, i0, index, indexes0, j0, key, l, len, res, turns0;
  res = [];
  key = i + ',' + j;

  var _reached$key = _slicedToArray(reached[key], 4);

  turns0 = _reached$key[0];
  i0 = _reached$key[1];
  j0 = _reached$key[2];
  indexes0 = _reached$key[3];
  i = i0;
  j = j0;

  res.push([i, j]);
  pathTimestamp = millis();
  indexes0.reverse();
  for (l = 0, len = indexes0.length; l < len; l++) {
    index = indexes0[l];

    var _index = _slicedToArray([[1, 0], [-1, 0], [0, 1], [0, -1]][index], 2);

    di = _index[0];
    dj = _index[1];

    var _makeMove = makeMove(wrap, i + di, j + dj);

    var _makeMove2 = _slicedToArray(_makeMove, 2);

    i = _makeMove2[0];
    j = _makeMove2[1];

    res.push([i, j]);
  }
  return res;
};

drawPath = function drawPath() {
  var i1, i2, j1, j2, l, len;
  if (path.length === 0) {
    return;
  }
  sw(3);
  sc(1, 1, 0);

  var _path$ = _slicedToArray(path[0], 2);

  i1 = _path$[0];
  j1 = _path$[1];

  for (l = 0, len = path.length; l < len; l++) {
    var _path$l = _slicedToArray(path[l], 2);

    i2 = _path$l[0];
    j2 = _path$l[1];

    if (1 === dist(i1, j1, i2, j2)) {
      line(TILE * i1, TILE * j1, TILE * i2, TILE * j2);
    }
    i1 = i2;
    j1 = j2;
  }
  if (millis() > 1000 + pathTimestamp) {
    return path = [];
  }
};

// A*
legal = function legal(wrap, i0, j0, i1, j1) {
  var cands, dx, dy, front, index, indexes0, key, l, len, len1, m, next, reached, ref, start, turns, turns0, x, x0, y, y0;
  start = [0, i0, j0, // turns,x,y,move
  []];
  cands = [];
  cands.push(start);
  reached = {};
  reached[[i0, j0]] = start;
  while (cands.length > 0) {
    front = cands;
    front.sort(function (a, b) {
      return a[0] - b[0];
    });
    cands = [];
    for (l = 0, len = front.length; l < len; l++) {
      var _front$l = _slicedToArray(front[l], 4);

      turns0 = _front$l[0];
      x0 = _front$l[1];
      y0 = _front$l[2];
      indexes0 = _front$l[3];

      ref = [[-1, 0], [1, 0], [0, -1], [0, 1]];
      for (index = m = 0, len1 = ref.length; m < len1; index = ++m) {
        var _ref$index = _slicedToArray(ref[index], 2);

        dx = _ref$index[0];
        dy = _ref$index[1];

        var _makeMove3 = makeMove(wrap, x0 + dx, y0 + dy);

        var _makeMove4 = _slicedToArray(_makeMove3, 2);

        x = _makeMove4[0];
        y = _makeMove4[1];

        key = x + ',' + y;
        turns = turns0;
        if (indexes0.length > 0 && index !== _.last(indexes0)) {
          turns++;
        }
        next = [turns, x, y, indexes0.concat([index])];
        if (x === i1 && y === j1 && turns <= 2) {
          reached[key] = next;
          return makePath(wrap, reached, i1, j1);
        }
        if (within(x, y)) {
          if (b[x][y] === FREE) {
            if (!(key in reached) || reached[key][0] >= next[0]) {
              if (next[0] < 3) {
                reached[key] = next;
                cands.push(next);
              }
            }
          }
        }
      }
    }
  }
  return [];
};

// setBoard = (n,w,i0,j0,i1,j1,arr) ->
// 	level = n
// 	for j in range SIZE
// 		b[j] = [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1]
// 	for row,j in arr
// 		for cell,i in row.split ' '
// 			b[i][j] = if cell=='' then -1 else parseInt cell
// 	legal i0,j0,i1,j1
//# sourceMappingURL=sketch.js.map
