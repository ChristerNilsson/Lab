'use strict';

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// Generated by CoffeeScript 2.0.3
var Button,
    COLORS,
    FREE,
    N,
    SIZE,
    TILE,
    b,
    buttons,
    draw,
    drawPath,
    legal,
    makeColors,
    makeGame,
    makeMove,
    makePath,
    message,
    mousePressed,
    mybrightness,
    newGame,
    path,
    pathTimestamp,
    selected,
    setBoard,
    setup,
    within,
    wrap,
    wrapCount,
    modulo = function modulo(a, b) {
  return (+a % (b = +b) + b) % b;
};

SIZE = 12;

TILE = 60;

FREE = -1;

N = 5;

b = null;

COLORS = null;

selected = [];

message = '';

buttons = [];

wrap = false;

wrapCount = 0;

path = [];

pathTimestamp = null;

Button = function () {
  function Button(x3, y3, txt, click) {
    _classCallCheck(this, Button);

    this.x = x3;
    this.y = y3;
    this.txt = txt;
    this.click = click;
    this.r = 50;
  }

  _createClass(Button, [{
    key: 'inside',
    value: function inside(x, y) {
      return this.r > dist(this.x, this.y, x, y);
    }
  }, {
    key: 'draw',
    value: function draw() {
      fc(0.5);
      sc();
      circle(this.x, this.y, this.r);
      fc(0);
      textSize(30);
      return text(this.txt, this.x, this.y);
    }
  }]);

  return Button;
}();

newGame = function newGame(n) {
  N = constrain(n, 2, 100);
  wrapCount = 0;
  return makeGame();
};

setup = function setup() {
  createCanvas(30 + TILE * SIZE + 30, 100 + TILE * SIZE + TILE);
  rectMode(CENTER);
  makeColors();
  buttons.push(new Button(80, 65, '-', function () {
    return newGame(N - 1);
  }));
  buttons.push(new Button(180, 65, N, function () {
    return newGame(N);
  }));
  buttons.push(new Button(280, 65, '+', function () {
    return newGame(N + 1);
  }));
  buttons.push(new Button(width - 80, 65, '', function () {
    return wrap = !wrap;
  }));
  return makeGame();
};

//assert true,  setBoard 41,true,2,5,9,8,["","",""," 25"," 22 35 21       7"," 11 10 15","          5","  19 18   29","   33      30"]
//assert false, setBoard 41,true,2,5,3,8,["","",""," 25"," 22 35 21       7"," 11 10 15","          5","  19 18   29","   33      30"]
//assert false,  setBoard 21,false,2,8,6,8,["","    17","","","        11","  7","     4   7","  5    7  15 10","  17   5 3 18 16 2 12","       8 13 15 9","  10  3    13 13"]
//assert true,  setBoard 21,false,2,2,7,2,["","        20  5"," 18 1  17   19 16","  4 9 10  14 15 3","     9"]
mybrightness = function mybrightness(s) {
  var ch, l, len, res;
  res = 0;
  for (l = 0, len = s.length; l < len; l++) {
    ch = s[l];
    res += "0123456789abcdef#".indexOf(ch);
  }
  return res;
};

makeColors = function makeColors() {
  var i, j, k, l, len, len1, len2, m, o, ref, ref1, ref2;
  COLORS = [];
  ref = "05af";
  for (l = 0, len = ref.length; l < len; l++) {
    i = ref[l];
    ref1 = "05af";
    for (m = 0, len1 = ref1.length; m < len1; m++) {
      j = ref1[m];
      ref2 = "05af";
      for (o = 0, len2 = ref2.length; o < len2; o++) {
        k = ref2[o];
        COLORS.push("#" + i + j + k);
      }
    }
  }
  COLORS = _.without(COLORS, "#000", "#005", "#00a");
  return COLORS.sort(function (a, b) {
    return mybrightness(b) - mybrightness(a);
  });
};

makeGame = function makeGame() {
  var candidates, i, j, l, len, len1, m, ref, ref1, results;
  candidates = [];
  ref = range(50);
  for (l = 0, len = ref.length; l < len; l++) {
    i = ref[l];
    candidates.push(i % N);
    candidates.push(N - 1 - i % N);
  }
  candidates = _.shuffle(candidates);
  b = new Array(SIZE);
  ref1 = range(SIZE);
  results = [];
  for (m = 0, len1 = ref1.length; m < len1; m++) {
    i = ref1[m];
    b[i] = new Array(SIZE);
    results.push(function () {
      var len2, o, ref2, results1;
      ref2 = range(SIZE);
      results1 = [];
      for (o = 0, len2 = ref2.length; o < len2; o++) {
        j = ref2[o];
        if (i === 0 || i === SIZE - 1 || j === 0 || j === SIZE - 1) {
          results1.push(b[i][j] = FREE);
        } else {
          results1.push(b[i][j] = candidates.pop());
        }
      }
      return results1;
    }());
  }
  return results;
};

draw = function draw() {
  var button, cell, i, j, l, len, len1, len2, len3, m, o, p, ref, ref1;
  bg(0.25);
  sw(1);
  buttons[1].txt = N - 1;
  buttons[3].txt = wrap ? 'wrap' : wrapCount;
  for (l = 0, len = buttons.length; l < len; l++) {
    button = buttons[l];
    button.draw();
  }
  textSize(0.8 * TILE);
  translate(TILE, TILE + 100);
  textAlign(CENTER, CENTER);
  fc(1);
  sc(0);
  ref = range(SIZE);
  for (m = 0, len1 = ref.length; m < len1; m++) {
    i = ref[m];
    ref1 = range(SIZE);
    for (o = 0, len2 = ref1.length; o < len2; o++) {
      j = ref1[o];
      fc(0);
      sc(1);
      rect(TILE * i, TILE * j, TILE, TILE);
      cell = b[i][j];
      if (cell >= 0) {
        fill(COLORS[modulo(cell, COLORS.length)]);
        sc();
        text(b[i][j], TILE * i, TILE * j);
      }
    }
  }
  for (p = 0, len3 = selected.length; p < len3; p++) {
    var _selected$p = _slicedToArray(selected[p], 2);

    i = _selected$p[0];
    j = _selected$p[1];

    fc(1, 1, 0, 0.5);
    sc();
    circle(TILE * i, TILE * j, TILE / 2 - 3);
  }
  return drawPath();
};

within = function within(i, j) {
  return 0 <= i && i < SIZE && 0 <= j && j < SIZE;
};

mousePressed = function mousePressed() {
  var button, i, i1, j, j1, l, len;
  for (l = 0, len = buttons.length; l < len; l++) {
    button = buttons[l];
    if (button.inside(mouseX, mouseY)) {
      button.click();
    }
  }
  var _ref = [Math.floor((mouseX - TILE / 2) / TILE), Math.floor((mouseY - 100 - TILE / 2) / TILE)];
  i = _ref[0];
  j = _ref[1];

  if (!within(i, j)) {
    return;
  }
  if (selected.length === 0) {
    if (b[i][j] !== FREE) {
      return selected.push([i, j]);
    }
  } else {
    var _selected$ = _slicedToArray(selected[0], 2);

    i1 = _selected$[0];
    j1 = _selected$[1];

    if (i === i1 && j === j1) {
      return selected.pop();
    }
    if (b[i][j] + b[i1][j1] === N - 1) {
      path = legal(i1, j1, i, j);
      if (path.length > 0) {
        // or legal(i,j,i1,j1) # legal misses some targets
        b[i][j] = b[i1][j1] = FREE;
        if (wrap) {
          wrapCount++;
        }
        wrap = false;
        return selected.pop();
      }
    }
  }
};

makeMove = function makeMove(x, y) {
  if (wrap) {
    return [modulo(x, SIZE), modulo(y, SIZE)];
  } else {
    return [x, y];
  }
};

makePath = function makePath(reached, i, j) {
  var count, di, dj, i0, index0, j0, key, res, turns0;
  res = [];
  print(reached, i, j);
  count = 0;
  while (count < 50) {
    count++;
    key = i + ',' + j;

    var _reached$key = _slicedToArray(reached[key], 4);

    turns0 = _reached$key[0];
    i0 = _reached$key[1];
    j0 = _reached$key[2];
    index0 = _reached$key[3];

    print([turns0, i0, j0, index0]);
    if (index0 === -1) {
      res.push(reached[key]);
      pathTimestamp = millis();
      print(res);
      return res;
    }

    var _index = _slicedToArray([[1, 0], [-1, 0], [0, 1], [0, -1]][index0], 2);

    di = _index[0];
    dj = _index[1];

    var _makeMove = makeMove(i0 + di, j0 + dj);

    var _makeMove2 = _slicedToArray(_makeMove, 2);

    i = _makeMove2[0];
    j = _makeMove2[1];

    res.push(reached[key]);
  }
  return res;
};

drawPath = function drawPath() {
  var i1, i2, j1, j2, l, len, x1, x2, y1, y2, z;
  if (path.length === 0) {
    return;
  }
  sw(3);

  var _path$ = _slicedToArray(path[0], 4);

  z = _path$[0];
  i1 = _path$[1];
  j1 = _path$[2];
  z = _path$[3];

  x1 = TILE * i1;
  y1 = TILE * j1;
  for (l = 0, len = path.length; l < len; l++) {
    var _path$l = _slicedToArray(path[l], 4);

    z = _path$l[0];
    i2 = _path$l[1];
    j2 = _path$l[2];
    z = _path$l[3];

    x2 = TILE * i2;
    y2 = TILE * j2;
    if (TILE === dist(x1, y1, x2, y2)) {
      line(x1, y1, x2, y2);
    }
    //		else
    // if y1==y2
    // 	line 1,y1,x2,y2
    // 	line x1,y1,10,y2
    // else
    // 	line x1,1,x2,y2
    // 	line x1,y1,x2,10
    x1 = x2;
    y1 = y2;
  }
  if (millis() > 200 + pathTimestamp) {
    return path = [];
  }
};

// A*
legal = function legal(i0, j0, i1, j1) {
  var cands, dx, dy, front, index, index0, key, l, len, len1, m, next, reached, ref, start, turns, turns0, x, x0, y, y0;
  start = [0, i0, j0, -1 // turns,x,y,move
  ];
  cands = [];
  cands.push(start);
  reached = {};
  reached[[i0, j0]] = start;
  //print "#####"
  while (cands.length > 0) {
    //print front
    front = cands;
    front.sort(function (a, b) {
      return a[0] - b[0];
    });
    cands = [];
    for (l = 0, len = front.length; l < len; l++) {
      var _front$l = _slicedToArray(front[l], 4);

      turns0 = _front$l[0];
      x0 = _front$l[1];
      y0 = _front$l[2];
      index0 = _front$l[3];

      ref = [[-1, 0], [1, 0], [0, -1], [0, 1]];
      //print '------',x0,y0
      for (index = m = 0, len1 = ref.length; m < len1; index = ++m) {
        var _ref$index = _slicedToArray(ref[index], 2);

        dx = _ref$index[0];
        dy = _ref$index[1];

        var _makeMove3 = makeMove(x0 + dx, y0 + dy);

        var _makeMove4 = _slicedToArray(_makeMove3, 2);

        x = _makeMove4[0];
        y = _makeMove4[1];

        key = x + ',' + y;
        turns = turns0;
        if (index !== index0 && index0 !== -1) {
          turns++;
        }
        next = [turns, x, y, index];
        //print next
        if (x === i1 && y === j1 && turns <= 2) {
          reached[key] = next;
          return makePath(reached, i1, j1);
        }
        if (within(x, y)) {
          if (b[x][y] === FREE) {
            if (!(key in reached) || reached[key][0] >= next[0]) {
              if (next[0] < 3) {
                reached[key] = next;
                cands.push(next);
              }
            }
          }
        }
      }
    }
  }
  return [];
};

setBoard = function setBoard(n, w, i0, j0, i1, j1, arr) {
  var cell, i, j, l, len, len1, len2, m, o, ref, ref1, row;
  N = n;
  wrap = w;
  ref = range(SIZE);
  for (l = 0, len = ref.length; l < len; l++) {
    j = ref[l];
    b[j] = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1];
  }
  for (j = m = 0, len1 = arr.length; m < len1; j = ++m) {
    row = arr[j];
    ref1 = row.split(' ');
    for (i = o = 0, len2 = ref1.length; o < len2; i = ++o) {
      cell = ref1[i];
      b[i][j] = cell === '' ? -1 : parseInt(cell);
    }
  }
  //print b
  return legal(i0, j0, i1, j1);
};

// getlst = (x0,y0,dx,dy) ->
// 	resx = []
// 	resy = []
// 	[x,y] = makeMove x0+dx,y0+dy 
// 	while within x,y
// 		if b[x][y] != FREE then return [resx,resy]
// 		resx.push x
// 		resy.push y
// 		[x,y] = makeMove x+dx,y+dy 
// 	[resx,resy]

// getrows = (x0,x1) ->
// 	res = []
// 	for y in range SIZE
// 		found = false 
// 		for x in range x0,x1 
// 			if b[x][y] != FREE then found = true 
// 		if not found then res.push y
// 	res

// getcols = (y0,y1) ->
// 	res = []
// 	for x in range SIZE
// 		found = false 
// 		for y in range y0,y1 
// 			if b[x][y] != FREE then found = true 
// 		if not found then res.push x
// 	res

// bridge = (x0,y0,x1,y1) ->
// 	lst1 = getlst(x0,y0,0,-1)[1].concat getlst(x0,y0,0,1)[1]
// 	lst2 = getlst(x1,y1,0,-1)[1].concat getlst(x1,y1,0,1)[1]
// 	lst3 = getrows _.min([x0,x1])+1,_.max([x0,x1])
// 	lst4 = _.intersection lst1, lst2, lst3 

// 	lst1 = getlst(x0,y0,-1,0)[0].concat getlst(x0,y0,1,0)[0]
// 	lst2 = getlst(x1,y1,-1,0)[0].concat getlst(x1,y1,1,0)[0]
// 	lst3 = getcols _.min([y0,y1])+1,_.max([y0,y1])
// 	lst5 = _.intersection lst1, lst2, lst3 

// 	lst4.length > 0 or lst5.length > 0
//# sourceMappingURL=sketch.js.map
