"use strict";

// Generated by CoffeeScript 2.0.3
var createProblem,
    createRests,
    indexOf = [].indexOf;

createRests = function createRests(ticks, path) {
  var i, j, k, lastp, len, len1, p, rests, t;
  rests = function () {
    var j, len, results;
    results = [];
    for (j = 0, len = ticks.length; j < len; j++) {
      t = ticks[j];
      results.push(0);
    }
    return results;
  }();
  lastp = 0;
  path.reverse();
  for (j = 0, len = path.length; j < len; j++) {
    p = path[j];
    for (i = k = 0, len1 = ticks.length; k < len1; i = ++k) {
      t = ticks[i];
      rests[i] = (rests[i] + p - lastp) % t;
    }
    lastp = p;
  }
  path.reverse();
  return rests;
};

createProblem = function createProblem(steps) {
  var cand, cands, item, j, k, l, len, len1, len2, nextcand, nextcands, path, primes, ref, rests, result, step, ticks, total, tree;
  primes = [2, 3, 5, 7, 11, 13, 17, 19];
  ticks = _.sample(primes, 1 + Math.floor(steps / 5));
  ticks.sort(function (a, b) {
    return a - b;
  });
  ticks.unshift(1);
  tree = {};
  cands = [0];
  ref = range(steps);
  for (j = 0, len = ref.length; j < len; j++) {
    step = ref[j];
    nextcands = [];
    for (k = 0, len1 = cands.length; k < len1; k++) {
      cand = cands[k];
      for (l = 0, len2 = ticks.length; l < len2; l++) {
        item = ticks[l];
        nextcand = cand + item;
        if (indexOf.call(nextcands, nextcand) < 0) {
          if (!(nextcand in tree)) {
            tree[nextcand] = cand;
            nextcands.push(nextcand);
          }
        }
      }
    }
    cands = nextcands;
  }
  path = [];
  total = _.sample(cands);
  while (total > 0) {
    path.push(total);
    total = tree[total];
  }
  rests = createRests(ticks, path);
  result = {
    rests: rests,
    ticks: ticks,
    total: path[0],
    steps: path.length,
    path: path
  };
  //restSum : rests.reduce (a,b) -> a+b 
  return result;
};

// crt = (n,a) ->
// 	sum = 0
// 	prod = n.reduce (a,c) -> a*c
// 	for [ni,ai] in _.zip n,a
// 		p = prod // ni
// 		sum += ai * p * mulInv p,ni
// 	sum % prod

// mulInv = (a,b) ->
// 	b0 = b
// 	[x0,x1] = [0,1]
// 	if b==1 then return 1
// 	while a > 1
// 		q = a // b
// 		[a,b] = [b, a % b]
// 		[x0,x1] = [x1-q*x0, x0]
// 	if x1 < 0 then x1 += b0
// 	x1

// breadth first search for smallest total
// search = (n,a,total) ->
// 	tree = {}
// 	cands = [0]
// 	ready = false
// 	while not ready 
// 		nextcands = []
// 		for cand in cands
// 			for item in n
// 				nextcand = cand+item
// 				if nextcand not in nextcands
// 					if nextcand not of tree 
// 						tree[nextcand] = cand 
// 					nextcands.push nextcand
// 				if nextcand == total then ready = true  
// 		cands = nextcands 
// 	res = {1:0,7:0,13:0,17:0}
// 	lasttotal = total
// 	while total>0
// 		total = tree[total]
// 		res[lasttotal-total]++
// 		lasttotal = total
// 	res
//# sourceMappingURL=utils.js.map
