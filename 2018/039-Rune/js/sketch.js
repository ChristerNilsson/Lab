'use strict';

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

// Generated by CoffeeScript 2.0.3
var c, contains, dist, group, halfCircle, i, inside, k, len, r, ref, stagepos, x, y;

halfCircle = function halfCircle(x0, y0, radius, cr, cg, cb, group) {
  var k, len, p, ref, v, x, y;
  p = r.polygon(x0, y0, group);
  p.fill(cr, cg, cb);
  ref = range(0, 190, 10);
  for (k = 0, len = ref.length; k < len; k++) {
    v = ref[k];
    x = radius * Math.cos(Rune.radians(v));
    y = radius * Math.sin(Rune.radians(v));
    p.lineTo(x, y);
  }
  return p;
};

group = null;

r = new Rune({
  container: "body",
  width: 600,
  height: 600
});

group = r.group(300, 300);

c = r.circle(0, 0, 200, group);

c.fill(0, 255, 0);

ref = range(4);
for (k = 0, len = ref.length; k < len; k++) {
  i = ref[k];
  x = 200 * Math.cos(Rune.radians(90 * i));
  y = 200 * Math.sin(Rune.radians(90 * i));
  halfCircle(x, y, -50, 255, 255, 0, group);
  halfCircle(x, y, +50, 255, 0, 0, group);
}

dist = function dist(x1, y1, x2, y2) {
  var dx, dy;
  dx = x1 - x2;
  dy = y1 - y2;
  return Math.sqrt(dx * dx + dy * dy);
};

r.on('update', function () {
  var child, l, len1, ref1, results, rotation;
  var _group$state = group.state;
  x = _group$state.x;
  y = _group$state.y;
  rotation = _group$state.rotation;

  group.rotate(rotation + 0.1, x, y);
  ref1 = group.children;
  results = [];
  for (i = l = 0, len1 = ref1.length; l < len1; i = ++l) {
    child = ref1[i];
    if (i > 0) {
      var _child$state = child.state;
      x = _child$state.x;
      y = _child$state.y;
      rotation = _child$state.rotation;

      results.push(child.rotate(rotation - 0.2, x, y));
    } else {
      results.push(void 0);
    }
  }
  return results;
});

stagepos = function stagepos(child) {
  // returns resulting [pos, rotation]
  var current, l, len1, lst, rot, rotation, rotres, v1, v2, vec;
  lst = [];
  current = child;
  while (current) {
    lst.unshift(current.state);
    current = current.parent;
  }
  vec = new Rune.Vector(0, 0);
  rot = 0;
  rotres = 0;
  for (l = 0, len1 = lst.length; l < len1; l++) {
    var _lst$l = lst[l];
    x = _lst$l.x;
    y = _lst$l.y;
    rotation = _lst$l.rotation;

    rotres += rotation;
    v1 = new Rune.Vector(x, y);
    v2 = v1.rotate(rot);
    rot = rotation;
    vec = vec.add(v2);
  }
  return [vec, rotres];
};

inside = function inside(v, vs) {
  var intersect, j, l, len1, lst, res, xi, xj, yi, yj;
  res = false;
  lst = range(vs.length);
  lst.unshift(lst.pop());
  for (i = l = 0, len1 = lst.length; l < len1; i = ++l) {
    j = lst[i];
    xi = vs[i].x;
    yi = vs[i].y;
    xj = vs[j].x;
    yj = vs[j].y;
    intersect = yi > v.y !== yj > v.y && v.x < (xj - xi) * (v.y - yi) / (yj - yi) + xi;
    if (intersect) {
      res = !res;
    }
  }
  return res;
};

contains = function contains(child, m) {
  var p2, p3, p4, rotation;

  var _stagepos = stagepos(child);

  var _stagepos2 = _slicedToArray(_stagepos, 2);

  p2 = _stagepos2[0];
  rotation = _stagepos2[1];

  p3 = m.sub(p2);
  p4 = p3.rotate(-rotation);
  return inside(p4, child.state.vectors);
};

r.el.addEventListener('mousemove', function (mouse) {
  var child, l, len1, m, ref1, results;
  m = new Rune.Vector(mouse.x, mouse.y);
  ref1 = group.children;
  results = [];
  for (i = l = 0, len1 = ref1.length; l < len1; i = ++l) {
    child = ref1[i];
    if (i > 0) {
      results.push(child.fill(contains(child, m) ? 0 : 255));
    } else {
      results.push(void 0);
    }
  }
  return results;
});

r.play();
//# sourceMappingURL=sketch.js.map
