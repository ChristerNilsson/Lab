'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

// Generated by CoffeeScript 2.0.3
var assert, bg, bsort, circle, _compare, fc, fixColor, getParameters, merp, nilsson_version, print, range, rd, sc, sw;

nilsson_version = "1.5"; // getParameters with 0 parameters fixed 


// chai visar listinnehåll på ett bra sätt. 
// _.isEqual(a,b) fungerar också men det blir sämre listutskrifter
assert = function assert(a, b) {
  var msg = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'Assert failure';

  return chai.assert.deepEqual(a, b, msg);
};

fixColor = function fixColor(args) {
  var a, b, g, n, r;
  n = args.length;
  a = 1;
  if (n === 1) {
    var _ref = [args[0], args[0], args[0]];
    r = _ref[0];
    g = _ref[1];
    b = _ref[2];
  }
  if (n === 2) {
    var _ref2 = [args[0], args[0], args[0], args[1]];
    r = _ref2[0];
    g = _ref2[1];
    b = _ref2[2];
    a = _ref2[3];
  }
  if (n === 3) {
    var _args = _slicedToArray(args, 3);

    r = _args[0];
    g = _args[1];
    b = _args[2];
  }
  if (n === 4) {
    var _args2 = _slicedToArray(args, 4);

    r = _args2[0];
    g = _args2[1];
    b = _args2[2];
    a = _args2[3];
  }
  return color(255 * r, 255 * g, 255 * b, 255 * a);
};

fc = function fc() {
  if (arguments.length === 0) {
    return noFill();
  } else {
    return fill(fixColor(arguments));
  }
};

sc = function sc() {
  if (arguments.length === 0) {
    return noStroke();
  } else {
    return stroke(fixColor(arguments));
  }
};

bg = function bg() {
  return background(fixColor(arguments));
};

sw = function sw(n) {
  return strokeWeight(n);
};

circle = function circle(x, y, r) {
  return ellipse(x, y, 2 * r, 2 * r);
};

rd = function rd(degrees) {
  return rotate(radians(degrees));
};

print = console.log;

range = _.range; // from underscore.coffee

merp = function merp(y1, y2, i) {
  var x1 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
  var x2 = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;

  return map(i, x1, x2, y1, y2);
};

getParameters = function getParameters() {
  var h = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window.location.href;

  var arr, f, s;
  arr = h.split('?');
  if (arr.length !== 2) {
    return {};
  }
  s = arr[1];
  if (s === '') {
    return {};
  }
  return _.object(function () {
    var k, len, ref, results;
    ref = s.split('&');
    results = [];
    for (k = 0, len = ref.length; k < len; k++) {
      f = ref[k];
      results.push(f.split('='));
    }
    return results;
  }());
};

assert(getParameters('http:\\christernilsson.github.io\Shortcut\www'), {});

assert(getParameters('http:\\christernilsson.github.io\Shortcut\www?'), {});

assert(getParameters('http:\\christernilsson.github.io\Shortcut\www?a=0&b=1'), {
  'a': '0',
  'b': '1'
});

_compare = function compare(a, b) {
  var c, i, k, len, ref;
  if ((typeof a === 'undefined' ? 'undefined' : _typeof(a)) === "object" && (typeof b === 'undefined' ? 'undefined' : _typeof(b)) === "object") {
    ref = range(Math.min(a.length, b.length));
    for (k = 0, len = ref.length; k < len; k++) {
      i = ref[k];
      c = _compare(a[i], b[i]);
      if (c !== 0) {
        return c;
      }
    }
  } else {
    return a > b ? -1 : a < b ? 1 : 0;
  }
  return 0;
};

assert(_compare(12, 13), 1);

assert(_compare(12, 12), 0);

assert(_compare(13, 12), -1);

assert(_compare([1, 11], [1, 2]), -1);

assert(_compare([1, 11], [1, 11]), 0);

assert(_compare([1, 2], [1, 11]), 1);

assert(_compare([1, '11'], [1, '2']), 1);

assert(_compare([1, '11'], [1, '11']), 0);

assert(_compare([1, '2'], [1, '11']), -1);

bsort = function bsort(list) {
  var cmp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _compare;

  var i, j, k, l, len, len1, ref, ref1;
  ref = range(list.length);
  for (k = 0, len = ref.length; k < len; k++) {
    i = ref[k];
    ref1 = range(list.length - 1);
    for (l = 0, len1 = ref1.length; l < len1; l++) {
      j = ref1[l];
      if (cmp(list[j], list[j + 1]) < 0) {
        var _ref3 = [list[j + 1], list[j]];
        list[j] = _ref3[0];
        list[j + 1] = _ref3[1];
      }
    }
  }
  return list;
};

assert(bsort([1, 8, 2], _compare), [1, 2, 8]);

assert(bsort([1, 8, 2], _compare), [1, 2, 8]);

assert(bsort([[1], [8], [2]], _compare), [[1], [2], [8]]);

assert(bsort([[2, 1], [2, 8], [2, 2]], _compare), [[2, 1], [2, 2], [2, 8]]);

assert(bsort([[1, 8], [1, 7], [1, 9]], _compare), [[1, 7], [1, 8], [1, 9]]);

assert(bsort([3, 2, 4, 1], _compare), [1, 2, 3, 4]);
//# sourceMappingURL=nilsson.js.map
