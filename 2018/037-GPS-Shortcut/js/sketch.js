'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// Generated by CoffeeScript 2.0.3
var Button, LAT, LNG, RADIUS, Rmeter, a, b, buttons, count, dh, draw, dw, hist, locationUpdate, locationUpdateFail, mousePressed, mouseReleased, position, radius, released, rmeter, setup, start, steps, stopp, track, wgs84ToXY;

released = true;

position = {
  x: 0,
  y: 0 // home
};

// inparametrar
Rmeter = 100; // stora radien i meter

rmeter = 30; // lilla radien meter

RADIUS = null; // stora radien i pixlar

radius = null; // lilla radien i pixlar

// level
// seed
LAT = 59.265205; // SkarpnÃ¤ck

LNG = 18.132735;

buttons = [];

hist = [];

track = [];

a = 8;

b = 9;

count = 0;

steps = 3;

start = null;

stopp = null;

dw = null;

dh = null;

Button = function () {
  function Button(x1, y1, radius1, txt1) {
    var r1 = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0.5;
    var g1 = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0.5;
    var b1 = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0.5;

    _classCallCheck(this, Button);

    this.x = x1;
    this.y = y1;
    this.radius = radius1;
    this.txt = txt1;
    this.r = r1;
    this.g = g1;
    this.b = b1;
  }

  _createClass(Button, [{
    key: 'draw',
    value: function draw() {
      if (this.radius > dist(position.x, position.y, this.x, this.y)) {
        fc(1, 1, 0, 0.5);
      } else {
        fc(1, 1, 1, 0.5);
      }
      if (stopp != null) {
        fc(0, 1, 0);
      }
      sc(0);
      if (this.radius > 0) {
        circle(this.x, this.y, this.radius);
      }
      fc(this.r, this.g, this.b);
      sc();
      return text(this.txt, this.x, this.y);
    }
  }, {
    key: 'execute',
    value: function execute() {
      if (this.radius > dist(position.x, position.y, this.x, this.y)) {
        this.event();
        if (a === b) {
          return stopp = millis();
        }
      }
    }
  }, {
    key: 'spara',
    value: function spara(value) {
      count++;
      hist.push(a);
      a = value;
      buttons[3].txt = steps - count;
      return buttons[4].txt = a;
    }
  }, {
    key: 'setColor',
    value: function setColor(r, g, b) {
      var _ref;

      return _ref = [r, g, b], this.r = _ref[0], this.g = _ref[1], this.b = _ref[2], _ref;
    }
  }]);

  return Button;
}();

locationUpdate = function locationUpdate(p) {
  var p1;
  p1 = {
    lat: p.coords.latitude,
    lng: p.coords.longitude,
    timestamp: p.timestamp // milliseconds since 1970
  };
  position = wgs84ToXY(p1);
  track.push(position);
  if (track.length > 10) {
    return track.shift();
  }
};

locationUpdateFail = function locationUpdateFail(error) {};

wgs84ToXY = function wgs84ToXY(p) {
  var timestamp, x, y;
  x = map(p.lng, LNG - dw / 2, LNG + dw / 2, 0, width);
  y = map(p.lat, LAT - dh / 2, LAT + dh / 2, 0, height);
  timestamp = p.timestamp;
  return { x: x, y: y, timestamp: timestamp };
};

setup = function setup() {
  var i, j, k, labels, len, len1, meterPerPixlar, n, p0, p1, p2, p3, p4, ref, results, txt, x, y;
  createCanvas(800, 800); // windowWidth,windowHeight
  // dx = 0.01/(1136.6/width) # meter per grad Stockholm
  // dy = 0.01/(2223.9/height) # meter per grad Stockholm
  //dh = height/113660 # grader vertikalt Stockholm
  //dw = width/222390 # grader horisontellt Stockholm
  dh = height / 222390; // grader vertikalt Stockholm
  dw = width / 113660; // grader horisontellt Stockholm
  meterPerPixlar = 2 * (rmeter + Rmeter) / Math.min(width, height);
  RADIUS = Rmeter / meterPerPixlar;
  radius = 0.3 * RADIUS;
  print(RADIUS, radius);
  print(dw, dh);
  print('meterPerPixlar', meterPerPixlar);
  p0 = {
    lat: LAT,
    lng: LNG,
    timestamp: 0
  };
  p1 = {
    lat: LAT - dh / 2,
    lng: LNG - dw / 2,
    timestamp: 0
  };
  p2 = {
    lat: LAT - dh / 2,
    lng: LNG + dw / 2,
    timestamp: 0
  };
  p3 = {
    lat: LAT + dh / 2,
    lng: LNG - dw / 2,
    timestamp: 0
  };
  p4 = {
    lat: LAT + dh / 2,
    lng: LNG + dw / 2,
    timestamp: 0
  };
  print(wgs84ToXY(p0));
  print(wgs84ToXY(p1));
  print(wgs84ToXY(p2));
  print(wgs84ToXY(p3));
  print(wgs84ToXY(p4));
  navigator.geolocation.watchPosition(locationUpdate, locationUpdateFail, {
    enableHighAccuracy: true,
    maximumAge: 30000,
    timeout: 27000
  });
  start = millis();
  angleMode(DEGREES);
  textAlign(CENTER, CENTER);
  textSize(1 * radius);
  labels = "+2 *2 /2".split(' ');
  n = labels.length;
  for (i = j = 0, len = labels.length; j < len; i = ++j) {
    txt = labels[i];
    x = width / 2 + RADIUS * cos(i * 360 / n); // -90
    y = height / 2 + RADIUS * sin(i * 360 / n); // -90
    buttons.push(new Button(x, y, radius, txt));
  }
  buttons.push(new Button(width / 2, height / 2, radius, steps));
  buttons[0].event = function () {
    return this.spara(a + 2);
  };
  buttons[1].event = function () {
    return this.spara(a * 2);
  };
  buttons[2].event = function () {
    if (a % 2 === 0) {
      return this.spara(Math.floor(a / 2));
    }
  };
  buttons[3].event = function () {
    if (hist.length > 0) {
      a = hist.pop();
      return buttons[4].txt = a;
    }
  };
  buttons.push(new Button(100, 100, -radius, a));
  buttons.push(new Button(width - 100, 100, -radius, b));
  buttons[4].setColor(0, 0, 0);
  buttons[5].setColor(0, 0, 0);
  buttons.push(new Button(120, height - radius, -radius, 'time'));
  buttons.push(new Button(width - 120, height - radius, -radius, 'count'));
  buttons[6].setColor(0, 0, 0);
  buttons[7].setColor(0, 0, 0);
  ref = range(3);
  results = [];
  for (k = 0, len1 = ref.length; k < len1; k++) {
    i = ref[k];
    results.push(print('dist', dist(400, 400, buttons[i].x, buttons[i].y)));
  }
  return results;
};

draw = function draw() {
  var button, i, j, k, len, len1, p;
  bg(0.5);
  fc();
  circle(width / 2, height / 2, RADIUS);
  for (j = 0, len = buttons.length; j < len; j++) {
    button = buttons[j];
    button.draw();
  }
  if (stopp != null) {
    buttons[6].txt = round(stopp - start) / 1000;
    buttons[7].txt = count;
  }
  fc();
  sc(0);
  sw(1);
  for (i = k = 0, len1 = track.length; k < len1; i = ++k) {
    p = track[i];
    circle(p.x, p.y, 1 + 2 * (10 - i));
  }
  fc(1, 0, 0);
  return text(position.x + ', ' + position.y, 0.5 * width, 0.35 * height);
};

mouseReleased = function mouseReleased() {
  // to make Android work
  released = true;
  return false;
};

mousePressed = function mousePressed() {
  var button, j, len, results;
  if (!released) {
    // to make Android work
    return;
  }
  released = false;
  if (stopp != null) {
    return;
  }
  results = [];
  for (j = 0, len = buttons.length; j < len; j++) {
    button = buttons[j];
    results.push(button.execute());
  }
  return results;
};
//# sourceMappingURL=sketch.js.map
