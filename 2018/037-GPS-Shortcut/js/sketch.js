'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// Generated by CoffeeScript 2.0.3
var Button, LAT, LON, RADIUS, Rmeter, SCALE, System, TRACKED, a, b, buttons, count, dh, draw, dw, hist, locationUpdate, locationUpdateFail, mousePressed, mouseReleased, position, radius, released, setup, start, steps, stopp, system, track;

released = true;

system = null;

position = {
  x: 0,
  y: 0 // home
};

SCALE = null;

// inparametrar
Rmeter = 50; // stora radien i meter

//rmeter = 30 # lilla radien meter
RADIUS = null; // stora radien i pixlar

radius = null; // lilla radien i pixlar

// level
// seed
TRACKED = 5;

LAT = 59.265205; // SkarpnÃ¤ck

LON = 18.132735;

buttons = [];

hist = [];

track = [];

a = 8;

b = 9;

count = 0;

steps = 3;

start = null;

stopp = null;

dw = null;

dh = null;

System = function () {
  function System(lat1, lon1, w, h) {
    _classCallCheck(this, System);

    var p0, p1, p2, p3, p4;
    this.lat = lat1;
    this.lon = lon1;
    this.w = w;
    this.h = h;
    p0 = LatLon(this.lat, this.lon);
    p1 = p0.destinationPoint(this.h / 2, 0);
    this.lat2 = p1.lat;
    p2 = p0.destinationPoint(this.w / 2, 90);
    this.lon2 = p2.lon;
    p3 = p0.destinationPoint(this.h / 2, 180);
    this.lat1 = p3.lat;
    p4 = p0.destinationPoint(this.w / 2, 270);
    this.lon1 = p4.lon;
  }

  _createClass(System, [{
    key: 'toXY',
    value: function toXY(lat, lon) {
      var x, y;
      x = round(map(lon, this.lon1, this.lon2, -this.w / 2, this.w / 2));
      y = round(map(lat, this.lat2, this.lat1, -this.h / 2, this.h / 2)); // turned
      return { x: x, y: y };
    }
  }, {
    key: 'toWGS84',
    value: function toWGS84(x, y) {
      var lat, lon;
      lon = map(x, -this.w / 2, this.w / 2, this.lon1, this.lon2);
      lat = map(y, -this.h / 2, this.h / 2, this.lat1, this.lat2);
      return { lat: lat, lon: lon };
    }
  }]);

  return System;
}();

Button = function () {
  function Button(x1, y1, radius1, txt1) {
    var r1 = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0.5;
    var g1 = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0.5;
    var b1 = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0.5;

    _classCallCheck(this, Button);

    this.x = x1;
    this.y = y1;
    this.radius = radius1;
    this.txt = txt1;
    this.r = r1;
    this.g = g1;
    this.b = b1;
  }

  _createClass(Button, [{
    key: 'draw',
    value: function draw() {
      if (this.inside()) {
        fc(1, 1, 0, 0.5);
      } else {
        fc(1, 1, 1, 0.5);
      }
      if (stopp != null) {
        fc(0, 1, 0);
      }
      sc();
      if (this.radius > 0) {
        circle(this.x, this.y, this.radius);
      }
      fc(this.r, this.g, this.b);
      //sc()
      return text(this.txt, this.x, this.y);
    }
  }, {
    key: 'execute',
    value: function execute() {
      if (this.inside()) {
        this.event();
        if (a === b) {
          return stopp = millis();
        }
      }
    }
  }, {
    key: 'inside',
    value: function inside() {
      return this.radius > dist(position.x, position.y, this.x, this.y);
    }
  }, {
    key: 'setColor',
    value: function setColor(r, g, b) {
      var _ref;

      return _ref = [r, g, b], this.r = _ref[0], this.g = _ref[1], this.b = _ref[2], _ref;
    }
  }, {
    key: 'spara',
    value: function spara(value) {
      count++;
      hist.push(a);
      a = value;
      buttons[3 + 1].txt = steps - count;
      return buttons[4 + 1].txt = a;
    }
  }]);

  return Button;
}();

locationUpdate = function locationUpdate(p) {
  var lat, lon;
  lat = p.coords.latitude;
  lon = p.coords.longitude;
  position = system.toXY(lat, lon);
  track.push(position);
  if (track.length > TRACKED) {
    return track.shift();
  }
};

locationUpdateFail = function locationUpdateFail(error) {};

setup = function setup() {
  var hs, i, j, labels, len, n, rs, txt, ws, x, y;
  createCanvas(windowWidth, windowHeight);
  system = new System(LAT, LON, width, height);
  //assert {x: 0, y: -0}, system.toXY LAT,LON
  //assert {lat: 59.26160771357633, lon: 18.125696195929095}, system.toWGS84 0,0
  RADIUS = Rmeter;
  SCALE = min(width, height) / RADIUS / 3;
  radius = 0.3 * RADIUS;
  navigator.geolocation.watchPosition(locationUpdate, locationUpdateFail, {
    enableHighAccuracy: true,
    maximumAge: 30000,
    timeout: 27000
  });
  start = millis();
  angleMode(DEGREES);
  textAlign(CENTER, CENTER);
  textSize(1 * radius);
  labels = "+2 *2 /2 +3".split(' ');
  n = labels.length;
  for (i = j = 0, len = labels.length; j < len; i = ++j) {
    txt = labels[i];
    x = RADIUS * cos(i * 360 / n);
    y = RADIUS * sin(i * 360 / n);
    buttons.push(new Button(x, y, radius, txt));
  }
  buttons[0].event = function () {
    return this.spara(a + 2);
  };
  buttons[1].event = function () {
    return this.spara(a * 2);
  };
  buttons[2].event = function () {
    if (a % 2 === 0) {
      return this.spara(Math.floor(a / 2));
    }
  };
  buttons[3].event = function () {
    return this.spara(a + 3);
  };
  buttons.push(new Button(0, 0, radius, steps));
  buttons[3 + 1].event = function () {
    if (hist.length > 0) {
      a = hist.pop();
      return buttons[4 + 1].txt = a;
    }
  };
  ws = 0.35 * width / SCALE;
  hs = 0.4 * height / SCALE;
  rs = radius / SCALE;
  buttons.push(new Button(-ws, -hs, -rs, a));
  buttons.push(new Button(ws, -hs, -rs, b));
  buttons[4 + 1].setColor(1, 0, 0);
  buttons[5 + 1].setColor(0, 1, 0);
  buttons.push(new Button(-ws, hs, -rs, '0'));
  buttons.push(new Button(ws, hs, -rs, '0'));
  buttons[6 + 1].setColor(0, 0, 0);
  return buttons[7 + 1].setColor(0, 0, 0);
};

draw = function draw() {
  var button, i, j, k, len, len1, p, results;
  translate(width / 2, height / 2);
  scale(SCALE);
  bg(0.5);
  fc();
  sc(0);
  circle(0, 0, RADIUS);
  if (stopp != null) {
    buttons[6 + 1].txt = round(stopp - start) / 1000;
  } else {
    buttons[6 + 1].txt = round((millis() - start) / 1000);
  }
  buttons[7 + 1].txt = count;
  for (j = 0, len = buttons.length; j < len; j++) {
    button = buttons[j];
    button.draw();
  }
  fc();
  sc(1, 1, 0);
  sw(1);
  results = [];
  for (i = k = 0, len1 = track.length; k < len1; i = ++k) {
    p = track[i];
    results.push(circle(p.x, p.y, 2 * (track.length - i)));
  }
  return results;
};

//fc 1,0,0
//text "#{position.x}, #{position.y}",0,-0.5*RADIUS
mouseReleased = function mouseReleased() {
  // to make Android work
  released = true;
  return false;
};

mousePressed = function mousePressed() {
  var button, j, len, results;
  if (!released) {
    // to make Android work
    return;
  }
  released = false;
  if (stopp != null) {
    return;
  }
  results = [];
  for (j = 0, len = buttons.length; j < len; j++) {
    button = buttons[j];
    results.push(button.execute());
  }
  return results;
};
//# sourceMappingURL=sketch.js.map
