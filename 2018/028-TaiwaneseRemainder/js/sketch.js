"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// Generated by CoffeeScript 2.0.3
// Man sparar till localStorage bara de problem man själv löst.
// Problem via url sparas ej.
var BLACK,
    Button,
    Clock,
    DELAY,
    GREEN,
    N,
    RED,
    WHITE,
    buttons,
    clocks,
    draw,
    game,
    info,
    mousePressed,
    newGame,
    newGame1,
    ok,
    okidoki,
    reset,
    setup,
    solution,
    solutionTimer,
    indexOf = [].indexOf,
    modulo = function modulo(a, b) {
  return (+a % (b = +b) + b) % b;
};

buttons = [];

clocks = [];

game = {};

N = 60;

RED = "#F00";

GREEN = "#0F0";

BLACK = "#000";

WHITE = "#FFF";

DELAY = 60; // seconds per step before Solution is available

solutionTimer = null;

solution = "";

reset = function reset() {
  var clock, k, len, results;
  game.totalSteps = 0;
  game.totalPoints = 0;
  results = [];
  for (k = 0, len = clocks.length; k < len; k++) {
    clock = clocks[k];
    results.push(clock.reset());
  }
  return results;
};

ok = function ok() {
  if (this.enabled) {
    if (game.steps === game.totalSteps && game.totalPoints === game.total) {
      newGame(1);
    }
    if (game.steps === game.totalSteps) {
      return newGame(1);
    } else {
      return newGame(-1);
    }
  }
};

setup = function setup() {
  var params, r;
  createCanvas(1200, 590);
  angleMode(DEGREES);
  textAlign(CENTER, CENTER);
  buttons.push(new Button('Steps:', 120, 60, 48));
  buttons.push(new Button('reset', 120, 170, 48, reset));
  buttons.push(new Button('ok', 120, 280, 48, ok));
  buttons.push(new Button('All clocks green', 120, 360, 24));
  buttons.push(new Button('Use all steps', 120, 390, 24));
  buttons.push(new Button('Share via clipboard', 120, 450, 24, function () {
    copyToClipboard(game.url);
    return this.enabled = false;
  }));
  buttons.push(new Button('Taiwanese Remainder', 120, 20, 20));
  buttons.push(new Button('Solution', 120, 540, 20, function () {
    if (this.enabled) {
      solution = game.solution.join(' ');
      this.enabled = false;
      return solutionTimer = millis();
    }
  }));
  buttons.push(new Button('Combinations', 120, 510, 20));
  buttons.push(new Button('Level', 120, 480, 20));
  buttons[5].enabled = true;
  if (indexOf.call(window.location.href, '?') >= 0) {
    params = getParameters();
    if (3 === _.size(params)) {
      game = {
        level: parseInt(params.level),
        ticks: function () {
          var k, len, ref, results;
          ref = params.ticks.split(',');
          results = [];
          for (k = 0, len = ref.length; k < len; k++) {
            r = ref[k];
            results.push(parseInt(r));
          }
          return results;
        }(),
        rests: function () {
          var k, len, ref, results;
          ref = params.rests.split(',');
          results = [];
          for (k = 0, len = ref.length; k < len; k++) {
            r = ref[k];
            results.push(parseInt(r));
          }
          return results;
        }(),
        url: window.location.href
      };
      newGame1();
    }
  } else if (localStorage['TaiwaneseRemainder']) {
    game = JSON.parse(localStorage['TaiwaneseRemainder']);
    return newGame1();
  } else {
    game = {
      level: 0
    };
    return newGame(0);
  }
};

Button = function () {
  function Button(txt, x, y, size) {
    var f = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : function () {};

    _classCallCheck(this, Button);

    this.txt = txt;
    this.x = x;
    this.y = y;
    this.size = size;
    this.f = f;
    this.enabled = false;
  }

  _createClass(Button, [{
    key: "draw",
    value: function draw() {
      fill(this.enabled ? WHITE : BLACK);
      sc();
      textSize(this.size);
      return text(this.txt, this.x, this.y);
    }
  }]);

  return Button;
}();

Clock = function () {
  function Clock(rest, tick1, x, y) {
    _classCallCheck(this, Clock);

    this.rest = rest;
    this.tick = tick1;
    this.x = x;
    this.y = y;
    this.reset();
  }

  _createClass(Clock, [{
    key: "reset",
    value: function reset() {
      this.count = 0;
      this.value = modulo(-this.rest, this.tick);
      this.oldValue = this.value;
      this.delta = 0;
      return this.n = N;
    }
  }, {
    key: "draw",
    value: function draw() {
      var j, k, len, ref, twelve;
      push();
      translate(this.x, this.y);
      sw(4);
      twelve = game.totalPoints % this.tick === this.rest;
      fill(twelve ? GREEN : RED);
      stroke(BLACK);
      circle(0, 0, 50);
      fill(twelve ? BLACK : WHITE);
      sw(1);
      sc();
      textAlign(CENTER, CENTER);
      textSize(40);
      text(this.tick, 0, 0);
      if (this.tick > 30) {
        textSize(20);
        text(this.rest, 0, 30);
      }
      // subtract
      if (this.count > 0) {
        fill(this.count > 0 ? WHITE : BLACK);
        sc();
        textSize(40);
        text(this.count, 80, 0);
      }
      if (this.n < N) {
        this.n++;
      }
      rotate(-90 + this.n * this.delta / N * 360 / this.tick);
      stroke(WHITE);
      ref = range(this.tick);
      for (k = 0, len = ref.length; k < len; k++) {
        j = ref[k];
        sw(2);
        point(50, 0);
        sw(2);
        if (j === this.oldValue) {
          line(25, 0, 46, 0);
        }
        rotate(360 / this.tick);
      }
      return pop();
    }
  }, {
    key: "add",
    value: function add(delta) {
      this.delta = delta;
      this.oldValue = this.value;
      this.value = modulo(this.value + delta, this.tick);
      return this.n = 0;
    }
  }, {
    key: "move",
    value: function move(step) {
      var clock, k, len, results, tick;
      if (this.count + step < 0) {
        return;
      }
      buttons[5].enabled = true;
      tick = step * this.tick;
      game.totalPoints += tick;
      game.totalSteps += step;
      this.count += step;
      results = [];
      for (k = 0, len = clocks.length; k < len; k++) {
        clock = clocks[k];
        results.push(clock.add(tick));
      }
      return results;
    }
  }]);

  return Clock;
}();

okidoki = function okidoki() {
  return true;
};

//if game.totalSteps != game.steps then return false 
//for clock in clocks
//	if game.totalPoints % clock.tick != clock.rest then return false
newGame = function newGame(delta) {
  game.level += delta;
  if (game.level < 0) {
    game.level = 0;
  }
  N = int(map(game.level, 0, 100, 60, 10));
  game = createProblem(game.level);
  if (indexOf.call(window.location.href, '?') < 0) {
    localStorage['TaiwaneseRemainder'] = JSON.stringify(game);
  }
  return newGame1();
};

newGame1 = function newGame1() {
  var C, clock, i, k, len, ref;
  game.steps = game.level % 5 + Math.floor(game.level / 5) + 1;
  game.combinations = combinations(game.steps, game.ticks.length);
  print(game.steps + ", [" + game.ticks + "], [" + game.rests + "]");
  reset();
  clocks = [];
  C = 5;
  ref = range(game.ticks.length);
  for (k = 0, len = ref.length; k < len; k++) {
    i = ref[k];
    clock = new Clock(game.rests[i], game.ticks[i], 300 + 200 * Math.floor(i / C), 60 + 110 * (i % C));
    clocks.push(clock);
    clock.forward = function () {
      return this.move(1);
    };
    clock.backward = function () {
      return this.move(-1);
    };
  }
  solutionTimer = millis();
  return solution = '';
};

info = function info() {
  var button, k, len, results;
  buttons[0].txt = 'steps: ' + (game.steps - game.totalSteps);
  buttons[1].enabled = game.totalSteps > 0;
  buttons[2].enabled = okidoki();
  buttons[8].txt = 'Combinations: ' + short(combinations(game.steps, game.ticks.length));
  buttons[9].txt = 'Level: ' + game.level;
  results = [];
  for (k = 0, len = buttons.length; k < len; k++) {
    button = buttons[k];
    results.push(button.draw());
  }
  return results;
};

draw = function draw() {
  var clock, k, len;
  bg(0.5);
  info();
  for (k = 0, len = clocks.length; k < len; k++) {
    clock = clocks[k];
    clock.draw();
  }
  buttons[7].enabled = millis() > solutionTimer + DELAY * 1000 * game.steps;
  fc(0);
  return text(solution, width / 2, buttons[7].y + 30);
};

mousePressed = function mousePressed() {
  var b, c, k, l, len, len1, results;
  for (k = 0, len = buttons.length; k < len; k++) {
    b = buttons[k];
    if (50 > dist(mouseX, mouseY, b.x, b.y)) {
      b.f();
    }
  }
  results = [];
  for (l = 0, len1 = clocks.length; l < len1; l++) {
    c = clocks[l];
    if (50 > dist(mouseX, mouseY, c.x, c.y)) {
      c.forward();
    }
    if (50 > dist(mouseX, mouseY, c.x + 100, c.y)) {
      results.push(c.backward());
    } else {
      results.push(void 0);
    }
  }
  return results;
};
//# sourceMappingURL=sketch.js.map
