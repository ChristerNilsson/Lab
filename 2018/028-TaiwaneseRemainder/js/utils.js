'use strict';

// Generated by CoffeeScript 2.0.3
var PRIMES, combinations, copyToClipboard, createProblem, createRests, _fac, short, solve;

PRIMES = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113 //,131,137,139,149,151,157,163,167,173]
];

createRests = function createRests(ticks, total) {
  var l, len, results, t;
  results = [];
  for (l = 0, len = ticks.length; l < len; l++) {
    t = ticks[l];
    results.push(total % t);
  }
  return results;
};

createProblem = function createProblem(level) {
  var antalKlockor, antalPrimtal, h, pathname, rests, solution, steps, ticks, total, url;
  steps = level % 5 + Math.floor(level / 5) + 1;
  antalKlockor = 2 + Math.floor(level / 5);
  antalPrimtal = int(map(steps, 1, 125, 4, PRIMES.length));
  antalPrimtal = constrain(antalPrimtal, 4, PRIMES.length);
  ticks = _.sample(PRIMES.slice(0, +antalPrimtal + 1 || 9e9), antalKlockor);
  ticks.sort(function (a, b) {
    return a - b;
  });
  // första metoden ger alltför jämnt fördelade problem.
  // total = (_.sample ticks for i in range steps).reduce (a,b)->a+b 
  // Vissa totalsummor är omöjliga att uppnå. Max 50%
  solution = null;
  while (solution === null) {
    total = _.random(steps * ticks[0], steps * _.last(ticks));
    solution = solve(ticks, total, steps);
  }
  rests = createRests(ticks, total);
  h = window.location.href;
  pathname = h.split('?')[0];
  url = pathname + '?level=' + level + '&ticks=' + ticks + '&rests=' + rests;
  print(url);
  return { level: level, ticks: ticks, rests: rests, url: url, solution: solution };
};

solve = function solve(ticks, sum, n) {
  var i, index, j, k, l, len, len1, len2, o, p, rad, ref, ref1, ref2, tabell;
  tabell = new Array(sum + 1).fill(null);
  tabell[n * ticks[0]] = new Array(ticks.length).fill(0);
  tabell[n * ticks[0]][0] = n;
  ref = range(n, sum);
  for (l = 0, len = ref.length; l < len; l++) {
    i = ref[l];
    rad = tabell[i];
    if (rad === null) {
      continue; // går ej att expandera
    }
    ref1 = range(ticks.length);
    for (o = 0, len1 = ref1.length; o < len1; o++) {
      j = ref1[o];
      if (rad[j] === 0) {
        continue; // finns inget att flytta
      }
      ref2 = range(j + 1, ticks.length);
      for (p = 0, len2 = ref2.length; p < len2; p++) {
        k = ref2[p];
        index = i - ticks[j] + ticks[k];
        if (index > sum) {
          continue; // utanför tabellen
        }
        if (tabell[index] === null) {
          tabell[index] = rad.slice(0);
          tabell[index][j]--;
          tabell[index][k]++;
        }
      }
    }
  }
  return tabell[sum];
};

assert([5, 1, 0, 0, 0, 4], solve([2, 3, 5, 7, 11, 13], 65, 10));

copyToClipboard = function copyToClipboard(s) {
  var el;
  el = document.createElement('textarea');
  el.value = s;
  document.body.appendChild(el);
  el.select();
  document.execCommand('copy');
  return document.body.removeChild(el);
};

_fac = function fac(n) {
  if (n <= 1) {
    return 1;
  } else {
    return n * _fac(n - 1);
  }
};

combinations = function combinations(n, k) {
  return _fac(n + k - 1) / _fac(k - 1) / _fac(n);
};

short = function short(n) {
  var dekad, m, value;
  m = Math.floor(Math.log10(n) / 3);
  dekad = Math.pow(1000, m);
  value = Math.round(n / dekad);
  return value + " KMGT"[m];
};

assert("999 ", short(999));

assert("1K", short(1000));

assert("1K", short(1001));

assert("1K", short(1499));

assert("2K", short(1500));

assert("20K", short(20000));

assert("200K", short(200000));

assert("2M", short(2000000));
//# sourceMappingURL=utils.js.map
