'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// Generated by CoffeeScript 2.3.2
var MonteCarlo, TRACE;

TRACE = true;

MonteCarlo = function () {
  function MonteCarlo(root) {
    _classCallCheck(this, MonteCarlo);

    this.root = root;
  }

  _createClass(MonteCarlo, [{
    key: 'runSearch',
    value: function runSearch() {
      var factor = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;

      var b, child, end, i, len, move, ref, results, winner;
      ref = this.root.board.surr;
      for (i = 0, len = ref.length; i < len; i++) {
        b = ref[i];
        this.root.expand(b);
      }
      end = Date.now() + factor * thinkingTime;
      results = [];
      while (Date.now() < end) {
        results.push(function () {
          var ref1, results1;
          ref1 = this.root.children;
          //for i in range 500
          results1 = [];
          for (move in ref1) {
            child = ref1[move];
            winner = this.simulate(child);
            child.n++;
            if (winner === 1) {
              results1.push(child.t++);
            } else {
              results1.push(void 0);
            }
          }
          return results1;
        }.call(this));
      }
      return results;
    }
  }, {
    key: 'bestPlay',
    value: function bestPlay(node) {
      var child, move, pair, pairs;
      pairs = function () {
        var ref, results;
        ref = node.children;
        results = [];
        for (move in ref) {
          child = ref[move];
          results.push([child.t, move]);
        }
        return results;
      }();
      if (pairs.length === 0) {
        print('Problem in bestPlay');
        return null;
      }
      pair = _.max(pairs, function (pair) {
        return pair[0];
      });
      return pair[1];
    }
  }, {
    key: 'simulate',
    value: function simulate(node) {
      var board, winner;
      antal++;
      board = node.board.copy();
      winner = board.winner();
      while (winner === null) {
        board.move(_.sample(board.surr));
        winner = board.winner();
      }
      return winner;
    }
  }]);

  return MonteCarlo;
}();
//# sourceMappingURL=montecarlo.js.map
