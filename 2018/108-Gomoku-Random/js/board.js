'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// Generated by CoffeeScript 2.3.2
var Board,
    N,
    WINSIZE,
    modulo = function modulo(a, b) {
  return (+a % (b = +b) + b) % b;
},
    indexOf = [].indexOf;

N = 10;

WINSIZE = 5; // number of markers to win

Board = function () {
  function Board() {
    var moves = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

    _classCallCheck(this, Board);

    var digit, j, len;
    this.clear();
    for (j = 0, len = moves.length; j < len; j++) {
      digit = moves[j];
      this.move(parseInt(digit));
    }
  }

  _createClass(Board, [{
    key: 'copy',
    value: function copy() {
      var b;
      b = new Board();
      b.board = this.board.slice(); // 1D
      b.moves = this.moves.slice(); // 1D
      b.surr = this.surr.slice(); // 1D
      return b;
    }
  }, {
    key: 'extendSurr',
    value: function extendSurr() {
      // one step neighbours in eight directions 
      var col, dc, dr, index, j, k, l, len, len1, len2, move, newSurr, ref, ref1, ref2, ref3, ref4, row, s;
      move = _.last(this.moves);
      row = Math.floor(move / N);
      col = modulo(move, N);
      ref = [-1, 0, 1];
      for (j = 0, len = ref.length; j < len; j++) {
        dr = ref[j];
        ref1 = [-1, 0, 1];
        for (k = 0, len1 = ref1.length; k < len1; k++) {
          dc = ref1[k];
          if (dr !== 0 || dc !== 0) {
            if (0 <= (ref2 = row + dr) && ref2 < N && 0 <= (ref3 = col + dc) && ref3 < N) {
              index = N * (row + dr) + col + dc;
              if (this.board[index] === 0 && indexOf.call(this.surr, index) < 0) {
                this.surr.push(index);
              }
            }
          }
        }
      }

      // for move in @moves
      // 	@surr = _.without @surr, move # 20 ggr lÃ¥ngsammare
      newSurr = [];
      ref4 = this.surr;
      for (l = 0, len2 = ref4.length; l < len2; l++) {
        s = ref4[l];
        if (indexOf.call(this.moves, s) < 0) {
          newSurr.push(s);
        }
      }
      return this.surr = newSurr;
    }
  }, {
    key: 'clear',
    value: function clear() {
      var i;
      this.moves = [];
      this.board = function () {
        var j, len, ref, results;
        ref = range(N * N);
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          i = ref[j];
          results.push(0);
        }
        return results;
      }();
      return this.surr = [];
    }
  }, {
    key: 'move',
    value: function move(play) {
      this.board[play] = this.nextMarker();
      this.moves.push(parseInt(play));
      return this.extendSurr();
    }
  }, {
    key: 'nextBoard',
    value: function nextBoard(play) {
      var b;
      b = this.copy();
      b.move(play);
      return b;
    }
  }, {
    key: 'lastMarker',
    value: function lastMarker() {
      return [1, 2][this.moves.length % 2];
    }
  }, {
    key: 'nextMarker',
    value: function nextMarker() {
      return [2, 1][this.moves.length % 2];
    }
  }, {
    key: 'calc',
    value: function calc(dr, dc) {
      var _this = this;

      var helper, index, marker;
      helper = function helper() {
        var col, res, row;
        row = dr + Math.floor(index / N);
        col = dc + modulo(index, N);
        res = 0;
        while (0 <= row && row < N && 0 <= col && col < N && _this.board[row * N + col] === marker) {
          res++;
          row += dr;
          col += dc;
        }
        return res;
      };
      marker = this.lastMarker();
      index = _.last(this.moves);
      return 1 + helper() >= WINSIZE;
    }
  }, {
    key: 'done',
    value: function done() {
      var dc, dr, j, k, len, len1, ref, ref1;
      if (this.moves.length <= 2 * (WINSIZE - 1)) {
        return false;
      }
      ref = [-1, 0, 1];
      for (j = 0, len = ref.length; j < len; j++) {
        dr = ref[j];
        ref1 = [-1, 0, 1];
        for (k = 0, len1 = ref1.length; k < len1; k++) {
          dc = ref1[k];
          if (dr !== 0 || dc !== 0) {
            if (this.calc(dr, dc)) {
              return true;
            }
          }
        }
      }
      return false;
    }
  }, {
    key: 'draw',
    value: function draw() {
      return this.moves.length === N * N; // OBS! Kan vara vinst!
    }
  }, {
    key: 'winner',
    value: function winner() {
      if (this.draw()) {
        return 0.5;
      }
      if (this.done()) {
        return [1, 0][this.moves.length % 2];
      }
      return null;
    }
  }]);

  return Board;
}();
//# sourceMappingURL=board.js.map
