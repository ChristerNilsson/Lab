'use strict';

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// Generated by CoffeeScript 2.3.2
var MonteCarlo, TRACE;

TRACE = true;

MonteCarlo = function () {
  function MonteCarlo(root) {
    _classCallCheck(this, MonteCarlo);

    this.root = root;
  }

  _createClass(MonteCarlo, [{
    key: 'dump',
    value: function dump(node) {
      var key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
      var level = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '*';

      var child, ref, results;
      print(level, key, 't:' + node.t, 'n:' + node.n, 'moves:' + JSON.stringify(node.board.moves), 'board:' + JSON.stringify(node.board.board));
      ref = node.children;
      results = [];
      for (key in ref) {
        child = ref[key];
        if (child !== null) {
          results.push(this.dump(child, key, level + '|'));
        } else {
          results.push(void 0);
        }
      }
      return results;
    }
  }, {
    key: 'runSearch',
    value: function runSearch() {
      var factor = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;

      var end, node, winner;
      end = Date.now() + factor * thinkingTime;
      while (Date.now() < end) {
        // if TRACE
        // 	print ''
        // 	print montecarlo
        // 	@dump montecarlo.root
        node = this.select();
        if (node === null) {
          return;
        }
        winner = node.board.winner();
        if (winner === null) {
          node = this.expand(node);
          winner = this.simulate(node);
        }
        this.backpropagate(node, winner);
      }
      return print('');
    }

    //print montecarlo
    //@dump montecarlo.root

  }, {
    key: 'bestPlay',
    value: function bestPlay(node) {
      var a, b, lst, pairs, play, res;
      pairs = function () {
        var i, len, ref, results;
        ref = node.allPlays();
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          play = ref[i];
          results.push([node.children[play].n, play]);
        }
        return results;
      }();
      if (pairs.length === 0) {
        print('Problem in bestPlay');
        return null;
      }
      res = _.max(pairs, function (pair) {
        return pair[0];
      })[1];
      lst = JSON.stringify(function () {
        var i, len, results;
        results = [];
        for (i = 0, len = pairs.length; i < len; i++) {
          var _pairs$i = _slicedToArray(pairs[i], 2);

          a = _pairs$i[0];
          b = _pairs$i[1];

          results.push(a);
        }
        return results;
      }());
      if (TRACE) {
        print('bestPlay', res, lst);
      }
      return res;
    }
  }, {
    key: 'select',
    value: function select() {
      // väljer en nod ur trädet
      var bestPlay, node, pairs, play, plays;
      node = this.root;
      while (node.isFullyExpanded()) {
        plays = node.allPlays();
        pairs = function () {
          var i, len, results;
          results = [];
          for (i = 0, len = plays.length; i < len; i++) {
            play = plays[i];
            results.push([node.children[play].getUCB1(), play]);
          }
          return results;
        }();
        if (pairs.length === 0) {
          return null;
        }
        bestPlay = _.max(pairs, function (pair) {
          return pair[0];
        })[1];
        node = node.children[bestPlay];
      }
      // if TRACE then print 'selecting',JSON.stringify(node.board.moves), pairs
      // if TRACE then print 'selected',JSON.stringify node.board.moves
      return node;
    }
  }, {
    key: 'expand',
    value: function expand(node) {
      var randomNode;
      randomNode = _.sample(node.unexpandedPlays());

      // if TRACE then print 'expand chooses',JSON.stringify randomNode
      return node.expand(randomNode);
    }
  }, {
    key: 'simulate',
    value: function simulate(node) {
      var board, winner;
      board = node.board;
      winner = board.winner();
      while (winner === null) {
        board = board.nextBoard(_.sample(board.legalPlays()));
        winner = board.winner();
      }
      // if TRACE then print 'simulate',winner,"#{JSON.stringify node.board.moves}",board.board,board.moves
      return winner;
    }

    // Anderson & Hesselberg 2016

  }, {
    key: 'backpropagate',
    value: function backpropagate(node, score) {
      // score in [0, 0.5, 1]
      var results;
      results = [];
      while (node !== null) {
        node.n++;
        node.t += [score, 1 - score][node.board.moves.length % 2];
        results.push(node = node.parent);
      }
      return results;
    }
  }]);

  return MonteCarlo;
}();

// b = new Board()
// n = new Node null,null,b
// mc = new MonteCarlo n
// mc.runSearch()
// print mc
// print mc.bestPlay mc.root
//# sourceMappingURL=montecarlo.js.map
