"use strict";

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

// Generated by CoffeeScript 2.0.3
// Vectorized Playing Cards 2.0 - http://sourceforge.net/projects/vector-cards/
// Copyright 2015 - Chris Aguilar - conjurenation@gmail.com
// Licensed under LGPL 3 - www.gnu.org/copyleft/lesser.html

//  4  4  4  4  4  0  8  8  8  8  8
//  5  5  5  5  5  1  9  9  9  9  9
//  6  6  6  6  6  2 10 10 10 10 10
//  7  7  7  7  7  3 11 11 11 11 11
//    12 13 14 15    17 18 19 20
var H,
    OFFSETX,
    RANK,
    SUIT,
    W,
    aceCards,
    autoShake,
    board,
    calcAntal,
    cands,
    cards,
    compress,
    countAceCards,
    display,
    done,
    dsts,
    expand,
    fakeBoard,
    findAllMoves,
    h,
    hash,
    hist,
    img,
    keyPressed,
    legalMove,
    makeAutoShake,
    makeBoard,
    makeKey,
    makeMove,
    marked,
    mousePressed,
    newGame,
    originalBoard,
    preload,
    prettyCard,
    prettyMove,
    printSolution,
    range,
    restart,
    setup,
    shake,
    showHeap,
    srcs,
    start,
    timing,
    undo,
    undoMove,
    w,
    indexOf = [].indexOf;

SUIT = "kl hj sp ru".split(' ');

RANK = "Ess 2 3 4 5 6 7 8 9 T Kn D K".split(' ');

OFFSETX = 468;

W = 263.25;

H = 352;

w = W / 3;

h = H / 3;

img = null;

board = null;

cards = null;

hist = [];

marked = null;

cands = null;

hash = null;

aceCards = 4;

done = null;

originalBoard = null;

start = null;

timing = null;

autoShake = [];

shake = true;

preload = function preload() {
  return img = loadImage('cards/Color_52_Faces_v.2.0.png');
};

range = _.range;

compress = function compress(board) {
  var h1, h2, heap, i, l, len, len1, m, ref, ref1, res, results, suit1, suit2, temp, v1, v2;
  ref = [4, 5, 6, 7, 8, 9, 10, 11];
  results = [];
  for (l = 0, len = ref.length; l < len; l++) {
    heap = ref[l];
    if (board[heap].length > 1) {
      temp = board[heap][0];
      res = [];
      ref1 = range(1, board[heap].length);
      for (m = 0, len1 = ref1.length; m < len1; m++) {
        i = ref1[m];
        var _temp = temp;

        var _temp2 = _slicedToArray(_temp, 3);

        suit1 = _temp2[0];
        h1 = _temp2[1];
        v1 = _temp2[2];

        var _board$heap$i = _slicedToArray(board[heap][i], 3);

        suit2 = _board$heap$i[0];
        h2 = _board$heap$i[1];
        v2 = _board$heap$i[2];

        if (suit1 === suit2 && 1 === abs(v1 - h2)) {
          temp = [suit1, h1, v2];
        } else {
          res.push(temp);
          temp = [suit2, h2, v2];
        }
      }
      res.push(temp);
      results.push(board[heap] = res);
    } else {
      results.push(void 0);
    }
  }
  return results;
};

makeBoard = function makeBoard() {
  var wild = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

  var heap, i, j, l, len, len1, len2, len3, len4, len5, len6, m, o, p, q, r, rank, ref, ref1, ref2, ref3, ref4, ref5, ref6, rr, suit, t;
  cards = [];
  ref = range(1, 13);
  for (l = 0, len = ref.length; l < len; l++) {
    rank = ref[l];
    ref1 = range(4);
    for (m = 0, len1 = ref1.length; m < len1; m++) {
      suit = ref1[m];
      cards.push([suit, rank, rank]);
    }
  }
  cards = _.shuffle(cards);
  board = [];
  ref2 = range(21);
  for (o = 0, len2 = ref2.length; o < len2; o++) {
    i = ref2[o];
    board.push([]);
  }
  ref3 = [2, 1, 3, 0];
  for (heap = p = 0, len3 = ref3.length; p < len3; heap = ++p) {
    suit = ref3[heap];
    board[heap].push([suit, 0, 0]);
  }
  ref4 = range(4, 12);
  for (q = 0, len4 = ref4.length; q < len4; q++) {
    i = ref4[q];
    ref5 = range(5);
    for (r = 0, len5 = ref5.length; r < len5; r++) {
      j = ref5[r];
      rr = wild ? int(random(4, 12)) : i;
      board[rr].push(cards.pop());
    }
  }
  ref6 = [12, 13, 14, 15, 17, 18, 19, 20];
  for (t = 0, len6 = ref6.length; t < len6; t++) {
    heap = ref6[t];
    board[heap].push(cards.pop());
  }
  return compress(board);
};

fakeBoard = function fakeBoard() {
  //board = [[[2,0,0]],[[1,0,0]],[[3,0,0]],[[0,0,0]],[[0,2,2],[1,3,3],[1,1,1],[3,1,1],[3,2,2]],[[0,4,4],[0,12,12],[3,5,5],[1,8,8],[3,9,9]],[[2,11,11],[3,12,12],[0,6,6],[2,5,5],[1,7,7]],[[0,8,8],[3,11,11],[2,6,6],[2,9,9],[1,12,12]],[[0,9,9],[0,10,10],[2,10,10],[2,4,4],[2,7,7]],[[1,2,2],[3,4,4],[3,6,6],[0,5,5],[1,11,11]],[[0,1,1],[0,7,7],[1,10,10],[1,5,5],[3,8,8]],[[0,3,3],[1,4,4],[3,3,3],[2,2,2],[3,10,10]],[[0,11,11]],[[3,7,7]],[[2,1,1]],[[2,8,8]],[],[[1,6,6]],[[2,3,3]],[[2,12,12]],[[1,9,9]]] # nix!
  //board = [[[2,0,0]],[[1,0,0]],[[3,0,0]],[[0,0,0]],[[0,10,10],[2,11,11],[0,6,6],[3,9,9],[1,8,8]],[[3,10,10],[2,10,10],[0,12,12],[0,4,4],[3,1,1]],[[3,12,12],[1,3,3],[1,4,4],[1,9,9],[0,2,2]],[[3,4,4],[3,5,5],[2,5,5],[2,9,9],[2,3,3]],[[3,6,6],[1,7,7],[0,5,5],[2,7,7],[3,8,8]],[[2,4,4],[0,9,9],[1,2,2],[3,11,11],[1,6,6]],[[2,8,8],[2,1,1],[2,2,2],[1,10,10],[3,3,3]],[[1,1,1],[1,11,11],[1,12,12],[3,7,7],[2,12,12]],[[0,11,11]],[[3,2,2]],[[1,5,5]],[[0,8,8]],[],[[2,6,6]],[[0,3,3]],[[0,1,1]],[[0,7,7]]] # 851 ms
  //board = [[[2,0,0]],[[1,0,0]],[[3,0,0]],[[0,0,0]],[[2,3,3],[2,12,12],[2,11,11],[3,10,10],[1,7,7]],[[1,11,11],[0,5,5],[2,9,9],[3,12,12],[1,5,5]],[[0,12,12],[3,8,8],[1,9,9],[0,6,6],[1,6,6]],[[3,1,1],[2,7,7],[0,8,8],[0,7,7],[1,3,3]],[[1,8,8],[0,9,9],[2,10,10],[3,9,9],[1,4,4]],[[1,12,12],[3,2,2],[3,3,3],[3,4,4],[1,2,2]],[[3,6,6],[2,1,1],[0,2,2],[2,8,8],[0,3,3]],[[1,1,1],[3,7,7],[2,6,6],[3,11,11],[0,1,1]],[[2,5,5]],[[2,2,2]],[[1,10,10]],[[2,4,4]],[],[[3,5,5]],[[0,10,10]],[[0,11,11]],[[0,4,4]]] # 963 ms
  //board = [[[2,0,0]],[[1,0,0]],[[3,0,0]],[[0,0,0]],[[3,12,12],[3,9,9],[2,5,5],[3,2,2],[1,10,10]],[[0,1,1],[0,10,10],[2,4,4],[1,3,3],[3,7,7]],[[0,3,3],[0,11,11],[2,7,7],[3,8,8],[1,2,2]],[[0,5,5],[2,6,6],[0,6,6],[3,3,3],[1,5,5]],[[0,4,4],[3,5,5],[0,2,2],[3,10,10],[2,2,2]],[[2,10,10],[0,12,12],[2,1,1],[2,11,11],[0,9,9]],[[3,4,4],[1,7,7],[1,6,6],[2,12,12],[1,8,8]],[[1,1,1],[1,12,12],[1,11,11],[1,4,4],[2,3,3]],[[0,8,8]],[[3,11,11]],[[2,9,9]],[[0,7,7]],[],[[3,1,1]],[[2,8,8]],[[3,6,6]],[[1,9,9]]] # 264 ms
  //board = [[[2,0,0]],[[1,0,0]],[[3,0,0]],[[0,0,0]],[[1,1,1],[0,12,12],[3,3,3],[2,7,7],[3,11,11]],[[2,11,11],[2,8,8],[3,6,6],[0,1,1],[0,6,6]],[[1,8,8],[1,6,6],[0,3,3],[1,3,3],[0,7,7]],[[0,11,11],[1,10,10],[3,12,12],[1,11,11],[1,2,2]],[[0,4,4],[3,2,2],[2,2,2],[3,7,7],[0,5,5]],[[2,5,5],[2,9,9],[3,8,8],[3,9,9],[2,4,4]],[[2,10,10],[0,9,9],[1,12,12],[3,4,4],[3,10,10]],[[2,12,12],[3,5,5],[1,4,4],[2,1,1],[0,2,2]],[[1,5,5]],[[0,10,10]],[[0,8,8]],[[1,9,9]],[],[[3,1,1]],[[1,7,7]],[[2,6,6]],[[2,3,3]]] # 397 ms
  board = [[[2, 0, 0]], [[1, 0, 0]], [[3, 0, 0]], [[0, 0, 0]], [[0, 2, 2], [2, 4, 4], [2, 10, 10], [2, 5, 5], [1, 1, 1], [3, 12, 12], [2, 12, 12], [3, 11, 11], [1, 8, 8], [1, 6, 6]], [[3, 9, 9], [2, 11, 11], [0, 12, 12], [0, 3, 3], [3, 10, 10]], [[3, 3, 3], [0, 9, 9]], [[2, 7, 7], [1, 4, 4], [3, 2, 2], [1, 9, 9], [0, 6, 6], [1, 5, 5], [0, 1, 1]], [[1, 3, 3], [1, 2, 2], [2, 2, 2], [2, 6, 6], [1, 11, 11]], [[3, 7, 7], [2, 8, 8], [1, 7, 7], [3, 1, 1], [0, 8, 8]], [[2, 3, 3], [3, 5, 5], [3, 6, 6]], [[1, 12, 12], [3, 4, 4], [0, 5, 5]], [[0, 7, 7]], [[3, 8, 8]], [[1, 10, 10]], [[0, 11, 11]], [], [[0, 4, 4]], [[0, 10, 10]], [[2, 1, 1]], [[2, 9, 9]]];
  board = [[[2, 0, 0]], [[1, 0, 0]], [[3, 0, 0]], [[0, 0, 0]], [[2, 7, 7], [0, 8, 8], [0, 2, 2], [0, 5, 5]], [[2, 9, 9], [1, 5, 5], [0, 3, 3], [2, 11, 11], [1, 10, 10]], [[2, 2, 2], [1, 8, 8]], [[1, 11, 11], [2, 6, 6], [2, 10, 10], [2, 5, 5], [3, 3, 3], [1, 1, 1]], [[3, 2, 2], [3, 12, 12], [2, 3, 3], [1, 7, 7], [3, 4, 4], [3, 11, 11]], [[3, 8, 8], [0, 10, 10], [3, 7, 7], [0, 12, 12], [1, 3, 3], [0, 9, 9], [1, 12, 12]], [[0, 7, 7], [2, 12, 12], [0, 6, 6], [3, 9, 9]], [[1, 2, 2], [0, 4, 4], [1, 6, 6], [2, 4, 4], [1, 4, 4], [1, 9, 9]], [[3, 6, 6]], [[2, 8, 8]], [[2, 1, 1]], [[3, 10, 10]], [], [[0, 11, 11]], [[0, 1, 1]], [[3, 1, 1]], [[3, 5, 5 // 118 ms
  ]]];
  //board = [[[2,0,0]],[[1,0,0]],[[3,0,0]],[[0,0,0]],[[3,3,3],[2,3,3],[0,6,6],[3,5,5],[0,9,9],[2,10,10],[1,10,10]],[[0,10,10],[0,7,7],[3,8,8],[2,11,11]],[[0,12,12],[3,7,7],[2,1,1],[2,8,8],[1,7,7]],[[1,4,4],[2,5,5],[2,6,6],[1,2,2],[0,1,1],[2,2,2],[3,11,11],[2,7,7]],[[3,6,6],[3,9,9],[0,4,4],[3,4,4],[1,8,8]],[[0,3,3],[3,12,12],[1,11,11]],[[2,4,4],[0,2,2],[3,10,10],[0,8,8]],[[1,5,5],[2,9,9],[1,6,6],[1,1,1]],[[0,5,5]],[[0,11,11]],[[2,12,12]],[[1,3,3]],[],[[1,12,12]],[[1,9,9]],[[3,1,1]],[[3,2,2]]]
  board = [[[2, 0, 0]], [[1, 0, 0]], [[3, 0, 0]], [[0, 0, 0]], [[0, 7, 7], [1, 10, 10], [0, 1, 1], [0, 2, 2], [2, 7, 7]], [[2, 1, 1], [2, 8, 8], [1, 3, 3], [1, 7, 7], [3, 11, 11]], [[2, 2, 2], [3, 6, 6], [3, 8, 8], [2, 4, 4], [0, 3, 3]], [[3, 1, 1], [0, 5, 5], [3, 2, 2], [2, 3, 3], [1, 2, 2]], [[3, 4, 4], [2, 10, 10], [1, 11, 11], [0, 11, 11], [2, 5, 5]], [[3, 9, 9], [0, 6, 6], [2, 11, 11], [0, 10, 10], [3, 12, 12]], [[1, 9, 9], [1, 12, 12], [0, 4, 4], [1, 6, 6], [2, 6, 6]], [[1, 1, 1], [2, 12, 12], [1, 5, 5], [3, 7, 7], [1, 8, 8]], [[3, 10, 10]], [[0, 9, 9]], [[3, 3, 3]], [[0, 12, 12]], [], [[2, 9, 9]], [[0, 8, 8]], [[1, 4, 4]], [[3, 5, 5]]];
  board = [[[2, 0, 0]], [[1, 0, 0]], [[3, 0, 0]], [[0, 0, 0]], [[3, 9, 9], [0, 4, 4], [3, 5, 5], [0, 7, 7], [1, 5, 5]], [[1, 10, 10], [3, 7, 7], [0, 6, 6], [3, 11, 11], [3, 8, 8]], [[2, 2, 2], [3, 1, 1], [1, 1, 1], [1, 9, 9], [0, 9, 9]], [[1, 2, 2], [2, 7, 7], [1, 6, 6], [3, 6, 6], [3, 3, 3]], [[1, 7, 7], [2, 3, 3], [0, 1, 1], [2, 1, 1], [0, 3, 3]], [[2, 8, 8], [1, 11, 11], [2, 6, 6], [0, 10, 10], [3, 4, 4]], [[2, 5, 5], [2, 12, 12], [3, 10, 10], [0, 2, 2], [1, 8, 8]], [[2, 11, 11], [2, 9, 9], [0, 12, 12], [3, 12, 12], [1, 4, 4]], [[1, 12, 12]], [[0, 5, 5]], [[2, 10, 10]], [[3, 2, 2]], [], [[1, 3, 3]], [[2, 4, 4]], [[0, 11, 11]], [[0, 8, 8]]];
  return board = [[[2, 0, 0]], [[1, 0, 0]], [[3, 0, 0]], [[0, 0, 0]], [[2, 10, 10], [2, 12, 12], [1, 8, 8], [1, 12, 12], [3, 3, 3]], [[1, 2, 2], [0, 5, 5]], [[3, 12, 12], [2, 4, 4], [3, 8, 8], [1, 5, 5], [0, 8, 8]], [[1, 11, 11], [0, 1, 1], [0, 4, 4]], [[1, 7, 7], [1, 3, 3], [0, 10, 10], [3, 4, 4], [2, 1, 1], [3, 11, 11]], [[2, 9, 9], [2, 5, 5], [1, 6, 6], [2, 2, 2], [1, 1, 1], [0, 3, 3]], [[2, 6, 6], [2, 3, 3], [3, 1, 2], [0, 2, 2], [1, 9, 9], [3, 7, 7], [3, 10, 10], [0, 11, 11], [2, 7, 7]], [[2, 8, 8], [3, 6, 6], [1, 10, 10]], [[0, 6, 6]], [[3, 5, 5]], [[3, 9, 9]], [[0, 12, 12]], [], [[2, 11, 11]], [[0, 9, 9]], [[1, 4, 4]], [[0, 7, 7]]];
};

makeAutoShake = function makeAutoShake() {
  var i, l, len, ref, results;
  autoShake = [];
  ref = range(52);
  results = [];
  for (l = 0, len = ref.length; l < len; l++) {
    i = ref[l];
    results.push(autoShake.push([int(random(-2, 2)), int(random(-2, 2))]));
  }
  return results;
};

setup = function setup() {
  createCanvas(800, 600);
  makeAutoShake();
  return newGame('C');
};

showHeap = function showHeap(board, heap, x, y, dx) {
  var card, dr, k, l, len, len1, m, n, rank, ref, ref1, suit, unvisible, visible, x0, y0;
  n = calcAntal(board[heap]);
  if (n === 0) {
    return;
  }
  x0 = width / 2 - w / 2;
  if (x < 0) {
    x0 += -w + dx;
  }
  if (x > 0) {
    x0 += w - dx;
  }
  x = x0 + x * dx / 2;
  y = y * h;
  ref = board[heap];
  for (k = l = 0, len = ref.length; l < len; k = ++l) {
    card = ref[k];
    var _card = card;

    var _card2 = _slicedToArray(_card, 3);

    suit = _card2[0];
    unvisible = _card2[1];
    visible = _card2[2];

    dr = unvisible < visible ? 1 : -1;
    ref1 = range(unvisible, visible + dr, dr);
    for (m = 0, len1 = ref1.length; m < len1; m++) {
      rank = ref1[m];

      var _ref = shake ? autoShake[13 * suit + rank] : [0, 0];

      var _ref2 = _slicedToArray(_ref, 2);

      x0 = _ref2[0];
      y0 = _ref2[1];

      image(img, x0 + x, y0 + y + 13, w, h, OFFSETX + W * rank, 1092 + H * suit, 243, H);
      x += dx;
    }
  }
  if (marked != null && marked === heap) {
    fill(0, 128, 0, 128);
    if (y === 4 * h) {
      return ellipse(-4 + x - w / 2, 6 + y + h / 2, 60);
    } else {
      if (dx < 0) {
        ellipse(-4 + x + w, 6 + y + h / 2, 60);
      }
      if (dx > 0) {
        ellipse(-4 + x, 6 + y + h / 2, 60);
      }
      if (dx === 0) {
        return ellipse(-4 + x + w / 2, 6 + y + h / 2, 60);
      }
    }
  }
};

calcAntal = function calcAntal(lst) {
  var l, len, res, suit, unvisible, visible;
  res = 0;
  for (l = 0, len = lst.length; l < len; l++) {
    var _lst$l = _slicedToArray(lst[l], 3);

    suit = _lst$l[0];
    unvisible = _lst$l[1];
    visible = _lst$l[2];

    res += 1 + abs(unvisible - visible);
  }
  return res;
};

display = function display(board) {
  var dx, heap, l, len, len1, len2, len3, m, n, o, p, ref, ref1, ref2, ref3, results, x, xx, y;
  background(128);
  textAlign(CENTER, CENTER);
  textSize(10);
  x = width / 2;
  y = height - 100;
  fill(200);
  text('U = Undo', x, y);
  text('R = Restart', x, y + 15);
  text('C = Classic', x, y + 30);
  text('W = Wild', x, y + 45);
  if (timing !== null) {
    text(timing + " seconds", x, y + 75);
  }
  text('Generalens Tidsfördriv', x, y + 95);
  ref = [0, 1, 2, 3];
  for (y = l = 0, len = ref.length; l < len; y = ++l) {
    heap = ref[y];
    showHeap(board, heap, 0, y, 0);
  }
  ref1 = [4, 5, 6, 7];
  for (y = m = 0, len1 = ref1.length; m < len1; y = ++m) {
    heap = ref1[y];
    n = calcAntal(board[heap]);
    dx = n <= 7 ? w / 2 : (width / 2 - w / 2 - w) / (n - 1);
    showHeap(board, heap, -2, y, -dx);
  }
  ref2 = [8, 9, 10, 11];
  for (y = o = 0, len2 = ref2.length; o < len2; y = ++o) {
    heap = ref2[y];
    n = calcAntal(board[heap]);
    dx = n <= 7 ? w / 2 : (width / 2 - w / 2 - w) / (n - 1);
    showHeap(board, heap, 2, y, dx);
  }
  ref3 = [12, 13, 14, 15, 16, 17, 18, 19, 20];
  results = [];
  for (x = p = 0, len3 = ref3.length; p < len3; x = ++p) {
    heap = ref3[x];
    xx = [-8, -6, -4, -2, 0, 2, 4, 6, 8][x];
    results.push(showHeap(board, heap, xx, 4, w));
  }
  return results;
};

legalMove = function legalMove(board, a, b) {
  var a1, a2, b1, b2, sa, sb;
  if (a === 0 || a === 1 || a === 2 || a === 3) {
    return false;
  }
  if (b === 12 || b === 13 || b === 14 || b === 15 || b === 17 || b === 18 || b === 19 || b === 20) {
    return false;
  }
  if (board[a].length === 0) {
    return false;
  }
  if (board[b].length === 0) {
    return true;
  }

  var _$last = _.last(board[a]);

  var _$last2 = _slicedToArray(_$last, 3);

  sa = _$last2[0];
  a1 = _$last2[1];
  a2 = _$last2[2];

  var _$last3 = _.last(board[b]);

  var _$last4 = _slicedToArray(_$last3, 3);

  sb = _$last4[0];
  b1 = _$last4[1];
  b2 = _$last4[2];

  if (sa === sb && abs(a2 - b2) === 1) {
    return true;
  }
  return false;
};

makeMove = function makeMove(board, a, b, record) {
  // from heap a to heap b
  var suit, unvisible, visible;

  // reverse order
  var _board$a$pop = board[a].pop();

  var _board$a$pop2 = _slicedToArray(_board$a$pop, 3);

  suit = _board$a$pop2[0];
  visible = _board$a$pop2[1];
  unvisible = _board$a$pop2[2];
  if (record) {
    hist.push([a, b, 1 + abs(unvisible - visible)]);
  }
  if (board[b].length > 0) {
    unvisible = board[b].pop()[1];
  }
  return board[b].push([suit, unvisible, visible]);
};

undoMove = function undoMove(_ref3) {
  var _ref4 = _slicedToArray(_ref3, 3),
      a = _ref4[0],
      b = _ref4[1],
      antal = _ref4[2];

  var suit, unvisible, visible;

  var _board$b$pop = board[b].pop();

  var _board$b$pop2 = _slicedToArray(_board$b$pop, 3);

  suit = _board$b$pop2[0];
  unvisible = _board$b$pop2[1];
  visible = _board$b$pop2[2];

  if (unvisible < visible) {
    board[a].push([suit, visible, visible - antal + 1]);
    if (visible !== unvisible + antal - 1) {
      return board[b].push([suit, unvisible, visible - antal]);
    }
  } else {
    board[a].push([suit, visible, visible + antal - 1]);
    if (unvisible !== visible + antal - 1) {
      return board[b].push([suit, unvisible, visible + antal]);
    }
  }
};

mousePressed = function mousePressed() {
  var marked1, mx, my;
  mx = Math.floor(mouseX / (W / 3));
  my = Math.floor(mouseY / (H / 3));
  if (my >= 4) {
    marked1 = 12 + mx;
  } else {
    if (mx === 4) {
      marked1 = my;
    } else if (mx < 4) {
      marked1 = 4 + my;
    } else {
      marked1 = 8 + my;
    }
  }
  if (marked != null) {
    if (marked1 !== marked) {
      if (legalMove(board, marked, marked1)) {
        makeMove(board, marked, marked1, true);
      }
    }
    marked = null;
  } else {
    marked = marked1;
  }
  if (52 === countAceCards(board)) {
    timing = Math.floor((millis() - start) / 1000);
  }
  return display(board);
};

//###### AI-section ########
srcs = [4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 17, 18, 19, 20];

dsts = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];

findAllMoves = function findAllMoves(b) {
  var dst, l, len, len1, m, res, src;
  res = [];
  for (l = 0, len = srcs.length; l < len; l++) {
    src = srcs[l];
    for (m = 0, len1 = dsts.length; m < len1; m++) {
      dst = dsts[m];
      if (src !== dst) {
        if (legalMove(b, src, dst)) {
          res.push([src, dst]);
        }
      }
    }
  }
  return res;
};

makeKey = function makeKey(b) {
  var heap, index, l, len, len1, m, r1, r2, res, suit;
  res = '';
  for (index = l = 0, len = b.length; l < len; index = ++l) {
    heap = b[index];
    for (m = 0, len1 = heap.length; m < len1; m++) {
      var _heap$m = _slicedToArray(heap[m], 3);

      suit = _heap$m[0];
      r1 = _heap$m[1];
      r2 = _heap$m[2];

      if (r1 === r2) {
        res += 'shrk'[suit] + str(r1);
      } else {
        res += 'shrk'[suit] + str(r1) + str(r2);
      }
    }
    res += ' ';
  }
  return res;
};

countAceCards = function countAceCards(b) {
  var heap, l, len, ref, res;
  res = 0;
  ref = [0, 1, 2, 3];
  for (l = 0, len = ref.length; l < len; l++) {
    heap = ref[l];
    res += calcAntal(b[heap]);
  }
  return res;
};

expand = function expand(_ref5) {
  var _ref6 = _slicedToArray(_ref5, 5),
      aceCards = _ref6[0],
      level = _ref6[1],
      b = _ref6[2],
      src0 = _ref6[3],
      dst0 = _ref6[4];

  var b1, dst, key, l, len, moves, res, src;
  res = [];
  moves = findAllMoves(b);
  for (l = 0, len = moves.length; l < len; l++) {
    var _moves$l = _slicedToArray(moves[l], 2);

    src = _moves$l[0];
    dst = _moves$l[1];

    b1 = _.cloneDeep(b);
    makeMove(b1, src, dst);
    key = makeKey(b1);
    if (!(key in hash)) {
      hash[key] = [src, dst, b];
      res.push([countAceCards(b1), level - 1, b1, src, dst]);
    }
  }
  return res;
};

newGame = function newGame(key) {
  var b, cand, dst, level, nr, src;
  start = millis();
  timing = null;
  while (true) {
    makeBoard(key === 'W');
    //print board
    originalBoard = _.cloneDeep(board);
    cands = [[4, 0, board, -1, -1 // antal kort på ässen, antal drag, board
    ]];
    done = board;
    hash = {};
    nr = 0;
    while (cands.length > 0 && aceCards < 52) {
      nr++;
      cand = cands.pop();
      var _cand = cand;

      var _cand2 = _slicedToArray(_cand, 5);

      aceCards = _cand2[0];
      level = _cand2[1];
      b = _cand2[2];
      src = _cand2[3];
      dst = _cand2[4];

      if (src > -1) {
        var _hash$makeKey = _slicedToArray(hash[makeKey(cand[2])], 3);

        src = _hash$makeKey[0];
        dst = _hash$makeKey[1];
        b = _hash$makeKey[2];
      }
      cands = cands.concat(expand(cand));
      cands.sort(function (a, b) {
        if (a[0] === b[0]) {
          return a[1] - b[1];
        } else {
          return a[0] - b[0];
        }
      });
    }
    print(nr, aceCards, -level); //,cands.length #, src,dst,prettyMove src,dst,b
    if (cands.length > 0) {
      print(JSON.stringify(originalBoard));
      board = cand[2];
      printSolution(hash, board);
      board = _.cloneDeep(originalBoard);
      print(int(millis() - start) + " ms");
      display(board);
      start = millis();
      return;
    }
  }
};

undo = function undo() {
  undoMove(hist.pop());
  return display(board);
};

restart = function restart() {
  hist = [];
  board = _.cloneDeep(originalBoard);
  return display(board);
};

keyPressed = function keyPressed() {
  if (key === 'U' && hist.length > 0) {
    undo();
  }
  if (key === 'R') {
    restart();
  }
  if (indexOf.call('CW', key) >= 0) {
    newGame(key);
  }
  if (key === 'A') {
    shake = !shake;
    return display(board);
  }
};

prettyCard = function prettyCard(_ref7) {
  var _ref8 = _slicedToArray(_ref7, 3),
      suit = _ref8[0],
      unvisible = _ref8[1],
      visible = _ref8[2];

  var antal = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;

  if (antal === 1) {
    return "" + RANK[visible];
  } else if (unvisible === visible) {
    return SUIT[suit] + " " + RANK[visible];
  } else {
    return SUIT[suit] + " " + RANK[unvisible] + ".." + RANK[visible];
  }
};

prettyMove = function prettyMove(src, dst, b) {
  var c1, c2;
  c1 = _.last(b[src]);
  if (b[dst].length > 0) {
    c2 = _.last(b[dst]);
    return prettyCard(c1) + " till " + prettyCard(c2, 1);
  } else {
    return prettyCard(c1) + " till h\xE5l";
  }
};

printSolution = function printSolution(hash, b) {
  var dst, index, key, l, len, s, solution, src;
  key = makeKey(b);
  solution = [];
  while (key in hash) {
    var _hash$key = _slicedToArray(hash[key], 3);

    src = _hash$key[0];
    dst = _hash$key[1];
    b = _hash$key[2];

    solution.push(hash[key]);
    key = makeKey(b);
  }
  solution.reverse();
  s = '';
  for (index = l = 0, len = solution.length; l < len; index = ++l) {
    var _solution$index = _slicedToArray(solution[index], 3);

    src = _solution$index[0];
    dst = _solution$index[1];
    b = _solution$index[2];

    s += "\n" + index + ": " + prettyMove(src, dst, b);
  }
  return print(s);
};
//# sourceMappingURL=sketch.js.map
