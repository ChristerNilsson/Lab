"use strict";

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

// Generated by CoffeeScript 2.0.3
// Vectorized Playing Cards 2.0 - http://sourceforge.net/projects/vector-cards/
// Copyright 2015 - Chris Aguilar - conjurenation@gmail.com
// Licensed under LGPL 3 - www.gnu.org/copyleft/lesser.html

//  4  4  4  4  4  0  8  8  8  8  8
//  5  5  5  5  5  1  9  9  9  9  9
//  6  6  6  6  6  2 10 10 10 10 10
//  7  7  7  7  7  3 11 11 11 11 11
//    12 13 14 15    16 17 18 19      PANEL
var ACES,
    H,
    HEAPS,
    LIMIT,
    LONG,
    N,
    OFFSETX,
    PANEL,
    RANK,
    SUIT,
    W,
    aceCards,
    autoShake,
    backs,
    board,
    calcAntal,
    cands,
    cards,
    classic,
    compress,
    countAceCards,
    display,
    dsts,
    expand,
    faces,
    fakeBoard,
    findAllMoves,
    h,
    hash,
    hist,
    keyPressed,
    legalMove,
    makeAutoShake,
    makeBoard,
    makeKey,
    makeMove,
    mousePressed,
    newGame,
    nextLevel,
    originalBoard,
    preload,
    prettyCard,
    prettyMove,
    printSolution,
    range,
    restart,
    setup,
    shake,
    showHeap,
    srcs,
    start,
    timing,
    undoMove,
    w,
    indexOf = [].indexOf;

ACES = [0, 1, 2, 3];

HEAPS = [4, 5, 6, 7, 8, 9, 10, 11];

PANEL = [12, 13, 14, 15, 16, 17, 18, 19];

SUIT = "club heart spade diamond".split(' ');

RANK = "A 2 3 4 5 6 7 8 9 T J Q K".split(' ');

LONG = " Ace 2 3 4 5 6 7 8 9 Ten Jack Queen King".split(' ');

OFFSETX = 468;

W = 263.25;

H = 352;

w = W / 3;

h = H / 3;

LIMIT = 2000; // Maximum steps considered before giving up.

faces = null;

backs = null;

board = null;

cards = null;

hist = null;

cands = null;

hash = null;

aceCards = 4;

originalBoard = null;

start = null;

timing = null;

autoShake = [];

shake = true;

N = null; // Max rank

classic = false;

srcs = null;

dsts = null;

preload = function preload() {
  faces = loadImage('cards/Color_52_Faces_v.2.0.png');
  return backs = loadImage('cards/Playing_Card_Backs.png');
};

range = _.range;

compress = function compress(board) {
  var h1, h2, heap, i, j, l, len, len1, ref, res, results, suit1, suit2, temp, v1, v2;
  results = [];
  for (j = 0, len = HEAPS.length; j < len; j++) {
    heap = HEAPS[j];
    if (board[heap].length > 1) {
      temp = board[heap][0];
      res = [];
      ref = range(1, board[heap].length);
      for (l = 0, len1 = ref.length; l < len1; l++) {
        i = ref[l];
        var _temp = temp;

        var _temp2 = _slicedToArray(_temp, 3);

        suit1 = _temp2[0];
        h1 = _temp2[1];
        v1 = _temp2[2];

        var _board$heap$i = _slicedToArray(board[heap][i], 3);

        suit2 = _board$heap$i[0];
        h2 = _board$heap$i[1];
        v2 = _board$heap$i[2];

        if (suit1 === suit2 && 1 === abs(v1 - h2)) {
          temp = [suit1, h1, v2];
        } else {
          res.push(temp);
          temp = [suit2, h2, v2];
        }
      }
      res.push(temp);
      results.push(board[heap] = res);
    } else {
      results.push(void 0);
    }
  }
  return results;
};

makeBoard = function makeBoard(maxRank, classic) {
  var card, heap, i, j, l, len, len1, len2, len3, len4, len5, m, o, p, q, rank, ref, ref1, ref2, ref3, suit;
  N = maxRank;
  cards = [];
  ref = range(1, maxRank);
  for (j = 0, len = ref.length; j < len; j++) {
    rank = ref[j];
    ref1 = range(4);
    for (l = 0, len1 = ref1.length; l < len1; l++) {
      suit = ref1[l];
      cards.push([suit, rank, rank]);
    }
  }
  cards = _.shuffle(cards);
  board = [];
  ref2 = range(20);
  for (m = 0, len2 = ref2.length; m < len2; m++) {
    i = ref2[m];
    board.push([]);
  }
  ref3 = range(4);
  for (heap = o = 0, len3 = ref3.length; o < len3; heap = ++o) {
    suit = ref3[heap];
    board[heap].push([suit, 0, 0]);
  }
  for (p = 0, len4 = PANEL.length; p < len4; p++) {
    heap = PANEL[p];
    board[heap].push(cards.pop());
  }
  for (i = q = 0, len5 = cards.length; q < len5; i = ++q) {
    card = cards[i];
    board[classic ? 4 + i % 8 : int(random(4, 12))].push(card);
  }
  return compress(board);
};

fakeBoard = function fakeBoard() {
  //board = [[[2,0,0]],[[1,0,0]],[[3,0,0]],[[0,0,0]],[[0,2,2],[1,3,3],[1,1,1],[3,1,1],[3,2,2]],[[0,4,4],[0,12,12],[3,5,5],[1,8,8],[3,9,9]],[[2,11,11],[3,12,12],[0,6,6],[2,5,5],[1,7,7]],[[0,8,8],[3,11,11],[2,6,6],[2,9,9],[1,12,12]],[[0,9,9],[0,10,10],[2,10,10],[2,4,4],[2,7,7]],[[1,2,2],[3,4,4],[3,6,6],[0,5,5],[1,11,11]],[[0,1,1],[0,7,7],[1,10,10],[1,5,5],[3,8,8]],[[0,3,3],[1,4,4],[3,3,3],[2,2,2],[3,10,10]],[[0,11,11]],[[3,7,7]],[[2,1,1]],[[2,8,8]],[],[[1,6,6]],[[2,3,3]],[[2,12,12]],[[1,9,9]]] # nix!
  //board = [[[2,0,0]],[[1,0,0]],[[3,0,0]],[[0,0,0]],[[0,10,10],[2,11,11],[0,6,6],[3,9,9],[1,8,8]],[[3,10,10],[2,10,10],[0,12,12],[0,4,4],[3,1,1]],[[3,12,12],[1,3,3],[1,4,4],[1,9,9],[0,2,2]],[[3,4,4],[3,5,5],[2,5,5],[2,9,9],[2,3,3]],[[3,6,6],[1,7,7],[0,5,5],[2,7,7],[3,8,8]],[[2,4,4],[0,9,9],[1,2,2],[3,11,11],[1,6,6]],[[2,8,8],[2,1,1],[2,2,2],[1,10,10],[3,3,3]],[[1,1,1],[1,11,11],[1,12,12],[3,7,7],[2,12,12]],[[0,11,11]],[[3,2,2]],[[1,5,5]],[[0,8,8]],[],[[2,6,6]],[[0,3,3]],[[0,1,1]],[[0,7,7]]] # 851 ms
  //board = [[[2,0,0]],[[1,0,0]],[[3,0,0]],[[0,0,0]],[[2,3,3],[2,12,12],[2,11,11],[3,10,10],[1,7,7]],[[1,11,11],[0,5,5],[2,9,9],[3,12,12],[1,5,5]],[[0,12,12],[3,8,8],[1,9,9],[0,6,6],[1,6,6]],[[3,1,1],[2,7,7],[0,8,8],[0,7,7],[1,3,3]],[[1,8,8],[0,9,9],[2,10,10],[3,9,9],[1,4,4]],[[1,12,12],[3,2,2],[3,3,3],[3,4,4],[1,2,2]],[[3,6,6],[2,1,1],[0,2,2],[2,8,8],[0,3,3]],[[1,1,1],[3,7,7],[2,6,6],[3,11,11],[0,1,1]],[[2,5,5]],[[2,2,2]],[[1,10,10]],[[2,4,4]],[],[[3,5,5]],[[0,10,10]],[[0,11,11]],[[0,4,4]]] # 963 ms
  //board = [[[2,0,0]],[[1,0,0]],[[3,0,0]],[[0,0,0]],[[3,12,12],[3,9,9],[2,5,5],[3,2,2],[1,10,10]],[[0,1,1],[0,10,10],[2,4,4],[1,3,3],[3,7,7]],[[0,3,3],[0,11,11],[2,7,7],[3,8,8],[1,2,2]],[[0,5,5],[2,6,6],[0,6,6],[3,3,3],[1,5,5]],[[0,4,4],[3,5,5],[0,2,2],[3,10,10],[2,2,2]],[[2,10,10],[0,12,12],[2,1,1],[2,11,11],[0,9,9]],[[3,4,4],[1,7,7],[1,6,6],[2,12,12],[1,8,8]],[[1,1,1],[1,12,12],[1,11,11],[1,4,4],[2,3,3]],[[0,8,8]],[[3,11,11]],[[2,9,9]],[[0,7,7]],[],[[3,1,1]],[[2,8,8]],[[3,6,6]],[[1,9,9]]] # 264 ms
  //board = [[[2,0,0]],[[1,0,0]],[[3,0,0]],[[0,0,0]],[[1,1,1],[0,12,12],[3,3,3],[2,7,7],[3,11,11]],[[2,11,11],[2,8,8],[3,6,6],[0,1,1],[0,6,6]],[[1,8,8],[1,6,6],[0,3,3],[1,3,3],[0,7,7]],[[0,11,11],[1,10,10],[3,12,12],[1,11,11],[1,2,2]],[[0,4,4],[3,2,2],[2,2,2],[3,7,7],[0,5,5]],[[2,5,5],[2,9,9],[3,8,8],[3,9,9],[2,4,4]],[[2,10,10],[0,9,9],[1,12,12],[3,4,4],[3,10,10]],[[2,12,12],[3,5,5],[1,4,4],[2,1,1],[0,2,2]],[[1,5,5]],[[0,10,10]],[[0,8,8]],[[1,9,9]],[],[[3,1,1]],[[1,7,7]],[[2,6,6]],[[2,3,3]]] # 397 ms
  board = [[[2, 0, 0]], [[1, 0, 0]], [[3, 0, 0]], [[0, 0, 0]], [[0, 2, 2], [2, 4, 4], [2, 10, 10], [2, 5, 5], [1, 1, 1], [3, 12, 12], [2, 12, 12], [3, 11, 11], [1, 8, 8], [1, 6, 6]], [[3, 9, 9], [2, 11, 11], [0, 12, 12], [0, 3, 3], [3, 10, 10]], [[3, 3, 3], [0, 9, 9]], [[2, 7, 7], [1, 4, 4], [3, 2, 2], [1, 9, 9], [0, 6, 6], [1, 5, 5], [0, 1, 1]], [[1, 3, 3], [1, 2, 2], [2, 2, 2], [2, 6, 6], [1, 11, 11]], [[3, 7, 7], [2, 8, 8], [1, 7, 7], [3, 1, 1], [0, 8, 8]], [[2, 3, 3], [3, 5, 5], [3, 6, 6]], [[1, 12, 12], [3, 4, 4], [0, 5, 5]], [[0, 7, 7]], [[3, 8, 8]], [[1, 10, 10]], [[0, 11, 11]], [], [[0, 4, 4]], [[0, 10, 10]], [[2, 1, 1]], [[2, 9, 9]]];
  board = [[[2, 0, 0]], [[1, 0, 0]], [[3, 0, 0]], [[0, 0, 0]], [[2, 7, 7], [0, 8, 8], [0, 2, 2], [0, 5, 5]], [[2, 9, 9], [1, 5, 5], [0, 3, 3], [2, 11, 11], [1, 10, 10]], [[2, 2, 2], [1, 8, 8]], [[1, 11, 11], [2, 6, 6], [2, 10, 10], [2, 5, 5], [3, 3, 3], [1, 1, 1]], [[3, 2, 2], [3, 12, 12], [2, 3, 3], [1, 7, 7], [3, 4, 4], [3, 11, 11]], [[3, 8, 8], [0, 10, 10], [3, 7, 7], [0, 12, 12], [1, 3, 3], [0, 9, 9], [1, 12, 12]], [[0, 7, 7], [2, 12, 12], [0, 6, 6], [3, 9, 9]], [[1, 2, 2], [0, 4, 4], [1, 6, 6], [2, 4, 4], [1, 4, 4], [1, 9, 9]], [[3, 6, 6]], [[2, 8, 8]], [[2, 1, 1]], [[3, 10, 10]], [], [[0, 11, 11]], [[0, 1, 1]], [[3, 1, 1]], [[3, 5, 5 // 118 ms
  ]]];
  //board = [[[2,0,0]],[[1,0,0]],[[3,0,0]],[[0,0,0]],[[3,3,3],[2,3,3],[0,6,6],[3,5,5],[0,9,9],[2,10,10],[1,10,10]],[[0,10,10],[0,7,7],[3,8,8],[2,11,11]],[[0,12,12],[3,7,7],[2,1,1],[2,8,8],[1,7,7]],[[1,4,4],[2,5,5],[2,6,6],[1,2,2],[0,1,1],[2,2,2],[3,11,11],[2,7,7]],[[3,6,6],[3,9,9],[0,4,4],[3,4,4],[1,8,8]],[[0,3,3],[3,12,12],[1,11,11]],[[2,4,4],[0,2,2],[3,10,10],[0,8,8]],[[1,5,5],[2,9,9],[1,6,6],[1,1,1]],[[0,5,5]],[[0,11,11]],[[2,12,12]],[[1,3,3]],[],[[1,12,12]],[[1,9,9]],[[3,1,1]],[[3,2,2]]]
  board = [[[2, 0, 0]], [[1, 0, 0]], [[3, 0, 0]], [[0, 0, 0]], [[0, 7, 7], [1, 10, 10], [0, 1, 1], [0, 2, 2], [2, 7, 7]], [[2, 1, 1], [2, 8, 8], [1, 3, 3], [1, 7, 7], [3, 11, 11]], [[2, 2, 2], [3, 6, 6], [3, 8, 8], [2, 4, 4], [0, 3, 3]], [[3, 1, 1], [0, 5, 5], [3, 2, 2], [2, 3, 3], [1, 2, 2]], [[3, 4, 4], [2, 10, 10], [1, 11, 11], [0, 11, 11], [2, 5, 5]], [[3, 9, 9], [0, 6, 6], [2, 11, 11], [0, 10, 10], [3, 12, 12]], [[1, 9, 9], [1, 12, 12], [0, 4, 4], [1, 6, 6], [2, 6, 6]], [[1, 1, 1], [2, 12, 12], [1, 5, 5], [3, 7, 7], [1, 8, 8]], [[3, 10, 10]], [[0, 9, 9]], [[3, 3, 3]], [[0, 12, 12]], [], [[2, 9, 9]], [[0, 8, 8]], [[1, 4, 4]], [[3, 5, 5]]];
  board = [[[2, 0, 0]], [[1, 0, 0]], [[3, 0, 0]], [[0, 0, 0]], [[3, 9, 9], [0, 4, 4], [3, 5, 5], [0, 7, 7], [1, 5, 5]], [[1, 10, 10], [3, 7, 7], [0, 6, 6], [3, 11, 11], [3, 8, 8]], [[2, 2, 2], [3, 1, 1], [1, 1, 1], [1, 9, 9], [0, 9, 9]], [[1, 2, 2], [2, 7, 7], [1, 6, 6], [3, 6, 6], [3, 3, 3]], [[1, 7, 7], [2, 3, 3], [0, 1, 1], [2, 1, 1], [0, 3, 3]], [[2, 8, 8], [1, 11, 11], [2, 6, 6], [0, 10, 10], [3, 4, 4]], [[2, 5, 5], [2, 12, 12], [3, 10, 10], [0, 2, 2], [1, 8, 8]], [[2, 11, 11], [2, 9, 9], [0, 12, 12], [3, 12, 12], [1, 4, 4]], [[1, 12, 12]], [[0, 5, 5]], [[2, 10, 10]], [[3, 2, 2]], [], [[1, 3, 3]], [[2, 4, 4]], [[0, 11, 11]], [[0, 8, 8]]];
  //board = [[[2,0,0]],[[1,0,0]],[[3,0,0]],[[0,0,0]],[[2,10,10],[2,12,12],[1,8,8],[1,12,12],[3,3,3]],[[1,2,2],[0,5,5]],[[3,12,12],[2,4,4],[3,8,8],[1,5,5],[0,8,8]],[[1,11,11],[0,1,1],[0,4,4]],[[1,7,7],[1,3,3],[0,10,10],[3,4,4],[2,1,1],[3,11,11]],[[2,9,9],[2,5,5],[1,6,6],[2,2,2],[1,1,1],[0,3,3]],[[2,6,6],[2,3,3],[3,1,2],[0,2,2],[1,9,9],[3,7,7],[3,10,10],[0,11,11],[2,7,7]],[[2,8,8],[3,6,6],[1,10,10]],[[0,6,6]],[[3,5,5]],[[3,9,9]],[[0,12,12]],[],[[2,11,11]],[[0,9,9]],[[1,4,4]],[[0,7,7]]]
  //board = [[[2,0,0]],[[1,0,0]],[[3,0,0]],[[0,0,0]],[[2,11,11],[1,6,6],[1,8,8],[2,4,4],[1,4,4],[3,9,9],[0,10,10],[2,9,9]],[[0,5,5],[0,11,11],[0,6,6]],[[0,2,2],[2,5,5],[2,1,1],[0,3,3]],[[2,8,8],[2,3,3],[1,9,9],[3,10,10],[0,4,4],[0,1,1],[0,12,12],[2,6,6],[1,12,12]],[[3,5,4],[3,11,11],[1,3,3],[3,6,6],[1,10,10],[3,8,8]],[[0,8,8]],[[1,1,1],[1,11,11]],[[1,7,7],[2,2,2],[1,2,2],[3,3,3],[3,1,2]],[[1,5,5]],[[0,7,7]],[[2,10,10]],[[3,7,7]],[],[[2,12,12]],[[0,9,9]],[[3,12,12]],[[2,7,7]]] # 68000
  return board = [[[0, 0, 0]], [[1, 0, 0]], [[2, 0, 0]], [[3, 0, 0]], [[0, 10, 10], [2, 8, 8], [0, 1, 1], [3, 10, 10], [2, 6, 6]], [[0, 4, 4], [3, 8, 9], [1, 8, 8], [0, 9, 9]], [[3, 3, 3], [1, 2, 2], [3, 11, 11], [2, 10, 10], [2, 2, 2]], [[1, 9, 9], [1, 3, 3], [1, 6, 6], [2, 9, 9], [3, 7, 7]], [[1, 7, 7], [1, 5, 5], [3, 2, 1], [2, 7, 7]], [[3, 6, 6], [1, 11, 11], [0, 11, 11], [1, 1, 1], [2, 11, 11]], [[2, 1, 1], [0, 5, 7], [3, 4, 4]], [[2, 3, 3], [0, 2, 2], [1, 4, 4], [3, 5, 5], [2, 5, 5]], [], [], [[1, 10, 10]], [[0, 3, 3]], [[0, 8, 8]], [[2, 4, 4]], [], []];
};

makeAutoShake = function makeAutoShake() {
  var i, j, len, ref, results;
  autoShake = [];
  ref = range(52);
  results = [];
  for (j = 0, len = ref.length; j < len; j++) {
    i = ref[j];
    results.push(autoShake.push([int(random(-2, 2)), int(random(-2, 2))]));
  }
  return results;
};

setup = function setup() {
  createCanvas(800, 600);
  makeAutoShake();
  newGame('3');
  return display(board);
};

showHeap = function showHeap(board, heap, x, y, dx) {
  var card, dr, j, k, l, len, len1, n, rank, ref, ref1, suit, unvisible, visible, x0, y0;
  n = calcAntal(board[heap]);
  if (n === 0) {
    return;
  }
  x0 = width / 2 - w / 2;
  if (x < 0) {
    x0 += -w + dx;
  }
  if (x > 0) {
    x0 += w - dx;
  }
  x = x0 + x * dx / 2;
  y = y * h;
  ref = board[heap];
  for (k = j = 0, len = ref.length; j < len; k = ++j) {
    card = ref[k];
    var _card = card;

    var _card2 = _slicedToArray(_card, 3);

    suit = _card2[0];
    unvisible = _card2[1];
    visible = _card2[2];

    dr = unvisible < visible ? 1 : -1;
    ref1 = range(unvisible, visible + dr, dr);
    for (l = 0, len1 = ref1.length; l < len1; l++) {
      rank = ref1[l];

      var _ref = shake ? autoShake[13 * suit + rank] : [0, 0];

      var _ref2 = _slicedToArray(_ref, 2);

      x0 = _ref2[0];
      y0 = _ref2[1];

      image(faces, x0 + x, y0 + y + 13, w, h, OFFSETX + W * rank, 1092 + H * suit, 243, H);
      x += dx;
    }
  }
  if (indexOf.call(ACES, heap) >= 0 && card[2] === N - 1) {
    var _ref3 = shake ? autoShake[13 * suit + rank] : [0, 0];

    var _ref4 = _slicedToArray(_ref3, 2);

    x0 = _ref4[0];
    y0 = _ref4[1];

    return image(backs, x0 + x, y0 + y + 13, w, h, OFFSETX + 860, 1092 + 622, 243, H);
  }
};

calcAntal = function calcAntal(lst) {
  var j, len, res, suit, unvisible, visible;
  res = 0;
  for (j = 0, len = lst.length; j < len; j++) {
    var _lst$j = _slicedToArray(lst[j], 3);

    suit = _lst$j[0];
    unvisible = _lst$j[1];
    visible = _lst$j[2];

    res += 1 + abs(unvisible - visible);
  }
  return res;
};

display = function display(board) {
  var dx, heap, j, l, len, len1, len2, len3, m, n, o, ref, ref1, results, x, xx, y;
  background(0, 128, 0);
  textAlign(CENTER, CENTER);
  textSize(10);
  x = width / 2 - 5;
  y = height - 110;
  fill(200);
  text('U = Undo', x, y);
  text('R = Restart', x, y + 10);
  text('3 4 5 6 = Easy', x, y + 20);
  text('7 8 9 T = Medium', x, y + 30);
  text('J Q K = Hard', x, y + 40);
  text('C = Classic', x, y + 50);
  text('Space = Next', x, y + 60);
  if (timing !== null) {
    text(timing + " seconds", x, y + 105);
  }
  textSize(24);
  text(classic ? 'Classic' : LONG[N], x, y + 84);
  textAlign(LEFT, CENTER);
  textSize(10);
  text('Generalens Tidsfördriv', 0, height - 5);
  for (y = j = 0, len = ACES.length; j < len; y = ++j) {
    heap = ACES[y];
    showHeap(board, heap, 0, y, 0);
  }
  ref = [4, 5, 6, 7];
  for (y = l = 0, len1 = ref.length; l < len1; y = ++l) {
    heap = ref[y];
    n = calcAntal(board[heap]);
    dx = n <= 7 ? w / 2 : (width / 2 - w / 2 - w) / (n - 1);
    showHeap(board, heap, -2, y, -dx);
  }
  ref1 = [8, 9, 10, 11];
  for (y = m = 0, len2 = ref1.length; m < len2; y = ++m) {
    heap = ref1[y];
    n = calcAntal(board[heap]);
    dx = n <= 7 ? w / 2 : (width / 2 - w / 2 - w) / (n - 1);
    showHeap(board, heap, 2, y, dx);
  }
  results = [];
  for (x = o = 0, len3 = PANEL.length; o < len3; x = ++o) {
    heap = PANEL[x];
    xx = [-8, -6, -4, -2, 2, 4, 6, 8][x];
    results.push(showHeap(board, heap, xx, 4, w));
  }
  return results;
};

legalMove = function legalMove(board, a, b) {
  var a1, a2, b1, b2, sa, sb;
  if (indexOf.call(ACES, a) >= 0) {
    return false;
  }
  if (indexOf.call(PANEL, b) >= 0) {
    return false;
  }
  if (board[a].length === 0) {
    return false;
  }
  if (board[b].length === 0) {
    return true;
  }

  var _$last = _.last(board[a]);

  var _$last2 = _slicedToArray(_$last, 3);

  sa = _$last2[0];
  a1 = _$last2[1];
  a2 = _$last2[2];

  var _$last3 = _.last(board[b]);

  var _$last4 = _slicedToArray(_$last3, 3);

  sb = _$last4[0];
  b1 = _$last4[1];
  b2 = _$last4[2];

  if (sa === sb && abs(a2 - b2) === 1) {
    return true;
  }
  return false;
};

makeMove = function makeMove(board, a, b, record) {
  // from heap a to heap b
  var suit, unvisible, visible;

  // reverse order
  var _board$a$pop = board[a].pop();

  var _board$a$pop2 = _slicedToArray(_board$a$pop, 3);

  suit = _board$a$pop2[0];
  visible = _board$a$pop2[1];
  unvisible = _board$a$pop2[2];
  if (record) {
    hist.push([a, b, 1 + abs(unvisible - visible)]);
  }
  if (board[b].length > 0) {
    unvisible = board[b].pop()[1];
  }
  return board[b].push([suit, unvisible, visible]);
};

undoMove = function undoMove(_ref5) {
  var _ref6 = _slicedToArray(_ref5, 3),
      a = _ref6[0],
      b = _ref6[1],
      antal = _ref6[2];

  var suit, unvisible, visible;

  var _board$b$pop = board[b].pop();

  var _board$b$pop2 = _slicedToArray(_board$b$pop, 3);

  suit = _board$b$pop2[0];
  unvisible = _board$b$pop2[1];
  visible = _board$b$pop2[2];

  if (unvisible < visible) {
    board[a].push([suit, visible, visible - antal + 1]);
    if (visible !== unvisible + antal - 1) {
      return board[b].push([suit, unvisible, visible - antal]);
    }
  } else {
    board[a].push([suit, visible, visible + antal - 1]);
    if (unvisible !== visible + antal - 1) {
      return board[b].push([suit, unvisible, visible + antal]);
    }
  }
};

mousePressed = function mousePressed() {
  var found, heap, holes, j, l, len, len1, marked, mx, my, ref;
  if (!(0 < mouseX && mouseX < width)) {
    return;
  }
  if (!(0 < mouseY && mouseY < height)) {
    return;
  }
  marked = null;
  mx = Math.floor(mouseX / (W / 3));
  my = Math.floor(mouseY / (H / 3));
  if (my >= 4) {
    if (mx <= 3) {
      marked = 12 + mx;
    }
    if (mx >= 5) {
      marked = 11 + mx;
    }
  } else {
    if (mx === 4) {
      marked = my;
    } else if (mx < 4) {
      marked = [4, 5, 6, 7][my];
    } else {
      marked = [8, 9, 10, 11][my];
    }
  }
  if (marked === null) {
    return;
  }
  holes = [];
  found = false;
  ref = ACES.concat(HEAPS);
  for (j = 0, len = ref.length; j < len; j++) {
    heap = ref[j];
    if (board[heap].length === 0) {
      holes.push(heap);
    }
    if (indexOf.call(holes, heap) < 0 && legalMove(board, marked, heap)) {
      makeMove(board, marked, heap, true);
      found = true;
      break;
    }
  }
  if (!found) {
    for (l = 0, len1 = holes.length; l < len1; l++) {
      heap = holes[l];
      if (legalMove(board, marked, heap)) {
        makeMove(board, marked, heap, true);
        break;
      }
    }
  }
  if (4 * N === countAceCards(board)) {
    timing = Math.floor((millis() - start) / 1000);
  }
  return display(board);
};

//###### AI-section ########
findAllMoves = function findAllMoves(b) {
  var dst, j, l, len, len1, res, src;
  srcs = HEAPS.concat(PANEL);
  dsts = ACES.concat(HEAPS);
  res = [];
  for (j = 0, len = srcs.length; j < len; j++) {
    src = srcs[j];
    for (l = 0, len1 = dsts.length; l < len1; l++) {
      dst = dsts[l];
      if (src !== dst) {
        if (legalMove(b, src, dst)) {
          res.push([src, dst]);
        }
      }
    }
  }
  return res;
};

makeKey = function makeKey(b) {
  // kanske 4-11 bör sorteras först
  var heap, index, j, l, len, len1, r1, r2, res, suit;
  res = '';
  for (index = j = 0, len = b.length; j < len; index = ++j) {
    heap = b[index];
    for (l = 0, len1 = heap.length; l < len1; l++) {
      var _heap$l = _slicedToArray(heap[l], 3);

      suit = _heap$l[0];
      r1 = _heap$l[1];
      r2 = _heap$l[2];

      if (r1 === r2) {
        res += 'chsd'[suit] + RANK[r1];
      } else {
        res += 'chsd'[suit] + RANK[r1] + RANK[r2];
      }
    }
    res += ' ';
  }
  return res;
};

countAceCards = function countAceCards(b) {
  var heap, j, len, res;
  res = 0;
  for (j = 0, len = ACES.length; j < len; j++) {
    heap = ACES[j];
    res += calcAntal(b[heap]);
  }
  return res;
};

expand = function expand(_ref7) {
  var _ref8 = _slicedToArray(_ref7, 3),
      aceCards = _ref8[0],
      level = _ref8[1],
      b = _ref8[2];

  var b1, dst, j, key, len, moves, res, src;
  res = [];
  moves = findAllMoves(b);
  for (j = 0, len = moves.length; j < len; j++) {
    var _moves$j = _slicedToArray(moves[j], 2);

    src = _moves$j[0];
    dst = _moves$j[1];

    b1 = _.cloneDeep(b);
    makeMove(b1, src, dst);
    key = makeKey(b1);
    if (!(key in hash)) {
      hash[key] = [src, dst, b];
      res.push([countAceCards(b1), level + 1, b1]);
    }
  }
  return res;
};

newGame = function newGame(key) {
  var cand, increment, level, nr;
  start = millis();
  timing = null;
  hist = [];
  classic = key === 'C';
  while (true) {
    if (indexOf.call('3456789TJQK', key) >= 0) {
      makeBoard(3 + '3456789TJQK'.indexOf(key), classic);
    }
    if (indexOf.call('C', key) >= 0) {
      makeBoard(13, classic);
    }
    originalBoard = _.cloneDeep(board);
    cands = [];
    cands.push([4, 0, board // antal kort på ässen, antal drag, board
    ]);
    hash = {};
    nr = 0;
    cand = null;
    aceCards = 4;
    while (nr < LIMIT && cands.length > 0 && aceCards < N * 4) {
      nr++;
      cand = cands.pop();
      aceCards = cand[0];
      increment = expand(cand);
      cands = cands.concat(increment);
      cands.sort(function (a, b) {
        if (a[0] === b[0]) {
          return b[1] - a[1];
        } else {
          return a[0] - b[0];
        }
      });
    }
    level = cand[1];
    print(nr, aceCards, level);
    if (aceCards === N * 4) {
      print(JSON.stringify(originalBoard));
      board = cand[2];
      printSolution(hash, board);
      board = _.cloneDeep(originalBoard);
      print(int(millis() - start) + " ms");
      start = millis();
      return;
    }
  }
};

restart = function restart() {
  hist = [];
  return board = _.cloneDeep(originalBoard);
};

nextLevel = function nextLevel() {
  if (4 * N === countAceCards(board)) {
    N++;
  } else {
    N--;
  }
  N = constrain(N, 3, 13);
  classic = false;
  return newGame('   3456789TJQK'[N]);
};

keyPressed = function keyPressed() {
  if (key === 'U' && hist.length > 0) {
    undoMove(hist.pop());
  }
  if (key === 'R') {
    restart();
  }
  if (indexOf.call('3456789TJQKC', key) >= 0) {
    newGame(key);
  }
  if (key === 'A') {
    shake = !shake;
  }
  if (key === ' ') {
    nextLevel();
  }
  return display(board);
};

prettyCard = function prettyCard(_ref9) {
  var _ref10 = _slicedToArray(_ref9, 3),
      suit = _ref10[0],
      unvisible = _ref10[1],
      visible = _ref10[2];

  var antal = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;

  if (antal === 1) {
    return "" + RANK[visible];
  } else {
    return SUIT[suit] + " " + RANK[visible];
  }
};

prettyMove = function prettyMove(src, dst, b) {
  var c1, c2;
  c1 = _.last(b[src]);
  if (b[dst].length > 0) {
    c2 = _.last(b[dst]);
    return prettyCard(c1) + " to " + prettyCard(c2, 1);
  } else {
    if (indexOf.call(HEAPS, dst) >= 0) {
      return prettyCard(c1) + " to hole";
    } else {
      return prettyCard(c1) + " to panel";
    }
  }
};

printSolution = function printSolution(hash, b) {
  var dst, index, j, key, len, s, solution, src;
  key = makeKey(b);
  solution = [];
  while (key in hash) {
    var _hash$key = _slicedToArray(hash[key], 3);

    src = _hash$key[0];
    dst = _hash$key[1];
    b = _hash$key[2];

    solution.push(hash[key]);
    key = makeKey(b);
  }
  solution.reverse();
  s = '';
  for (index = j = 0, len = solution.length; j < len; index = ++j) {
    var _solution$index = _slicedToArray(solution[index], 3);

    src = _solution$index[0];
    dst = _solution$index[1];
    b = _solution$index[2];

    s += "\n" + index + ": " + prettyMove(src, dst, b);
  }
  return print(s);
};
//# sourceMappingURL=sketch.js.map
