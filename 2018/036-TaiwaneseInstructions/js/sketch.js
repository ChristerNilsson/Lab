'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// Generated by CoffeeScript 2.0.3
// negativt x innebär högerjustering. Characters, not pixels
var Grid, HEIGHT, Line, Text, WIDTH, drawComment, g0, g1, g2, g3, index, keyPressed, makeCommands, move, objects, rests, setup, ticks, xdraw;

WIDTH = 10; // pixels per character

HEIGHT = 23; // pixels per character

setup = function setup() {
  createCanvas(800, 600);
  textSize(20);
  textFont('monospace');
  strokeCap(SQUARE);
  makeCommands();
  print(objects);
  return xdraw();
};

ticks = [3, 11, 13];

rests = [2, 7, 10];

objects = [];

g0 = null;

g1 = null;

g2 = null;

g3 = null;

index = 0;

Text = function () {
  function Text(txt, x1, y1) {
    var comment1 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';

    _classCallCheck(this, Text);

    this.txt = txt;
    this.x = x1;
    this.y = y1;
    this.comment = comment1;
  }

  _createClass(Text, [{
    key: 'draw',
    value: function draw(i) {
      var p;
      if (i >= index) {
        return;
      }
      if (this.x < 0) {
        textAlign(RIGHT, TOP);
      } else {
        textAlign(LEFT, TOP);
      }
      if (this.index === index) {
        fc(1, 1, 0);
      } else {
        fc(0);
      }
      sc();
      p = this.parent;
      text(this.txt, WIDTH * (p.x + p.w * abs(this.x)), HEIGHT * (p.y + p.h * this.y));
      if (this.index === index) {
        return drawComment(this.comment);
      }
    }
  }]);

  return Text;
}();

Line = function () {
  function Line(x1, y1, x2, y2, d) {
    var comment1 = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : '';

    _classCallCheck(this, Line);

    this.x1 = x1;
    this.y1 = y1;
    this.x2 = x2;
    this.y2 = y2;
    this.d = d;
    this.comment = comment1;
  }

  _createClass(Line, [{
    key: 'draw',
    value: function draw(i) {
      var p;
      if (i >= index) {
        return;
      }
      sw(this.d);
      if (this.index === index) {
        fc(1, 1, 0);
      } else {
        fc(0);
      }
      p = this.parent;
      line(WIDTH * (p.x + p.w * this.x1 + 0.5), HEIGHT * (p.y + p.h * this.y1), WIDTH * (p.x + p.w * this.x2 + 0.5), HEIGHT * (p.y + p.h * this.y2));
      if (this.index === index) {
        return drawComment(this.comment);
      }
    }
  }]);

  return Line;
}();

Grid = function () {
  function Grid(x1, y1, w, h, xCount, yCount, visible) {
    var comment1 = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : '';

    _classCallCheck(this, Grid);

    this.x = x1;
    this.y = y1;
    this.w = w;
    this.h = h;
    this.xCount = xCount;
    this.yCount = yCount;
    this.visible = visible;
    this.comment = comment1;
    index++;
    this.index = index;
    objects.push(this);
  }

  _createClass(Grid, [{
    key: 'add',
    value: function add(obj) {
      index++;
      obj.index = index;
      objects.push(obj);
      return obj.parent = this;
    }
  }, {
    key: 'draw',
    value: function draw(i) {
      var j, k, l, len, len1, ref, ref1;
      if (this.visible && i <= index) {
        sw(1);
        sc(0);
        if (this.index === index) {
          sc(1, 1, 0);
        } else {
          sc(0);
        }
        ref = range(this.xCount + 1);
        for (k = 0, len = ref.length; k < len; k++) {
          j = ref[k];
          line(WIDTH * (0.5 + this.x + this.w * j), HEIGHT * this.y, WIDTH * (0.5 + this.x + this.w * j), HEIGHT * (this.y + this.yCount * this.h));
        }
        ref1 = range(this.yCount + 1);
        for (l = 0, len1 = ref1.length; l < len1; l++) {
          j = ref1[l];
          line(WIDTH * (0.5 + this.x), HEIGHT * (this.y + this.h * j), WIDTH * (0.5 + this.x + this.xCount * this.w), HEIGHT * (this.y + this.h * j));
        }
      }
      if (this.index === index) {
        return drawComment(this.comment);
      }
    }
  }]);

  return Grid;
}();

makeCommands = function makeCommands() {
  var i, j, k, l, len, len1, len2, len3, m, n, ref, ref1, ref2, ref3, x, y;
  g0 = new Grid(0, 0, 1, 1, 100, 30, false, 'Taiwanese Remainders: Använd piltangenterna');
  g0.add(new Text("Problem:", 0, 0, "Tag reda på vilka klockor man ska klicka på"));
  g0.add(new Text("Klockor: [3,11,13]", 10, 0));
  g0.add(new Text("Rester:  [2, 7,10]", 10, 1));
  g0.add(new Text("Steg: 8", 10, 2));
  g0.add(new Text("(% innebär modulo, dvs resten vid heltalsdivision)", 20, 2));
  g0.add(new Text("Lösning:", 0, 3));
  g1 = new Grid(0, 4, 4, 1, 10, 3, true, 'Chinese Remainders');
  ref = range(3);
  for (k = 0, len = ref.length; k < len; k++) {
    i = ref[k];
    g1.add(new Text(ticks[i], -1, i, 'Klocka ' + ticks[i]));
  }
  ref1 = range(3);
  for (l = 0, len1 = ref1.length; l < len1; l++) {
    i = ref1[l];
    g1.add(new Text(rests[i], -2, i, 'Rest ' + rests[i]));
  }
  g1.add(new Line(2, 0, 2, 3, 3));
  g1.add(new Text(18, -3, 1, "Vrid klockan med näst störst värde (7). 11 + 7 = 18"));
  g1.add(new Text(23, -3, 2, "Vrid klockan med näst störst värde (10). 13 + 10 = 23"));
  g1.add(new Text(29, -4, 1, "Vrid klockan med näst störst värde (18). 11 + 18 = 29"));
  g1.add(new Text(36, -4, 2, "Vrid klockan med näst störst värde"));
  g1.add(new Text(40, -5, 1, "Vrid klockan med näst störst värde"));
  g1.add(new Text(49, -5, 2, "Vrid klockan med näst störst värde"));
  g1.add(new Text(51, -6, 1, "Vrid klockan med näst störst värde"));
  g1.add(new Text(62, -6, 2, "Vrid klockan med näst störst värde"));
  g1.add(new Text(62, -7, 1, "Vrid klockan med näst störst värde"));
  g1.add(new Text('', 0, 0, "De två största klockorna har nu samma värde. Summa=62"));
  g1.add(new Text('', 0, 0, "Kontrollera att alla klockor uppfyller summa % klocka = rest"));
  g1.add(new Text(2, -2, 0, "62 % 3 = 2"));
  g1.add(new Text(7, -2, 1, "62 % 11 = 7"));
  g1.add(new Text(10, -2, 2, "62 % 13 = 10"));
  g1.add(new Text(62, -7, 1, "Detta innebär att summan 62 är den vi söker"));
  g0.add(new Text('', 0, 0, "Nu skapar vi en differensmatris som vi kommer att behöva senare"));
  g2 = new Grid(0, 8, 4, 1, 4, 4, true, 'Differensmatris');
  g2.add(new Text(3, -1, 1, "från-klocka 3"));
  g2.add(new Text(11, -1, 2, "från-klocka 11"));
  g2.add(new Text(13, -1, 3, "från-klocka 13"));
  g2.add(new Line(1, 0, 1, 4, 3));
  g2.add(new Text('Från', 0, 4, "Dessa klockor utgör från-klockor"));
  g2.add(new Text(3, -2, 0, "till-klocka 3"));
  g2.add(new Text(11, -3, 0, "till-klocka 11"));
  g2.add(new Text(13, -4, 0, "till-klocka 13"));
  g2.add(new Line(0, 1, 4, 1, 3));
  g2.add(new Text('Till', 4.2, 0, "Dessa klockor utgör till-klockor"));
  ref2 = range(3);
  for (m = 0, len2 = ref2.length; m < len2; m++) {
    j = ref2[m];
    ref3 = range(3);
    for (n = 0, len3 = ref3.length; n < len3; n++) {
      i = ref3[n];
      x = -2 - i;
      y = 1 + j;
      if (ticks[i] !== ticks[j]) {
        g2.add(new Text(ticks[i] - ticks[j], x, y, 'Differensen blir ' + ticks[i] + ' - ' + ticks[j] + ' = ' + (ticks[i] - ticks[j])));
      }
    }
  }
  g0.add(new Text('', 0, 0, "Nu ska de åtta stegen fördelas på de tre klockorna"));
  g3 = new Grid(4, 14, 4, 1, 3, 5, true, 'Ryggsäcksproblemet');
  g3.add(new Text(3, -1, 0, "Skriv upp klockornas kolumnrubriker"));
  g3.add(new Text(11, -2, 0, "Skriv upp klockornas kolumnrubriker"));
  g3.add(new Text(13, -3, 0, "Skriv upp klockornas kolumnrubriker"));
  g3.add(new Line(0, 1, 3, 1, 3));
  g3.add(new Text('Uppnå summan 62 med 8 steg', 4, 0));
  g3.add(new Text(3, -1, 1, "Fördela de 8 stegen på de 3 klockorna efter eget behag"));
  g3.add(new Text(3, -2, 1, "Fördela de 8 stegen på de tre klockorna efter eget behag"));
  g3.add(new Text(2, -3, 1, "Fördela de 8 stegen på de tre klockorna efter eget behag"));
  g3.add(new Line(0, 2, 3, 2, 2));
  g3.add(new Text('3*3 + 3*11 + 2*13 = 68  (3+3+2=8)', 4, 1, "Beräkna en ny summa, 68. Den måste minskas med 6 för att bli 62"));
  g3.add(new Text('', 0, 0, "I matrisen kan vi erhålla -6, dvs 62-68, genom att addera 2 och -8"));
  g2.add(new Text('2', -4, 2, "Här är 2"));
  g2.add(new Text('-8', -2, 2, "Här är -8"));
  g3.add(new Text('-1', -2, 2, "2 uppnås genom att minska antalet steg på klocka 11 ..."));
  g3.add(new Text('+1', -3, 2, "... och öka antalet steg på klocka 13"));
  g3.add(new Text('Flytta ett steg från klocka 11 till klocka 13', 4, 2, "Observera att ibland blir -2, +3 osv nödvändigt"));
  g3.add(new Text('-1', -2, 3, "-8 uppnås genom att minska antalet steg på klocka 11 ..."));
  g3.add(new Text('+1', -1, 3, "... och öka antalet steg på klocka 3"));
  g3.add(new Text('Flytta ett steg från klocka 11 till klocka 3', 4, 3, "Observera att stegantalet för en klocka ej kan vara negativt"));
  g3.add(new Line(0, 4, 3, 4, 3));
  g3.add(new Text(4, -1, 4, "Beräkna det justerade antalet 3 +1 = 4"));
  g3.add(new Text(1, -2, 4, "Beräkna det justerade antalet 3 -1 -1 = 1"));
  g3.add(new Text(3, -3, 4, "Beräkna det justerade antalet 2 +1 = 3"));
  g3.add(new Text("4*3 + 1*11 + 3*13 = 62", 4, 4, "Kontroll av summa"));
  g0.add(new Text("Svar: Klicka 4, 1 samt 3 gånger på klockorna", 0, 20, "Ibland kan man behöva utföra fler flyttningar"));
  g0.add(new Text("", 0, 0, "Ibland kan man finna flera lösningar"));
  return index = 1;
};

drawComment = function drawComment(comment) {
  fc(0);
  sc();
  textAlign(LEFT, BOTTOM);
  text(comment, 10, height - 10);
  textAlign(RIGHT, BOTTOM);
  return text('#' + index, width - 10, height - 10);
};

xdraw = function xdraw() {
  var i, k, len, obj, results;
  bg(0.5);
  results = [];
  for (i = k = 0, len = objects.length; k < len; i = ++k) {
    obj = objects[i];
    results.push(obj.draw(i));
  }
  return results;
};

move = function move(delta) {
  var i, lst, lstr;
  if (delta === -1) {
    lstr = [objects.length, g3.index, g2.index, g1.index, g0.index];
    i = _.findIndex(lstr, function (x) {
      return index > x;
    });
    if (i === -1) {
      return;
    }
    return index = lstr[i];
  } else {
    lst = [g0.index, g1.index, g2.index, g3.index, objects.length];
    i = _.findIndex(lst, function (x) {
      return index < x;
    });
    if (i === -1) {
      return;
    }
    return index = lst[i];
  }
};

keyPressed = function keyPressed() {
  if (keyCode === LEFT_ARROW) {
    index--;
  }
  if (keyCode === RIGHT_ARROW) {
    index++;
  }
  if (keyCode === UP_ARROW || keyCode === 33) {
    move(-1);
  }
  if (keyCode === DOWN_ARROW || keyCode === 34) {
    move(1);
  }
  if (keyCode === 36) {
    index = 1;
  }
  if (keyCode === 35) {
    index = objects.length;
  }
  index = constrain(index, 1, objects.length);
  return xdraw();
};
//# sourceMappingURL=sketch.js.map
