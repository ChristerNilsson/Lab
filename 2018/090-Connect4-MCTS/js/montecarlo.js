'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// Generated by CoffeeScript 2.3.2
var MonteCarlo, b, mc, n;

MonteCarlo = function () {
  function MonteCarlo(root) {
    _classCallCheck(this, MonteCarlo);

    this.root = root;
  }

  _createClass(MonteCarlo, [{
    key: 'runSearch',
    value: function runSearch() {
      var timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 3;

      var draws, end, node, totalSims, winner;
      draws = 0;
      totalSims = 0;
      end = Date.now() + 100; // 3 * 1000
      while (Date.now() < end) {
        node = this.select();
        winner = node.board.winner();
        if (node.isLeaf() === false && winner === null) {
          node = this.expand(node);
          winner = this.simulate(node);
        }
        this.backpropagate(node, winner);
        if (winner === 0) {
          draws++;
        }
        totalSims++;
      }
      return {
        runtime: timeout,
        simulations: totalSims,
        draws: draws
      };
    }
  }, {
    key: 'bestPlay',
    value: function bestPlay(node) {
      var allPlays, bestPlay, childNode, i, len, max, play, ratio;
      allPlays = node.allPlays();
      bestPlay = null;
      max = -2e308;
      for (i = 0, len = allPlays.length; i < len; i++) {
        play = allPlays[i];
        childNode = node.children[play];
        //ratio = childNode.t / childNode.n
        ratio = childNode.n;
        print('bestPlay', play, childNode.t, childNode.n, childNode.t / childNode.n);
        if (ratio > max) {
          bestPlay = play;
          max = ratio;
        }
      }
      return bestPlay;
    }
  }, {
    key: 'select',
    value: function select() {
      // väljer en nod ur trädet
      var bestPlay, node, pairs, play, plays;
      node = this.root;
      while (node.isFullyExpanded() && !node.isLeaf()) {
        plays = node.allPlays();
        pairs = function () {
          var i, len, results;
          results = [];
          for (i = 0, len = plays.length; i < len; i++) {
            play = plays[i];
            results.push([node.children['' + play].getUCB1(), play]);
          }
          return results;
        }();
        bestPlay = _.max(pairs, function (pair) {
          return pair[0];
        })[1];
        node = node.children['' + bestPlay];
      }
      return node;
    }
  }, {
    key: 'expand',
    value: function expand(node) {
      return node.expand(_.sample(node.unexpandedPlays()));
    }
  }, {
    key: 'simulate',
    value: function simulate(node) {
      var board, winner;
      board = node.board;
      winner = board.winner();
      while (winner === null) {
        board = board.nextBoard(_.sample(board.legalPlays()));
        winner = board.winner();
      }
      //print winner,board
      return winner;
    }
  }, {
    key: 'backpropagate',
    value: function backpropagate(node, winner) {
      var results;
      results = [];
      while (node !== null) {
        node.n++;
        if (node.board.isPlayer(-winner)) {
          node.t++;
        }
        results.push(node = node.parent);
      }
      return results;
    }
  }]);

  return MonteCarlo;
}();

// getStats : (state) ->

//##### tester ######
b = new Board();

n = new Node(null, null, b);

mc = new MonteCarlo(n);

mc.runSearch();

print(mc);

print(mc.bestPlay(mc.root));

// assert mc.root.board.board, ['','','','','','','']
// assert mc.root.board.moves, []
//child = mc.root.children[0]
//assert child.play, 0
//assert child.board.board[0], "X"

// print 'n1'
// n1 = mc.select()
// assert n,n1
// assert n1.board.done(), false
// assert n1.isLeaf(), false
// child = mc.expand n1,0
// print child
// assert child.board.board[child.play], 'X'
// winner = mc.simulate child
// print mc,winner
// mc.backpropagate child,winner
// print mc

// print 'n2'
// n2 = mc.select()
// #assert n,n2
// #assert n1.board.done(), false
// #assert n1.isLeaf(), false
// child = mc.expand n2,0
// print child
// #assert child.board.board[child.play], 'X'
// winner = mc.simulate child
// print mc,winner
// mc.backpropagate child,winner
// print mc
//# sourceMappingURL=montecarlo.js.map
