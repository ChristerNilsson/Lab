"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// Generated by CoffeeScript 2.3.2
var MonteCarlo;

MonteCarlo = function () {
  function MonteCarlo(root) {
    _classCallCheck(this, MonteCarlo);

    this.root = root;
  }

  _createClass(MonteCarlo, [{
    key: "runSearch",
    value: function runSearch() {
      var factor = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;

      var end, node, results, winner;
      end = Date.now() + factor * 50;
      results = [];
      while (Date.now() < end) {
        node = this.select();
        winner = node.board.winner();
        if (winner === null) {
          node = this.expand(node);
          winner = this.simulate(node);
        }
        results.push(this.backpropagate(node, winner));
      }
      return results;
    }
  }, {
    key: "bestPlay",
    value: function bestPlay(node) {
      var allPlays, bestPlay, childNode, i, len, max, play, ratio;
      allPlays = node.allPlays();
      bestPlay = null;
      max = -2e308;
      for (i = 0, len = allPlays.length; i < len; i++) {
        play = allPlays[i];
        childNode = node.children[play];
        //ratio = childNode.t / childNode.n
        ratio = childNode.n;
        if (ratio > max) {
          bestPlay = play;
          max = ratio;
        }
      }
      return bestPlay;
    }
  }, {
    key: "select",
    value: function select() {
      // väljer en nod ur trädet
      var bestPlay, node, pairs, play, plays;
      node = this.root;
      while (node.isFullyExpanded()) {
        plays = node.allPlays();
        pairs = function () {
          var i, len, results;
          results = [];
          for (i = 0, len = plays.length; i < len; i++) {
            play = plays[i];
            results.push([node.children[play].getUCB1(), play]);
          }
          return results;
        }();
        bestPlay = _.max(pairs, function (pair) {
          return pair[0];
        })[1];
        node = node.children[bestPlay];
      }
      return node;
    }
  }, {
    key: "expand",
    value: function expand(node) {
      return node.expand(_.sample(node.unexpandedPlays()));
    }
  }, {
    key: "simulate",
    value: function simulate(node) {
      var board, winner;
      board = node.board;
      winner = board.winner();
      while (winner === null) {
        board = board.nextBoard(_.sample(board.legalPlays()));
        winner = board.winner();
      }
      return winner;
    }
  }, {
    key: "backpropagate",
    value: function backpropagate(node, winner) {
      var results;
      results = [];
      while (node !== null) {
        node.n++;
        if (node.board.isPlayer(-winner)) {
          node.t++;
        }
        results.push(node = node.parent);
      }
      return results;
    }
  }]);

  return MonteCarlo;
}();

// b = new Board()
// n = new Node null,null,b
// mc = new MonteCarlo n
// mc.runSearch()
// print mc
// print mc.bestPlay mc.root

//##### tester ######

// assert mc.root.board.board, ['','','','','','','']
// assert mc.root.board.moves, []
//child = mc.root.children[0]
//assert child.play, 0
//assert child.board.board[0], "X"

// print 'n1'
// n1 = mc.select()
// assert n,n1
// assert n1.board.done(), false
// assert n1.isLeaf(), false
// child = mc.expand n1,0
// print child
// assert child.board.board[child.play], 'X'
// winner = mc.simulate child
// print mc,winner
// mc.backpropagate child,winner
// print mc

// print 'n2'
// n2 = mc.select()
// #assert n,n2
// #assert n1.board.done(), false
// #assert n1.isLeaf(), false
// child = mc.expand n2,0
// print child
// #assert child.board.board[child.play], 'X'
// winner = mc.simulate child
// print mc,winner
// mc.backpropagate child,winner
// print mc
//# sourceMappingURL=montecarlo.js.map
